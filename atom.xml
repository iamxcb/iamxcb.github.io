<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三点钟的太阳</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://iamxcb.com/"/>
  <updated>2019-07-18T01:46:52.075Z</updated>
  <id>https://iamxcb.com/</id>
  
  <author>
    <name>iamxcb</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode 1106. 解析布尔表达式</title>
    <link href="https://iamxcb.com/leetcode-1106.html"/>
    <id>https://iamxcb.com/leetcode-1106.html</id>
    <published>2019-07-17T06:40:34.000Z</published>
    <updated>2019-07-18T01:46:52.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个以字符串形式表述的 布尔表达式（boolean） expression，返回该式的运算结果。<br>有效的表达式需遵循以下约定：</p><ol><li>“t”，运算结果为 True</li><li>“f”，运算结果为 False</li><li>“!(expr)”，运算过程为对内部表达式 expr 进行逻辑 非的运算（NOT）</li><li>“&amp;(expr1,expr2,…)”，运算过程为对 2 个或以上内部表达式 expr1, expr2, … 进行逻辑 与的运算（AND）</li><li>“|(expr1,expr2,…)”，运算过程为对 2 个或以上内部表达式 expr1, expr2, … 进行逻辑 或的运算（OR）</li></ol><p>示例 1：<br>输入：expression = “!(f)”<br>输出：true</p><p>示例 2：<br>输入：expression = “|(f,t)”<br>输出：true</p><p>示例 3：<br>输入：expression = “&amp;(t,f)”<br>输出：false</p><p>示例 4：<br>输入：expression = “|(&amp;(t,f,t),!(t))”<br>输出：false</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>两个栈，一个存操作 <code>stackOp</code>，一个存值 <code>stackVal</code>，遇到字符 <code>)</code> 时计算相应表达式的值（以<code>(</code>开始的表达式），加入栈 <code>stackVal</code></p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseBoolExpr</span><span class="params">(expression <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    stackOp := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>)</span><br><span class="line">    stackVal := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>)</span><br><span class="line">    n := <span class="built_in">len</span>(expression)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> expression[i] == <span class="string">'&amp;'</span> || expression[i] == <span class="string">'|'</span> || expression[i] == <span class="string">'!'</span> &#123;</span><br><span class="line">            stackOp = <span class="built_in">append</span>(stackOp, expression[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> expression[i] == <span class="string">'('</span> || expression[i] == <span class="string">'t'</span> || expression[i] == <span class="string">'f'</span> &#123;</span><br><span class="line">            stackVal = <span class="built_in">append</span>(stackVal, expression[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> expression[i] == <span class="string">')'</span> &#123;</span><br><span class="line">            haveT, haveF := <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">            op := stackOp[<span class="built_in">len</span>(stackOp)<span class="number">-1</span>]</span><br><span class="line">            stackOp = stackOp[:<span class="built_in">len</span>(stackOp)<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">for</span> stackVal[<span class="built_in">len</span>(stackVal)<span class="number">-1</span>] != <span class="string">'('</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> stackVal[<span class="built_in">len</span>(stackVal)<span class="number">-1</span>] == <span class="string">'t'</span> &#123;</span><br><span class="line">                    haveT = <span class="literal">true</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    haveF = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                stackVal = stackVal[:<span class="built_in">len</span>(stackVal)<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            stackVal = stackVal[:<span class="built_in">len</span>(stackVal)<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">'!'</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> haveT &#123;</span><br><span class="line">                    stackVal = <span class="built_in">append</span>(stackVal, <span class="string">'f'</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stackVal = <span class="built_in">append</span>(stackVal, <span class="string">'t'</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">'&amp;'</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> haveF &#123;</span><br><span class="line">                    stackVal = <span class="built_in">append</span>(stackVal, <span class="string">'f'</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stackVal = <span class="built_in">append</span>(stackVal, <span class="string">'t'</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">'|'</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> haveT &#123;</span><br><span class="line">                    stackVal = <span class="built_in">append</span>(stackVal, <span class="string">'t'</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stackVal = <span class="built_in">append</span>(stackVal, <span class="string">'f'</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> stackVal[<span class="number">0</span>] == <span class="string">'t'</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个以字符串形式表述的 布尔表达式（boolean） expression，返回该式的运算结果。&lt;br&gt;有效的表达式需遵
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 30. 串联所有单词的子串</title>
    <link href="https://iamxcb.com/leetcode-30.html"/>
    <id>https://iamxcb.com/leetcode-30.html</id>
    <published>2019-07-16T03:07:39.000Z</published>
    <updated>2019-07-17T08:05:25.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。<br>注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。</p><p>示例 1：<br>输入：<br>  s = “barfoothefoobarman”,<br>  words = [“foo”,”bar”]<br>输出：[0,9]<br>解释：<br>从索引 0 和 9 开始的子串分别是 “barfoor” 和 “foobar” 。<br>输出的顺序不重要, [9,0] 也是有效答案。</p><p>示例 2：<br>输入：<br>  s = “wordgoodgoodgoodbestword”,<br>  words = [“word”,”good”,”best”,”word”]<br>输出：[]</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>暴力解法，直接通过哈希表判断每个子串是否符合题目要求</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findSubstring</span><span class="params">(s <span class="keyword">string</span>, words []<span class="keyword">string</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    m, k := <span class="built_in">len</span>(words), <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">0</span> || k == <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    n := <span class="built_in">len</span>(words[<span class="number">0</span>])</span><br><span class="line">    hashW := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">        hashW[word]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= k-m*n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> isSubstring(s[i:i+m*n], m, n, hashW) &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubstring</span><span class="params">(s <span class="keyword">string</span>, m, n <span class="keyword">int</span>, hashW <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    hashS := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m*n; i += n &#123;</span><br><span class="line">        hashS[s[i:i+n]]++</span><br><span class="line">        <span class="keyword">if</span> hashW[s[i:i+n]] &lt; <span class="number">1</span> || hashS[s[i:i+n]] &gt; hashW[s[i:i+n]] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 87. 扰乱字符串</title>
    <link href="https://iamxcb.com/leetcode-87.html"/>
    <id>https://iamxcb.com/leetcode-87.html</id>
    <published>2019-07-15T07:20:46.000Z</published>
    <updated>2019-07-17T08:35:43.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 s1，我们可以把它递归地分割成两个非空子字符串，从而将其表示为二叉树。</p><p>下图是字符串 s1 = “great” 的一种可能的表示形式。</p><pre><code>great</code></pre><p>   /    \<br>  gr    eat<br> / \    /  \<br>g   r  e   at<br>           / \<br>          a   t<br>在扰乱这个字符串的过程中，我们可以挑选任何一个非叶节点，然后交换它的两个子节点。</p><p>例如，如果我们挑选非叶节点 “gr” ，交换它的两个子节点，将会产生扰乱字符串 “rgeat” 。</p><pre><code>rgeat</code></pre><p>   /    \<br>  rg    eat<br> / \    /  \<br>r   g  e   at<br>           / \<br>          a   t<br>我们将 “rgeat” 称作 “great” 的一个扰乱字符串。</p><p>同样地，如果我们继续将其节点 “eat” 和 “at” 进行交换，将会产生另一个新的扰乱字符串 “rgtae” 。</p><pre><code>rgtae</code></pre><p>   /    \<br>  rg    tae<br> / \    /  \<br>r   g  ta  e<br>       / \<br>      t   a<br>我们将 “rgtae” 称作 “great” 的一个扰乱字符串。</p><p>给出两个长度相等的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。</p><p>示例 1:<br>输入: s1 = “great”, s2 = “rgeat”<br>输出: true</p><p>示例 2:<br>输入: s1 = “abcde”, s2 = “caebd”<br>输出: false</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>递归，<code>i</code> 作为分割位，分割之后的两部分 <code>s[:i+1], s[i+1:]</code> 可能交换，也可能不交换，所以有两种可能</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isScramble</span><span class="params">(s1 <span class="keyword">string</span>, s2 <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1 == s2 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !isSame(s1, s2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    n := <span class="built_in">len</span>(s1)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> isScramble(s1[:i], s2[:i]) &amp;&amp; isScramble(s1[i:], s2[i:]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> isScramble(s1[:i], s2[n-i:]) &amp;&amp; isScramble(s1[i:], s2[:n-i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSame</span><span class="params">(s1, s2 <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(s1)<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        hash[s1[i]]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(s2)<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        hash[s2[i]]--</span><br><span class="line">        <span class="keyword">if</span> hash[s2[i]] &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个字符串 s1，我们可以把它递归地分割成两个非空子字符串，从而将其表示为二叉树。&lt;/p&gt;
&lt;p&gt;下图是字符串 s1 =
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 982. 按位与为零的三元组</title>
    <link href="https://iamxcb.com/leetcode-982.html"/>
    <id>https://iamxcb.com/leetcode-982.html</id>
    <published>2019-07-11T07:01:00.000Z</published>
    <updated>2019-07-18T01:44:04.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 A，找出索引为 (i, j, k) 的三元组，使得：</p><ol><li>0 &lt;= i &lt; A.length</li><li>0 &lt;= j &lt; A.length</li><li>0 &lt;= k &lt; A.length</li><li>A[i] &amp; A[j] &amp; A[k] == 0，其中 &amp; 表示按位与（AND）操作符。</li></ol><p>示例：<br>输入：[2,1,3]<br>输出：12<br>解释：我们可以选出如下 i, j, k 三元组：<br>(i=0, j=0, k=1) : 2 &amp; 2 &amp; 1<br>(i=0, j=1, k=0) : 2 &amp; 1 &amp; 2<br>(i=0, j=1, k=1) : 2 &amp; 1 &amp; 1<br>(i=0, j=1, k=2) : 2 &amp; 1 &amp; 3<br>(i=0, j=2, k=1) : 2 &amp; 3 &amp; 1<br>(i=1, j=0, k=0) : 1 &amp; 2 &amp; 2<br>(i=1, j=0, k=1) : 1 &amp; 2 &amp; 1<br>(i=1, j=0, k=2) : 1 &amp; 2 &amp; 3<br>(i=1, j=1, k=0) : 1 &amp; 1 &amp; 2<br>(i=1, j=2, k=0) : 1 &amp; 3 &amp; 2<br>(i=2, j=0, k=1) : 3 &amp; 2 &amp; 1<br>(i=2, j=1, k=0) : 3 &amp; 1 &amp; 2</p><p>提示：</p><ol><li>1 &lt;= A.length &lt;= 1000</li><li>0 &lt;= A[i] &lt; 2^16</li></ol><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>分两步，先计算 <code>A[i] &amp; A[j]</code> 保存出现的次数，再计算 <code>(A[i] &amp; A[j]) &amp; A[k]</code> 判断是否为零</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countTriplets</span><span class="params">(A []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res, n := <span class="number">0</span>, <span class="built_in">len</span>(A)</span><br><span class="line">    hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            hash[A[i] &amp; A[j]]++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> key, count := <span class="keyword">range</span> hash &#123;</span><br><span class="line">        <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; n; k++ &#123;</span><br><span class="line">            <span class="keyword">if</span> key &amp; A[k] == <span class="number">0</span> &#123;</span><br><span class="line">                res += count</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个整数数组 A，找出索引为 (i, j, k) 的三元组，使得：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;0 &amp;lt;= i &amp;lt
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 36. 有效的数独</title>
    <link href="https://iamxcb.com/leetcode-36.html"/>
    <id>https://iamxcb.com/leetcode-36.html</id>
    <published>2019-07-10T07:23:26.000Z</published>
    <updated>2019-07-17T08:08:37.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p><ol><li>数字 1-9 在每一行只能出现一次。</li><li>数字 1-9 在每一列只能出现一次。</li><li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</li></ol><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt=""></p><p>上图是一个部分填充的有效的数独。</p><p>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p><p>示例 1:<br>输入:<br>[<br>  [“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>  [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>  [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>  [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>  [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>  [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>  [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>  [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>  [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br>输出: true</p><p>示例 2:<br>输入:<br>[<br>  [“8”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>  [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>  [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>  [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>  [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>  [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>  [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>  [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>  [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br>输出: false<br>解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。<br>     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</p><p>说明:<br>一个有效的数独（部分已被填充）不一定是可解的。<br>只需要根据以上规则，验证已经填入的数字是否有效即可。<br>给定数独序列只包含数字 1-9 和字符 ‘.’ 。<br>给定数独永远是 9x9 形式的。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>使用三个二维数组 <code>a, b, c</code> 分别保存每行，每列，每个 3*3 区块中，相应数字出现的次数</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidSudoku</span><span class="params">(board [][]<span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    a := [<span class="number">9</span>][<span class="number">9</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    b := [<span class="number">9</span>][<span class="number">9</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    c := [<span class="number">9</span>][<span class="number">9</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">9</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">9</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="string">'.'</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            num := board[i][j] - <span class="string">'0'</span></span><br><span class="line">            k := (i / <span class="number">3</span>) * <span class="number">3</span> + j / <span class="number">3</span></span><br><span class="line">            a[i][num<span class="number">-1</span>]++</span><br><span class="line">            b[j][num<span class="number">-1</span>]++</span><br><span class="line">            c[k][num<span class="number">-1</span>]++</span><br><span class="line">            <span class="keyword">if</span> a[i][num<span class="number">-1</span>] &gt; <span class="number">1</span> || b[j][num<span class="number">-1</span>] &gt; <span class="number">1</span> || c[k][num<span class="number">-1</span>] &gt; <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数字 1-
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 76. 最小覆盖子串</title>
    <link href="https://iamxcb.com/leetcode-76.html"/>
    <id>https://iamxcb.com/leetcode-76.html</id>
    <published>2019-07-09T03:08:36.000Z</published>
    <updated>2019-07-17T08:32:09.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。</p><p>示例：<br>输入: S = “ADOBECODEBANC”, T = “ABC”<br>输出: “BANC”</p><p>说明：<br>如果 S 中不存这样的子串，则返回空字符串 “”。<br>如果 S 中存在这样的子串，我们保证它是唯一的答案。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>双指针，滑动窗口</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minWindow</span><span class="params">(s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    res := <span class="string">""</span></span><br><span class="line">    left, right := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    hashS := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">    hashT := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> t &#123;</span><br><span class="line">        hashT[<span class="keyword">byte</span>(v)]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> right &lt; n &#123;</span><br><span class="line">        hashS[s[right]]++</span><br><span class="line">        <span class="keyword">for</span> left &lt;= right &amp;&amp; contains(hashS, hashT) &#123;</span><br><span class="line">            <span class="keyword">if</span> res == <span class="string">""</span> &#123;</span><br><span class="line">                res = s[left:right+<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &gt; right-left+<span class="number">1</span> &#123;</span><br><span class="line">                res = s[left:right+<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            hashS[s[left]]--</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        right++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">contains</span><span class="params">(hashS, hashT <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> hashT &#123;</span><br><span class="line">        <span class="keyword">if</span> hashS[k] &lt; v &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;输
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 828. 独特字符串</title>
    <link href="https://iamxcb.com/leetcode-828.html"/>
    <id>https://iamxcb.com/leetcode-828.html</id>
    <published>2019-07-08T06:32:23.000Z</published>
    <updated>2019-07-18T01:35:05.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如果一个字符在字符串 S 中有且仅有出现一次，那么我们称其为独特字符。<br>例如，在字符串 S = “LETTER” 中，”L” 和 “R” 可以被称为独特字符。<br>我们再定义 UNIQ(S) 作为字符串 S 中独特字符的个数。<br>那么，在 S = “LETTER” 中， UNIQ(“LETTER”) =  2。<br>对于给定字符串 S，计算其所有非空子串的独特字符的个数（即 UNIQ(substring)）之和。<br>如果在 S 的不同位置上出现两个甚至多个相同的子串，那么我们认为这些子串是不同的。<br>考虑到答案可能会非常大，规定返回格式为：结果 mod 10 ^ 9 + 7。</p><p>示例 1:<br>输入: “ABC”<br>输出: 10<br>解释: 所有可能的子串为：”A”,”B”,”C”,”AB”,”BC” 和 “ABC”。<br>其中，每一个子串都由独特字符构成。<br>所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10</p><p>示例 2:<br>输入: “ABA”<br>输出: 8<br>解释: 除了子串 UNIQ(‘ABA’) = 1，其余与示例1相同。</p><p>说明: 0 &lt;= S.length &lt;= 10000。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先子串的独特字符的个数和即 <code>sum(UNIQ(substring))</code>，可以转化为求解包含 <code>S[i]</code> 的子串中，<code>S[i]</code> 为独特字符的和即 <code>sum(UNIQ(S[i]))</code> ；<br>同时包含 <code>S[i]</code> 的子串中，可能会存在 <code>S[i]</code> 永远不会为独特字符的子串；<br>当 <code>j &lt; i &amp;&amp; S[j] == S[i]</code> 时，以 <code>S[j]</code> 开始的子串会使 <code>S[i]</code> 永远成不了独特字符；<br>当 <code>k &gt; i &amp;&amp; S[k] == S[i]</code> 时，以 <code>S[k]</code> 结尾的子串会使 <code>S[i]</code> 永远成不了独特字符；<br>所以可以去除这两种情况，在 <code>S[j+1:k]</code> 之间统计 <code>UNIQ(S[i])</code>；<br>最终问题就变成了计算在 <code>S[j+1:k]</code> 之间，包含 <code>S[i]</code> 的子串有多少种可能，因为每个子串中 <code>S[i]</code> 都会是独特字符；<br>在 <code>S[j+1:k]</code> 之间，包含 <code>S[i]</code> 的子串的数量其实就等于 <code>(i - j) * (k - i)</code>；<br><code>S[j+1:i+1], S[j+1:i+2], ..., S[j+1:k]</code>，<code>S[j+2:i+1], S[j+2:i+2], ...., S[j+1:k]</code>，….，<code>S[i:i+1], S[i:i+2], ...., S[i:k]</code></p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniqueLetterString</span><span class="params">(S <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res, n := <span class="number">0</span>, <span class="built_in">len</span>(S)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        j, k := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line">            <span class="keyword">if</span> S[j] == S[i] &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> k = i+<span class="number">1</span>; k &lt; n; k++ &#123;</span><br><span class="line">            <span class="keyword">if</span> S[k] == S[i] &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += (i - j) * (k - i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;如果一个字符在字符串 S 中有且仅有出现一次，那么我们称其为独特字符。&lt;br&gt;例如，在字符串 S = “LETTER” 中，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 140. 单词拆分 II</title>
    <link href="https://iamxcb.com/leetcode-140.html"/>
    <id>https://iamxcb.com/leetcode-140.html</id>
    <published>2019-07-05T06:36:09.000Z</published>
    <updated>2019-07-17T08:51:08.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</p><p>说明：</p><ul><li>分隔时可以重复使用字典中的单词。</li><li>你可以假设字典中没有重复的单词。</li></ul><p>示例 1：<br>输入:<br>s = “catsanddog”<br>wordDict = [“cat”, “cats”, “and”, “sand”, “dog”]<br>输出:<br>[<br>  “cats and dog”,<br>  “cat sand dog”<br>]</p><p>示例 2：<br>输入:<br>s = “pineapplepenapple”<br>wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]<br>输出:<br>[<br>  “pine apple pen apple”,<br>  “pineapple pen apple”,<br>  “pine applepen apple”<br>]<br>解释: 注意你可以重复使用字典中的单词。</p><p>示例 3：<br>输入:<br>s = “catsandog”<br>wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出:<br>[]</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>记忆化回溯，<code>hash[s]</code> 保存相应字符串 <code>s</code> 对应的单词组合</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wordBreak</span><span class="params">(s <span class="keyword">string</span>, wordDict []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span><br><span class="line">    wordHash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> wordDict &#123;</span><br><span class="line">        wordHash[word] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(s, wordDict, hash, wordHash)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(s <span class="keyword">string</span>, wordDict []<span class="keyword">string</span>, hash <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>, wordHash <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := hash[s]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> hash[s]</span><br><span class="line">    &#125;</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        res = <span class="built_in">append</span>(res, <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> wordHash[s[:i+<span class="number">1</span>]] &#123;</span><br><span class="line">            sublist := dfs(s[i+<span class="number">1</span>:], wordDict, hash, wordHash)</span><br><span class="line">            <span class="keyword">for</span> _, sub := <span class="keyword">range</span> sublist &#123;</span><br><span class="line">                space := <span class="string">" "</span></span><br><span class="line">                <span class="keyword">if</span> sub == <span class="string">""</span> &#123;</span><br><span class="line">                    space = <span class="string">""</span></span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">append</span>(res, s[:i+<span class="number">1</span>]+space+sub)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hash[s] = res</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 4. 寻找两个有序数组的中位数</title>
    <link href="https://iamxcb.com/leetcode-4.html"/>
    <id>https://iamxcb.com/leetcode-4.html</id>
    <published>2019-07-04T02:39:12.000Z</published>
    <updated>2019-07-17T07:46:24.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。<br>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。<br>你可以假设 nums1 和 nums2 不会同时为空。</p><p>示例 1:<br>nums1 = [1, 3]<br>nums2 = [2]<br>则中位数是 2.0</p><p>示例 2:<br>nums1 = [1, 2]<br>nums2 = [3, 4]<br>则中位数是 (2 + 3)/2 = 2.5</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>通过 <code>i</code> 划分 <code>nums1</code> 为左右两部分 <code>nums1[0], nums1[1], ..., nums1[i-1]</code> 和 <code>nums1[i], nums1[i+1], ..., nums1[m-1]</code><br>通过 <code>j</code> 划分 <code>nums2</code> 为左右两部分 <code>nums2[0], nums2[1], ..., nums2[j-1]</code> 和 <code>nums2[j], nums2[j+1], ..., nums2[n-1]</code><br>如果 <code>i, j</code> 取值满足条件 <code>i + j = m - i + n - j</code> 和 <code>nums1[i-1] &lt; nums2[j], nums2[j-1] &lt; nums1[i]</code>（说明划分出了长度相等的左右两部分，并且左边的值都小于右边的值）<br>两个有序数组的中位数 <code>(max(nums1[i-1], nums2[j-1]) +  min(nums1[i], nums2[j])) / 2</code></p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    m, n := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">    <span class="keyword">if</span> m &gt; n &#123;</span><br><span class="line">        nums1, nums2 = nums2, nums1</span><br><span class="line">        m, n = n, m</span><br><span class="line">    &#125;</span><br><span class="line">    left, right, half := <span class="number">0</span>, m, (m + n + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        i := (left + right) / <span class="number">2</span></span><br><span class="line">        j := half - i</span><br><span class="line">        <span class="keyword">if</span> i &lt; right &amp;&amp; nums1[i] &lt; nums2[j<span class="number">-1</span>] &#123;</span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> i &gt; left &amp;&amp; nums1[i<span class="number">-1</span>] &gt; nums2[j] &#123;</span><br><span class="line">            right = i - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            maxLeft, minRight := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                maxLeft = nums2[j<span class="number">-1</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> j == <span class="number">0</span> &#123;</span><br><span class="line">                maxLeft = nums1[i<span class="number">-1</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxLeft = max(nums1[i<span class="number">-1</span>], nums2[j<span class="number">-1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (m + n) % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">float64</span>(maxLeft)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> i == m &#123;</span><br><span class="line">                minRight = nums2[j]</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> j == n &#123;</span><br><span class="line">                minRight = nums1[i]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                minRight = min(nums1[i], nums2[j])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">float64</span>(maxLeft + minRight) / <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。&lt;br&gt;请你找出这两个有序数组的中位数，并且要求算法的时
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 315. 计算右侧小于当前元素的个数</title>
    <link href="https://iamxcb.com/leetcode-315.html"/>
    <id>https://iamxcb.com/leetcode-315.html</id>
    <published>2019-07-03T06:11:01.000Z</published>
    <updated>2019-07-17T09:10:48.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。</p><p>示例:<br>输入: [5,2,6,1]<br>输出: [2,1,1,0]<br>解释:<br>5 的右侧有 2 个更小的元素 (2 和 1).<br>2 的右侧仅有 1 个更小的元素 (1).<br>6 的右侧有 1 个更小的元素 (1).<br>1 的右侧有 0 个更小的元素.</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>从后往前遍历 <code>nums</code>，构建二叉搜索树，每个节点要记录其左子树节点的个数 <code>Count</code></p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Left *Node</span><br><span class="line">    Right *Node</span><br><span class="line">    Val <span class="keyword">int</span></span><br><span class="line">    Count <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countSmaller</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> root *Node</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        root = insert(root, nums[i], i, res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(root *Node, val, index <span class="keyword">int</span>, res []<span class="keyword">int</span>)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        root = &amp;Node&#123;<span class="literal">nil</span>, <span class="literal">nil</span>, val, <span class="number">0</span>&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> val &lt;= root.Val &#123;</span><br><span class="line">        root.Count++</span><br><span class="line">        root.Left = insert(root.Left, val, index, res)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res[index] += root.Count + <span class="number">1</span></span><br><span class="line">        root.Right = insert(root.Right, val, index, res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 72. 编辑距离</title>
    <link href="https://iamxcb.com/leetcode-72.html"/>
    <id>https://iamxcb.com/leetcode-72.html</id>
    <published>2019-07-02T03:17:31.000Z</published>
    <updated>2019-07-17T08:30:56.167Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ol><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ol><p>示例 1:<br>输入: word1 = “horse”, word2 = “ros”<br>输出: 3<br>解释:<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p><p>示例 2:<br>输入: word1 = “intention”, word2 = “execution”<br>输出: 5<br>解释:<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>动态规划，<code>dp[i][j]</code> 表示 <code>word1</code> 的前 <code>i</code> 个字母和 <code>word2</code> 的前 <code>j</code> 个字母之间的编辑距离，<code>dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])</code>，特许情况当 <code>word1[i] == word2[j]</code> 时，<code>dp[i][j] = dp[i-1][j-1]</code> 不需要额外操作</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDistance</span><span class="params">(word1 <span class="keyword">string</span>, word2 <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    m, n := <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= m; i++ &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= m; i++ &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>] &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span> + min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。&lt;/p&gt;
&lt;p&gt;你
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 134. 加油站</title>
    <link href="https://iamxcb.com/leetcode-134.html"/>
    <id>https://iamxcb.com/leetcode-134.html</id>
    <published>2019-07-01T06:27:13.000Z</published>
    <updated>2019-07-17T08:48:22.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。<br>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。<br>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p>说明: </p><ul><li>如果题目有解，该答案即为唯一答案。</li><li>输入数组均为非空数组，且长度相同。</li><li>输入数组中的元素均为非负数。</li></ul><p>示例 1:<br>输入:<br>gas  = [1,2,3,4,5]<br>cost = [3,4,5,1,2]<br>输出: 3<br>解释:<br>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油<br>开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油<br>开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油<br>开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油<br>开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油<br>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。<br>因此，3 可为起始索引。</p><p>示例 2:<br>输入:<br>gas  = [2,3,4]<br>cost = [3,4,3]<br>输出: -1<br>解释:<br>你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br>我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油<br>开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油<br>开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油<br>你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。<br>因此，无论怎样，你都不可能绕环路行驶一周。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>找到 <code>gas[i] &gt;= cost[i]</code> 作为起点， 判断是否可以行驶一周</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canCompleteCircuit</span><span class="params">(gas []<span class="keyword">int</span>, cost []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(gas)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> gas[i] &gt;= cost[i] &amp;&amp; canComplete(gas, cost, i) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canComplete</span><span class="params">(gas []<span class="keyword">int</span>, cost []<span class="keyword">int</span>, i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(gas)</span><br><span class="line">    pre := gas[i] - cost[i]</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line">        k := (i+j) % n</span><br><span class="line">        <span class="keyword">if</span> k == i &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre += gas[k] - cost[k]</span><br><span class="line">        <span class="keyword">if</span> pre &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。&lt;br&gt;你有一辆油箱容量无限的的汽车，从第 i 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 165. 比较版本号</title>
    <link href="https://iamxcb.com/leetcode-165.html"/>
    <id>https://iamxcb.com/leetcode-165.html</id>
    <published>2019-06-28T06:31:02.000Z</published>
    <updated>2019-07-17T08:57:00.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>比较两个版本号 version1 和 version2。<br>如果 version1 &gt; version2 返回 1，如果 version1 &lt; version2 返回 -1， 除此之外返回 0。<br>你可以假设版本字符串非空，并且只包含数字和 . 字符。<br> . 字符不代表小数点，而是用于分隔数字序列。<br>例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。<br>你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。</p><p>示例 1:<br>输入: version1 = “0.1”, version2 = “1.1”<br>输出: -1</p><p>示例 2:<br>输入: version1 = “1.0.1”, version2 = “1”<br>输出: 1</p><p>示例 3:<br>输入: version1 = “7.5.2.4”, version2 = “7.5.3”<br>输出: -1</p><p>示例 4：<br>输入：version1 = “1.01”, version2 = “1.001”<br>输出：0<br>解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。</p><p>示例 5：<br>输入：version1 = “1.0”, version2 = “1.0.0”<br>输出：0<br>解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。</p><p>提示：<br>版本字符串由以点 （.） 分隔的数字字符串组成。这个数字字符串可能有前导零。<br>版本字符串不以点开始或结束，并且其中不会有两个连续的点。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先根据 “.” 分割成数组，然后依次比较每一项的值（可以先转为整数再比较，方便一点）</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compareVersion</span><span class="params">(version1 <span class="keyword">string</span>, version2 <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    arr1 := strings.Split(version1, <span class="string">"."</span>)</span><br><span class="line">    arr2 := strings.Split(version2, <span class="string">"."</span>)</span><br><span class="line">    m, n := <span class="built_in">len</span>(arr1), <span class="built_in">len</span>(arr2)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">0</span> ;i &lt; m || j &lt; n; &#123;</span><br><span class="line">        <span class="keyword">if</span> i &lt; m &amp;&amp; j &lt; n &#123;</span><br><span class="line">            num1, _ := strconv.Atoi(arr1[i])</span><br><span class="line">            num2, _ := strconv.Atoi(arr2[j])</span><br><span class="line">            <span class="keyword">if</span> num1 &gt; num2 &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> num1 &lt; num2 &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            &#125;</span><br><span class="line">            i++</span><br><span class="line">            j++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> i == m &amp;&amp; j &lt; n &#123;</span><br><span class="line">            num2, _ := strconv.Atoi(arr2[j])</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt; num2 &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            &#125;</span><br><span class="line">            j++</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> i &lt; m &amp;&amp; j == n &#123;</span><br><span class="line">            num1, _ := strconv.Atoi(arr1[i])</span><br><span class="line">            <span class="keyword">if</span> num1 &gt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;比较两个版本号 version1 和 version2。&lt;br&gt;如果 version1 &amp;gt; version2 返回 1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 556. 下一个更大元素 III</title>
    <link href="https://iamxcb.com/leetcode-556.html"/>
    <id>https://iamxcb.com/leetcode-556.html</id>
    <published>2019-06-27T02:01:05.000Z</published>
    <updated>2019-07-17T09:35:29.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个32位正整数 n，你需要找到最小的32位整数，其与 n 中存在的位数完全相同，并且其值大于n。如果不存在这样的32位整数，则返回-1。</p><p>示例 1:<br>输入: 12<br>输出: 21</p><p>示例 2:<br>输入: 21<br>输出: -1</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><code>n</code> 转为字节数组 <code>b</code>，首先从右到左找到 <code>b[i-1] &lt; b[i]</code> 表明有更大的值大于 <code>n</code>（但不一定是最小的），然后在 <code>b[i:]</code> 里找到大于 <code>b[i-1]</code> 的最小值 <code>b[j]</code>，接着交换 <code>b[i-1], b[j]</code>，反转 <code>b[i:]</code> 按升序排列</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextGreaterElement</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    b := []<span class="keyword">byte</span>(strconv.Itoa(n))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(b)<span class="number">-1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> b[i<span class="number">-1</span>] &lt; b[i] &#123;</span><br><span class="line">            <span class="keyword">for</span> j := <span class="built_in">len</span>(b)<span class="number">-1</span>; j &gt;= i; j-- &#123;</span><br><span class="line">                <span class="keyword">if</span> b[j] &gt; b[i<span class="number">-1</span>] &#123;</span><br><span class="line">                    b[j], b[i<span class="number">-1</span>] = b[i<span class="number">-1</span>], b[j]</span><br><span class="line">                    reverse(b, i)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res, _ := strconv.Atoi(<span class="keyword">string</span>(b))</span><br><span class="line">    <span class="keyword">if</span> res == n || res &gt; math.MaxInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(b []<span class="keyword">byte</span>, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    l, r := i, <span class="built_in">len</span>(b)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">        b[l], b[r] = b[r], b[l]</span><br><span class="line">        l++</span><br><span class="line">        r--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个32位正整数 n，你需要找到最小的32位整数，其与 n 中存在的位数完全相同，并且其值大于n。如果不存在这样的32位
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 131. 分割回文串</title>
    <link href="https://iamxcb.com/leetcode-131.html"/>
    <id>https://iamxcb.com/leetcode-131.html</id>
    <published>2019-06-25T06:11:31.000Z</published>
    <updated>2019-07-17T08:47:14.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。<br>返回 s 所有可能的分割方案。</p><p>示例:<br>输入: “aab”<br>输出:<br>[<br>  [“aa”,”b”],<br>  [“a”,”a”,”b”]<br>]</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>递归回溯，如果字符串的 <code>s[:i]</code> 子串回文，则对剩下的 <code>s[i:]</code> 子串进行递归</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res [][]<span class="keyword">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(s <span class="keyword">string</span>)</span> [][]<span class="title">string</span></span> &#123;</span><br><span class="line">    res = [][]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    dfs(s, []<span class="keyword">string</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(s <span class="keyword">string</span>, arr []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">""</span> &#123;</span><br><span class="line">        tmp := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">        tmp = <span class="built_in">append</span>(tmp, arr...)</span><br><span class="line">        res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> isPalindrome(s[:i]) &#123;</span><br><span class="line">            dfs(s[i:], <span class="built_in">append</span>(arr, <span class="keyword">string</span>(s[:i])))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n/<span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] != s[n-i<span class="number">-1</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。&lt;br&gt;返回 s 所有可能的分割方案。&lt;/p&gt;
&lt;p&gt;示例
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 41. 缺失的第一个正数</title>
    <link href="https://iamxcb.com/leetcode-41.html"/>
    <id>https://iamxcb.com/leetcode-41.html</id>
    <published>2019-06-20T06:19:41.000Z</published>
    <updated>2019-07-17T08:10:26.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p><p>示例 1:<br>输入: [1,2,0]<br>输出: 3</p><p>示例 2:<br>输入: [3,4,-1,1]<br>输出: 2</p><p>示例 3:<br>输入: [7,8,9,11,12]<br>输出: 1</p><p>说明:<br>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>缺失的第一个正数不会大于 <code>n+1</code>；首先将小于 1 的值置为 <code>n+1</code>，然后数组的值作为下标，把相对应的位置 <code>nums[v-1]</code> 变为负数，最后遍历数组判断是否有正数</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstMissingPositive</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v &lt; <span class="number">1</span> &#123;</span><br><span class="line">            nums[i] = n+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        v1 := abs(v)</span><br><span class="line">        <span class="keyword">if</span> v1 &gt; <span class="number">0</span> &amp;&amp; v1 &lt;= n &#123;</span><br><span class="line">            nums[v1<span class="number">-1</span>] = -abs(nums[v1<span class="number">-1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个未排序的整数数组，找出其中没有出现的最小的正整数。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: [1,2,0]&lt;br&gt;输
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 3. 无重复字符的最长子串</title>
    <link href="https://iamxcb.com/leetcode-3.html"/>
    <id>https://iamxcb.com/leetcode-3.html</id>
    <published>2019-06-17T07:21:48.000Z</published>
    <updated>2019-07-17T07:45:02.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><p>示例 2:<br>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p><p>示例 3:<br>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>通过哈希表保存重复字符上一次出现的位置，然后从重复字符的后一个字符作为新的开始，重新计算最长子串的长度</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    res, start := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> last, ok := hash[s[i]]; ok &amp;&amp; last &gt;= start &#123;</span><br><span class="line">            start = last+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        hash[s[i]] = i</span><br><span class="line">        res = max(res, i-start+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: “abcabcbb
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 146. LRU缓存机制</title>
    <link href="https://iamxcb.com/leetcode-146.html"/>
    <id>https://iamxcb.com/leetcode-146.html</id>
    <published>2019-06-15T13:48:17.000Z</published>
    <updated>2019-07-17T08:55:04.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。<br>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p><p>进阶:<br>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><p>示例:<br>LRUCache cache = new LRUCache( 2 /<em> 缓存容量 </em>/ );</p><p>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // 返回  1<br>cache.put(3, 3);    // 该操作会使得密钥 2 作废<br>cache.get(2);       // 返回 -1 (未找到)<br>cache.put(4, 4);    // 该操作会使得密钥 1 作废<br>cache.get(1);       // 返回 -1 (未找到)<br>cache.get(3);       // 返回  3<br>cache.get(4);       // 返回  4</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>主要需要解决的问题就是如何在 O(1) 时间之内找出最近最少使用的值，所以使用了双链表，<code>head</code> 指向双链表的头，<code>tail</code> 指向尾，每次进行 <code>Get, Put</code> 操作时，就把 <code>key</code> 所对应的值 <code>node</code> 移到链表头，<code>tail</code> 所指向的尾部就是最近最少使用的值</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    key   <span class="keyword">int</span></span><br><span class="line">    value <span class="keyword">int</span></span><br><span class="line">    pre   *Node</span><br><span class="line">    next  *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    capacity <span class="keyword">int</span></span><br><span class="line">    hash     <span class="keyword">map</span>[<span class="keyword">int</span>]*Node</span><br><span class="line">    head     *Node</span><br><span class="line">    tail     *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="keyword">int</span>)</span> <span class="title">LRUCache</span></span> &#123;</span><br><span class="line">    cache := LRUCache&#123;capacity: capacity, hash: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*Node)&#125;</span><br><span class="line">    cache.head = &amp;Node&#123;&#125;</span><br><span class="line">    cache.tail = &amp;Node&#123;&#125;</span><br><span class="line">    cache.head.next = cache.tail</span><br><span class="line">    cache.tail.pre = cache.head</span><br><span class="line">    <span class="keyword">return</span> cache</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    node, ok := this.hash[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.remove(node)</span><br><span class="line">    this.setHead(node)</span><br><span class="line">    <span class="keyword">return</span> node.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node, ok := this.hash[key]; ok &#123;</span><br><span class="line">        node.value = value</span><br><span class="line">        this.remove(node)</span><br><span class="line">        this.setHead(node)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(this.hash) &gt;= this.capacity &#123;</span><br><span class="line">            <span class="built_in">delete</span>(this.hash, this.tail.pre.key)</span><br><span class="line">            this.remove(this.tail.pre)</span><br><span class="line">        &#125;</span><br><span class="line">        this.hash[key] = &amp;Node&#123;key: key, value: value&#125;</span><br><span class="line">        this.setHead(this.hash[key])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">setHead</span><span class="params">(node *Node)</span></span> &#123;</span><br><span class="line">    headNext := this.head.next</span><br><span class="line">    this.head.next = node</span><br><span class="line">    node.pre = this.head</span><br><span class="line">    node.next = headNext</span><br><span class="line">    headNext.pre = node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">remove</span><span class="params">(node *Node)</span></span> &#123;</span><br><span class="line">    node.pre.next = node.next</span><br><span class="line">    node.next.pre = node.pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 179. 最大数</title>
    <link href="https://iamxcb.com/leetcode-179.html"/>
    <id>https://iamxcb.com/leetcode-179.html</id>
    <published>2019-06-13T02:49:56.000Z</published>
    <updated>2019-07-17T08:57:46.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</p><p>示例 1:<br>输入: [10,2]<br>输出: 210</p><p>示例 2:<br>输入: [3,30,34,5,9]<br>输出: 9534330</p><p>说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>自定义排序方式，比较 <code>arr[i]+arr[j], arr[j]+arr[i]</code> 两种相连方式，例如比较 “34” 和 “341” 时，可以转换为比较 “34341” 和 “34134”，可以看出 “34” 要排在 “341” 前面</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    arr := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        arr = <span class="built_in">append</span>(arr, strconv.Itoa(v))</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Slice(arr, <span class="function"><span class="keyword">func</span> <span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[i]+arr[j] &gt; arr[j]+arr[i]</span><br><span class="line">    &#125;)</span><br><span class="line">    res := strings.Join(arr, <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(res) &gt; <span class="number">0</span> &amp;&amp; res[<span class="number">0</span>] == <span class="string">'0'</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: [10,2]&lt;br&gt;输
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 93. 复原IP地址</title>
    <link href="https://iamxcb.com/leetcode-93.html"/>
    <id>https://iamxcb.com/leetcode-93.html</id>
    <published>2019-06-12T02:03:14.000Z</published>
    <updated>2019-07-17T08:36:20.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p>示例:<br>输入: “25525511135”<br>输出: [“255.255.11.135”, “255.255.111.35”]</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>dfs 深度优先搜索，每次取 1~3 位为一个 ip 地址段，然后对剩下的字符串进行递归（注意地址段是否合法）</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">restoreIpAddresses</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">    dfs(s, []<span class="keyword">string</span>&#123;&#125;, &amp;res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(s <span class="keyword">string</span>, arr []<span class="keyword">string</span>, res *[]<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> s != <span class="string">""</span> &amp;&amp; <span class="built_in">len</span>(arr) == <span class="number">4</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">""</span> &amp;&amp; <span class="built_in">len</span>(arr) == <span class="number">4</span> &#123;</span><br><span class="line">        *res = <span class="built_in">append</span>(*res, strings.Join(arr, <span class="string">"."</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span> &amp;&amp; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> isLess(s[:i+<span class="number">1</span>], <span class="string">"255"</span>) &amp;&amp; isLegal(s[:i+<span class="number">1</span>]) &#123;</span><br><span class="line">            dfs(s[i+<span class="number">1</span>:], <span class="built_in">append</span>(arr, s[:i+<span class="number">1</span>]), res)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isLess</span><span class="params">(a, b <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    a1, _  := strconv.Atoi(a)</span><br><span class="line">    b1, _  := strconv.Atoi(b)</span><br><span class="line">    <span class="keyword">if</span> a1 &lt;= b1 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isLegal</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> str[<span class="number">0</span>] == <span class="string">'0'</span> &amp;&amp; <span class="built_in">len</span>(str) &gt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。&lt;/p&gt;
&lt;p&gt;示例:&lt;br&gt;输入: “25525511
      
    
    </summary>
    
    
  </entry>
  
</feed>
