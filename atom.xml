<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三点钟的太阳</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://iamxcb.com/"/>
  <updated>2019-07-05T06:52:39.433Z</updated>
  <id>https://iamxcb.com/</id>
  
  <author>
    <name>iamxcb</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode 140. 单词拆分 II</title>
    <link href="https://iamxcb.com/leetcode-140.html"/>
    <id>https://iamxcb.com/leetcode-140.html</id>
    <published>2019-07-05T06:36:09.000Z</published>
    <updated>2019-07-05T06:52:39.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>记忆化回溯，<code>hash[s]</code> 保存相应字符串 <code>s</code> 对应的单词组合</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wordBreak</span><span class="params">(s <span class="keyword">string</span>, wordDict []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span><br><span class="line">wordHash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">for</span> _, word := <span class="keyword">range</span> wordDict &#123;</span><br><span class="line">wordHash[word] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dfs(s, wordDict, hash, wordHash)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(s <span class="keyword">string</span>, wordDict []<span class="keyword">string</span>, hash <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>, wordHash <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := hash[s]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> hash[s]</span><br><span class="line">&#125;</span><br><span class="line">res := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">n := <span class="built_in">len</span>(s)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, <span class="string">""</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> wordHash[s[:i+<span class="number">1</span>]] &#123;</span><br><span class="line">sublist := dfs(s[i+<span class="number">1</span>:], wordDict, hash, wordHash)</span><br><span class="line"><span class="keyword">for</span> _, sub := <span class="keyword">range</span> sublist &#123;</span><br><span class="line">space := <span class="string">" "</span></span><br><span class="line"><span class="keyword">if</span> sub == <span class="string">""</span> &#123;</span><br><span class="line">space = <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">append</span>(res, s[:i+<span class="number">1</span>]+space+sub)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">hash[s] = res</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;记忆化回溯，&lt;code&gt;hash[s]&lt;/code&gt; 保存相应字符串 &lt;code&gt;s&lt;/code&gt; 对应的单词组合&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 4. 寻找两个有序数组的中位数</title>
    <link href="https://iamxcb.com/leetcode-4.html"/>
    <id>https://iamxcb.com/leetcode-4.html</id>
    <published>2019-07-04T02:39:12.000Z</published>
    <updated>2019-07-04T03:12:03.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>通过 <code>i</code> 划分 <code>nums1</code> 为左右两部分 <code>nums1[0], nums1[1], ..., nums1[i-1]</code> 和 <code>nums1[i], nums1[i+1], ..., nums1[m-1]</code><br>通过 <code>j</code> 划分 <code>nums2</code> 为左右两部分 <code>nums2[0], nums2[1], ..., nums2[j-1]</code> 和 <code>nums2[j], nums2[j+1], ..., nums2[n-1]</code><br>如果 <code>i, j</code> 取值满足条件 <code>i + j = m - i + n - j</code> 和 <code>nums1[i-1] &lt; nums2[j], nums2[j-1] &lt; nums1[i]</code>（说明划分出了长度相等的左右两部分，并且左边的值都小于右边的值）<br>两个有序数组的中位数 <code>(max(nums1[i-1], nums2[j-1]) +  min(nums1[i], nums2[j])) / 2</code></p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    m, n := <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">    <span class="keyword">if</span> m &gt; n &#123;</span><br><span class="line">        nums1, nums2 = nums2, nums1</span><br><span class="line">        m, n = n, m</span><br><span class="line">    &#125;</span><br><span class="line">    left, right, half := <span class="number">0</span>, m, (m + n + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        i := (left + right) / <span class="number">2</span></span><br><span class="line">        j := half - i</span><br><span class="line">        <span class="keyword">if</span> i &lt; right &amp;&amp; nums1[i] &lt; nums2[j<span class="number">-1</span>] &#123;</span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> i &gt; left &amp;&amp; nums1[i<span class="number">-1</span>] &gt; nums2[j] &#123;</span><br><span class="line">            right = i - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            maxLeft, minRight := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                maxLeft = nums2[j<span class="number">-1</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> j == <span class="number">0</span> &#123;</span><br><span class="line">                maxLeft = nums1[i<span class="number">-1</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxLeft = max(nums1[i<span class="number">-1</span>], nums2[j<span class="number">-1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (m + n) % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">float64</span>(maxLeft)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> i == m &#123;</span><br><span class="line">                minRight = nums2[j]</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> j == n &#123;</span><br><span class="line">                minRight = nums1[i]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                minRight = min(nums1[i], nums2[j])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">float64</span>(maxLeft + minRight) / <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;通过 &lt;code&gt;i&lt;/code&gt; 划分 &lt;code&gt;nums1&lt;/code&gt; 为左右两部分 &lt;code&gt;nums1[0], nums1[1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 315. 计算右侧小于当前元素的个数</title>
    <link href="https://iamxcb.com/leetcode-315.html"/>
    <id>https://iamxcb.com/leetcode-315.html</id>
    <published>2019-07-03T06:11:01.000Z</published>
    <updated>2019-07-03T06:19:56.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>从后往前遍历 <code>nums</code>，构建二叉搜索树，每个节点要记录其左子树节点的个数 <code>Count</code></p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Left *Node</span><br><span class="line">    Right *Node</span><br><span class="line">    Val <span class="keyword">int</span></span><br><span class="line">    Count <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countSmaller</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> root *Node</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        root = insert(root, nums[i], i, res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(root *Node, val, index <span class="keyword">int</span>, res []<span class="keyword">int</span>)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        root = &amp;Node&#123;<span class="literal">nil</span>, <span class="literal">nil</span>, val, <span class="number">0</span>&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> val &lt;= root.Val &#123;</span><br><span class="line">        root.Count++</span><br><span class="line">        root.Left = insert(root.Left, val, index, res)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res[index] += root.Count + <span class="number">1</span></span><br><span class="line">        root.Right = insert(root.Right, val, index, res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;从后往前遍历 &lt;code&gt;nums&lt;/code&gt;，构建二叉搜索树，每个节点要记录其左子树节点的个数 &lt;code&gt;Count&lt;/code&gt;&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 72. 编辑距离</title>
    <link href="https://iamxcb.com/leetcode-72.html"/>
    <id>https://iamxcb.com/leetcode-72.html</id>
    <published>2019-07-02T03:17:31.000Z</published>
    <updated>2019-07-02T03:24:27.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>动态规划，<code>dp[i][j]</code> 表示 <code>word1</code> 的前 <code>i</code> 个字母和 <code>word2</code> 的前 <code>j</code> 个字母之间的编辑距离，<code>dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])</code>，特许情况当 <code>word1[i] == word2[j]</code> 时，<code>dp[i][j] = dp[i-1][j-1]</code> 不需要额外操作</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDistance</span><span class="params">(word1 <span class="keyword">string</span>, word2 <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    m, n := <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= m; i++ &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= m; i++ &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>] &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span> + min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;动态规划，&lt;code&gt;dp[i][j]&lt;/code&gt; 表示 &lt;code&gt;word1&lt;/code&gt; 的前 &lt;code&gt;i&lt;/code&gt; 个字母
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 134. 加油站</title>
    <link href="https://iamxcb.com/leetcode-134.html"/>
    <id>https://iamxcb.com/leetcode-134.html</id>
    <published>2019-07-01T06:27:13.000Z</published>
    <updated>2019-07-01T06:32:43.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>找到 <code>gas[i] &gt;= cost[i]</code> 作为起点， 判断是否可以行驶一周</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canCompleteCircuit</span><span class="params">(gas []<span class="keyword">int</span>, cost []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(gas)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> gas[i] &gt;= cost[i] &amp;&amp; canComplete(gas, cost, i) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canComplete</span><span class="params">(gas []<span class="keyword">int</span>, cost []<span class="keyword">int</span>, i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(gas)</span><br><span class="line">    pre := gas[i] - cost[i]</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= n; j++ &#123;</span><br><span class="line">        k := (i+j) % n</span><br><span class="line">        <span class="keyword">if</span> k == i &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre += gas[k] - cost[k]</span><br><span class="line">        <span class="keyword">if</span> pre &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;找到 &lt;code&gt;gas[i] &amp;gt;= cost[i]&lt;/code&gt; 作为起点， 判断是否可以行驶一周&lt;/p&gt;
&lt;h2 id=&quot;示例代码
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 165. 比较版本号</title>
    <link href="https://iamxcb.com/leetcode-165.html"/>
    <id>https://iamxcb.com/leetcode-165.html</id>
    <published>2019-06-28T06:31:02.000Z</published>
    <updated>2019-06-28T06:35:49.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先根据 “.” 分割成数组，然后依次比较每一项的值（可以先转为整数再比较，方便一点）</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compareVersion</span><span class="params">(version1 <span class="keyword">string</span>, version2 <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    arr1 := strings.Split(version1, <span class="string">"."</span>)</span><br><span class="line">    arr2 := strings.Split(version2, <span class="string">"."</span>)</span><br><span class="line">    m, n := <span class="built_in">len</span>(arr1), <span class="built_in">len</span>(arr2)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">0</span> ;i &lt; m || j &lt; n; &#123;</span><br><span class="line">        <span class="keyword">if</span> i &lt; m &amp;&amp; j &lt; n &#123;</span><br><span class="line">            num1, _ := strconv.Atoi(arr1[i])</span><br><span class="line">            num2, _ := strconv.Atoi(arr2[j])</span><br><span class="line">            <span class="keyword">if</span> num1 &gt; num2 &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> num1 &lt; num2 &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            &#125;</span><br><span class="line">            i++</span><br><span class="line">            j++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> i == m &amp;&amp; j &lt; n &#123;</span><br><span class="line">            num2, _ := strconv.Atoi(arr2[j])</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt; num2 &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            &#125;</span><br><span class="line">            j++</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> i &lt; m &amp;&amp; j == n &#123;</span><br><span class="line">            num1, _ := strconv.Atoi(arr1[i])</span><br><span class="line">            <span class="keyword">if</span> num1 &gt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;首先根据 “.” 分割成数组，然后依次比较每一项的值（可以先转为整数再比较，方便一点）&lt;/p&gt;
&lt;h2 id=&quot;示例代码-go&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 556. 下一个更大元素 III</title>
    <link href="https://iamxcb.com/leetcode-556.html"/>
    <id>https://iamxcb.com/leetcode-556.html</id>
    <published>2019-06-27T02:01:05.000Z</published>
    <updated>2019-06-27T03:10:40.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><code>n</code> 转为字节数组 <code>b</code>，首先从右到左找到 <code>b[i-1] &lt; b[i]</code> 表明有更大的值大于 <code>n</code>（但不一定是最小的），然后在 <code>b[i:]</code> 里找到大于 <code>b[i-1]</code> 的最小值 <code>b[j]</code>，接着交换 <code>b[i-1], b[j]</code>，反转 <code>b[i:]</code> 按升序排列</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextGreaterElement</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    b := []<span class="keyword">byte</span>(strconv.Itoa(n))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(b)<span class="number">-1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> b[i<span class="number">-1</span>] &lt; b[i] &#123;</span><br><span class="line">            <span class="keyword">for</span> j := <span class="built_in">len</span>(b)<span class="number">-1</span>; j &gt;= i; j-- &#123;</span><br><span class="line">                <span class="keyword">if</span> b[j] &gt; b[i<span class="number">-1</span>] &#123;</span><br><span class="line">                    b[j], b[i<span class="number">-1</span>] = b[i<span class="number">-1</span>], b[j]</span><br><span class="line">                    reverse(b, i)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res, _ := strconv.Atoi(<span class="keyword">string</span>(b))</span><br><span class="line">    <span class="keyword">if</span> res == n || res &gt; math.MaxInt32 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(b []<span class="keyword">byte</span>, i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    l, r := i, <span class="built_in">len</span>(b)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">        b[l], b[r] = b[r], b[l]</span><br><span class="line">        l++</span><br><span class="line">        r--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 转为字节数组 &lt;code&gt;b&lt;/code&gt;，首先从右到左找到 &lt;code&gt;b[i-1] &amp;lt; b[i]&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 131. 分割回文串</title>
    <link href="https://iamxcb.com/leetcode-131.html"/>
    <id>https://iamxcb.com/leetcode-131.html</id>
    <published>2019-06-25T06:11:31.000Z</published>
    <updated>2019-06-25T06:14:38.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>递归回溯，如果字符串的 <code>s[:i]</code> 子串回文，则对剩下的 <code>s[i:]</code> 子串进行递归</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res [][]<span class="keyword">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(s <span class="keyword">string</span>)</span> [][]<span class="title">string</span></span> &#123;</span><br><span class="line">    res = [][]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    dfs(s, []<span class="keyword">string</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(s <span class="keyword">string</span>, arr []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">""</span> &#123;</span><br><span class="line">        tmp := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">        tmp = <span class="built_in">append</span>(tmp, arr...)</span><br><span class="line">        res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> isPalindrome(s[:i]) &#123;</span><br><span class="line">            dfs(s[i:], <span class="built_in">append</span>(arr, <span class="keyword">string</span>(s[:i])))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n/<span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] != s[n-i<span class="number">-1</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;递归回溯，如果字符串的 &lt;code&gt;s[:i]&lt;/code&gt; 子串回文，则对剩下的 &lt;code&gt;s[i:]&lt;/code&gt; 子串进行递归&lt;/p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 41. 缺失的第一个正数</title>
    <link href="https://iamxcb.com/leetcode-41.html"/>
    <id>https://iamxcb.com/leetcode-41.html</id>
    <published>2019-06-20T06:19:41.000Z</published>
    <updated>2019-06-20T06:35:45.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>缺失的第一个正数不会大于 <code>n+1</code>；首先将小于 1 的值置为 <code>n+1</code>，然后数组的值作为下标，把相对应的位置 <code>nums[v-1]</code> 变为负数，最后遍历数组判断是否有正数</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstMissingPositive</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v &lt; <span class="number">1</span> &#123;</span><br><span class="line">            nums[i] = n+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        v1 := abs(v)</span><br><span class="line">        <span class="keyword">if</span> v1 &gt; <span class="number">0</span> &amp;&amp; v1 &lt;= n &#123;</span><br><span class="line">            nums[v1<span class="number">-1</span>] = -abs(nums[v1<span class="number">-1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;缺失的第一个正数不会大于 &lt;code&gt;n+1&lt;/code&gt;；首先将小于 1 的值置为 &lt;code&gt;n+1&lt;/code&gt;，然后数组的值作为下标
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 3. 无重复字符的最长子串</title>
    <link href="https://iamxcb.com/leetcode-3.html"/>
    <id>https://iamxcb.com/leetcode-3.html</id>
    <published>2019-06-17T07:21:48.000Z</published>
    <updated>2019-06-17T07:27:59.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>通过哈希表保存重复字符上一次出现的位置，然后从重复字符的后一个字符作为新的开始，重新计算最长子串的长度</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    res, start := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> last, ok := hash[s[i]]; ok &amp;&amp; last &gt;= start &#123;</span><br><span class="line">            start = last+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        hash[s[i]] = i</span><br><span class="line">        res = max(res, i-start+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;通过哈希表保存重复字符上一次出现的位置，然后从重复字符的后一个字符作为新的开始，重新计算最长子串的长度&lt;/p&gt;
&lt;h2 id=&quot;示例代码-g
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 146. LRU缓存机制</title>
    <link href="https://iamxcb.com/leetcode-146.html"/>
    <id>https://iamxcb.com/leetcode-146.html</id>
    <published>2019-06-15T13:48:17.000Z</published>
    <updated>2019-06-20T06:36:39.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>主要需要解决的问题就是如何在 O(1) 时间之内找出最近最少使用的值，所以使用了双链表，<code>head</code> 指向双链表的头，<code>tail</code> 指向尾，每次进行 <code>Get, Put</code> 操作时，就把 <code>key</code> 所对应的值 <code>node</code> 移到链表头，<code>tail</code> 所指向的尾部就是最近最少使用的值</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    key   <span class="keyword">int</span></span><br><span class="line">    value <span class="keyword">int</span></span><br><span class="line">    pre   *Node</span><br><span class="line">    next  *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    capacity <span class="keyword">int</span></span><br><span class="line">    hash     <span class="keyword">map</span>[<span class="keyword">int</span>]*Node</span><br><span class="line">    head     *Node</span><br><span class="line">    tail     *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="keyword">int</span>)</span> <span class="title">LRUCache</span></span> &#123;</span><br><span class="line">    cache := LRUCache&#123;capacity: capacity, hash: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*Node)&#125;</span><br><span class="line">    cache.head = &amp;Node&#123;&#125;</span><br><span class="line">    cache.tail = &amp;Node&#123;&#125;</span><br><span class="line">    cache.head.next = cache.tail</span><br><span class="line">    cache.tail.pre = cache.head</span><br><span class="line">    <span class="keyword">return</span> cache</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    node, ok := this.hash[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.remove(node)</span><br><span class="line">    this.setHead(node)</span><br><span class="line">    <span class="keyword">return</span> node.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node, ok := this.hash[key]; ok &#123;</span><br><span class="line">        node.value = value</span><br><span class="line">        this.remove(node)</span><br><span class="line">        this.setHead(node)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(this.hash) &gt;= this.capacity &#123;</span><br><span class="line">            <span class="built_in">delete</span>(this.hash, this.tail.pre.key)</span><br><span class="line">            this.remove(this.tail.pre)</span><br><span class="line">        &#125;</span><br><span class="line">        this.hash[key] = &amp;Node&#123;key: key, value: value&#125;</span><br><span class="line">        this.setHead(this.hash[key])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">setHead</span><span class="params">(node *Node)</span></span> &#123;</span><br><span class="line">    headNext := this.head.next</span><br><span class="line">    this.head.next = node</span><br><span class="line">    node.pre = this.head</span><br><span class="line">    node.next = headNext</span><br><span class="line">    headNext.pre = node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span> <span class="title">remove</span><span class="params">(node *Node)</span></span> &#123;</span><br><span class="line">    node.pre.next = node.next</span><br><span class="line">    node.next.pre = node.pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;主要需要解决的问题就是如何在 O(1) 时间之内找出最近最少使用的值，所以使用了双链表，&lt;code&gt;head&lt;/code&gt; 指向双链表的头，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 179. 最大数</title>
    <link href="https://iamxcb.com/leetcode-179.html"/>
    <id>https://iamxcb.com/leetcode-179.html</id>
    <published>2019-06-13T02:49:56.000Z</published>
    <updated>2019-06-13T02:56:42.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>自定义排序方式，比较 <code>arr[i]+arr[j], arr[j]+arr[i]</code> 两种相连方式，例如比较 “34” 和 “341” 时，可以转换为比较 “34341” 和 “34134”，可以看出 “34” 要排在 “341” 前面</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    arr := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        arr = <span class="built_in">append</span>(arr, strconv.Itoa(v))</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Slice(arr, <span class="function"><span class="keyword">func</span> <span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[i]+arr[j] &gt; arr[j]+arr[i]</span><br><span class="line">    &#125;)</span><br><span class="line">    res := strings.Join(arr, <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(res) &gt; <span class="number">0</span> &amp;&amp; res[<span class="number">0</span>] == <span class="string">'0'</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;自定义排序方式，比较 &lt;code&gt;arr[i]+arr[j], arr[j]+arr[i]&lt;/code&gt; 两种相连方式，例如比较 “34” 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 93. 复原IP地址</title>
    <link href="https://iamxcb.com/leetcode-93.html"/>
    <id>https://iamxcb.com/leetcode-93.html</id>
    <published>2019-06-12T02:03:14.000Z</published>
    <updated>2019-06-12T02:09:33.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>dfs 深度优先搜索，每次取 1~3 位为一个 ip 地址段，然后对剩下的字符串进行递归（注意地址段是否合法）</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">restoreIpAddresses</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">    dfs(s, []<span class="keyword">string</span>&#123;&#125;, &amp;res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(s <span class="keyword">string</span>, arr []<span class="keyword">string</span>, res *[]<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> s != <span class="string">""</span> &amp;&amp; <span class="built_in">len</span>(arr) == <span class="number">4</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">""</span> &amp;&amp; <span class="built_in">len</span>(arr) == <span class="number">4</span> &#123;</span><br><span class="line">        *res = <span class="built_in">append</span>(*res, strings.Join(arr, <span class="string">"."</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span> &amp;&amp; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> isLess(s[:i+<span class="number">1</span>], <span class="string">"255"</span>) &amp;&amp; isLegal(s[:i+<span class="number">1</span>]) &#123;</span><br><span class="line">            dfs(s[i+<span class="number">1</span>:], <span class="built_in">append</span>(arr, s[:i+<span class="number">1</span>]), res)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isLess</span><span class="params">(a, b <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    a1, _  := strconv.Atoi(a)</span><br><span class="line">    b1, _  := strconv.Atoi(b)</span><br><span class="line">    <span class="keyword">if</span> a1 &lt;= b1 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isLegal</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> str[<span class="number">0</span>] == <span class="string">'0'</span> &amp;&amp; <span class="built_in">len</span>(str) &gt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;dfs 深度优先搜索，每次取 1~3 位为一个 ip 地址段，然后对剩下的字符串进行递归（注意地址段是否合法）&lt;/p&gt;
&lt;h2 id=&quot;示例
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 130. 被围绕的区域</title>
    <link href="https://iamxcb.com/leetcode-130.html"/>
    <id>https://iamxcb.com/leetcode-130.html</id>
    <published>2019-06-11T06:10:50.000Z</published>
    <updated>2019-06-11T06:16:56.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>bfs 广度优先搜索，首先把边界上出现的 <code>O</code> 以及相连的 <code>O</code> 置为 <code>S</code>，然后遍历二维矩阵 <code>board</code>， <code>O</code> 置为 <code>X</code>, <code>S</code> 置为 <code>O</code></p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solve</span><span class="params">(board [][]<span class="keyword">byte</span>)</span></span>  &#123;</span><br><span class="line">    m, n := <span class="built_in">len</span>(board), <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> m &gt; <span class="number">0</span> &#123;</span><br><span class="line">        n = <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> board[<span class="number">0</span>][j] == <span class="string">'O'</span> &#123;</span><br><span class="line">            bfs(board, m, n, <span class="number">0</span>, j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> board[i][<span class="number">0</span>] == <span class="string">'O'</span> &#123;</span><br><span class="line">            bfs(board, m, n, i, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> board[i][n<span class="number">-1</span>] == <span class="string">'O'</span> &#123;</span><br><span class="line">            bfs(board, m, n, i, n<span class="number">-1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> board[m<span class="number">-1</span>][j] == <span class="string">'O'</span> &#123;</span><br><span class="line">            bfs(board, m, n, m<span class="number">-1</span>, j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="string">'S'</span> &#123;</span><br><span class="line">                board[i][j] = <span class="string">'O'</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> board[i][j] == <span class="string">'O'</span> &#123;</span><br><span class="line">                board[i][j] = <span class="string">'X'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bfs</span><span class="params">(board [][]<span class="keyword">byte</span>, m, n, i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> board[i][j] == <span class="string">'O'</span> &#123;</span><br><span class="line">        board[i][j] = <span class="string">'S'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> i<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; board[i<span class="number">-1</span>][j] == <span class="string">'O'</span> &#123;</span><br><span class="line">        bfs(board, m, n, i<span class="number">-1</span>, j)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> i+<span class="number">1</span> &lt; m &amp;&amp; board[i+<span class="number">1</span>][j] == <span class="string">'O'</span> &#123;</span><br><span class="line">        bfs(board, m, n, i+<span class="number">1</span>, j)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> j<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; board[i][j<span class="number">-1</span>] == <span class="string">'O'</span> &#123;</span><br><span class="line">        bfs(board, m, n, i, j<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> j+<span class="number">1</span> &lt; n &amp;&amp; board[i][j+<span class="number">1</span>] == <span class="string">'O'</span> &#123;</span><br><span class="line">        bfs(board, m, n, i, j+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;bfs 广度优先搜索，首先把边界上出现的 &lt;code&gt;O&lt;/code&gt; 以及相连的 &lt;code&gt;O&lt;/code&gt; 置为 &lt;code&gt;S&lt;/c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 127. 单词接龙</title>
    <link href="https://iamxcb.com/leetcode-127.html"/>
    <id>https://iamxcb.com/leetcode-127.html</id>
    <published>2019-06-10T09:08:21.000Z</published>
    <updated>2019-06-10T09:15:20.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>bfs 思想，根据前面已经入队 <code>queue</code> 的单词 <code>beginWord</code>，然后把可以转换的单词 <code>word</code> 加入队列</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ladderLength</span><span class="params">(beginWord <span class="keyword">string</span>, endWord <span class="keyword">string</span>, wordList []<span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    visited := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">    queue := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">    queue = <span class="built_in">append</span>(queue, beginWord)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        res++</span><br><span class="line">        n := <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            beginWord := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">for</span> j, word := <span class="keyword">range</span> wordList &#123;</span><br><span class="line">                <span class="keyword">if</span> !visited[j] &amp;&amp; canTransform(beginWord, word) &#123;</span><br><span class="line">                    <span class="keyword">if</span> word == endWord &#123;</span><br><span class="line">                        <span class="keyword">return</span> res + <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    visited[j] = <span class="literal">true</span></span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, word)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canTransform</span><span class="params">(beginWord <span class="keyword">string</span>, endWord <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(beginWord)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> beginWord[:i] + beginWord[i+<span class="number">1</span>:] == endWord[:i] + endWord[i+<span class="number">1</span>:] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;bfs 思想，根据前面已经入队 &lt;code&gt;queue&lt;/code&gt; 的单词 &lt;code&gt;beginWord&lt;/code&gt;，然后把可以转换的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 227. 基本计算器 II</title>
    <link href="https://iamxcb.com/leetcode-227.html"/>
    <id>https://iamxcb.com/leetcode-227.html</id>
    <published>2019-06-06T12:03:23.000Z</published>
    <updated>2019-06-14T09:55:55.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>遍历字符串 <code>s</code> ，取出数值 <code>num</code> 存入 <code>stack</code> 栈中，主要是通过前边的操作符 <code>op</code> 判断如何存入数值，<code>+, -</code> 则直接存 <code>num</code> 的值或者取反后再存入，<code>*, /</code> 的话则要计算之后再存入，最后把 <code>stack</code> 栈中的数值相加起来</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    stack := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">var</span> op <span class="keyword">byte</span></span><br><span class="line">    op = <span class="string">'+'</span></span><br><span class="line">    num := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] &gt;= <span class="string">'0'</span> &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + <span class="keyword">int</span>(s[i] - <span class="string">'0'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &lt; <span class="string">'0'</span> &amp;&amp; s[i] != <span class="string">' '</span>) || i == n<span class="number">-1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">'+'</span> &#123;</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, num)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">'-'</span> &#123;</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, -num)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">'*'</span> &#123;</span><br><span class="line">                tmp := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] * num</span><br><span class="line">                stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, tmp)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">'/'</span> &#123;</span><br><span class="line">                tmp := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] / num</span><br><span class="line">                stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, tmp)</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            op = s[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> stack &#123;</span><br><span class="line">        res += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;遍历字符串 &lt;code&gt;s&lt;/code&gt; ，取出数值 &lt;code&gt;num&lt;/code&gt; 存入 &lt;code&gt;stack&lt;/code&gt; 栈中，主
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 454. 四数相加 II</title>
    <link href="https://iamxcb.com/leetcode-454.html"/>
    <id>https://iamxcb.com/leetcode-454.html</id>
    <published>2019-06-05T03:24:02.000Z</published>
    <updated>2019-06-05T03:33:06.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先遍历 <code>A</code> 和 <code>B</code> 元素和的组合情况，并记录在 <code>hash</code> 中，然后遍历 <code>C</code> 和 <code>D</code> 元素和的组合情况，判断取反后的值是否在 <code>hash</code> 表中</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fourSumCount</span><span class="params">(A []<span class="keyword">int</span>, B []<span class="keyword">int</span>, C []<span class="keyword">int</span>, D []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    hash := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, a := <span class="keyword">range</span> A &#123;</span><br><span class="line">        <span class="keyword">for</span> _, b := <span class="keyword">range</span> B &#123;</span><br><span class="line">            hash[a+b]++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> C &#123;</span><br><span class="line">        <span class="keyword">for</span> _, d := <span class="keyword">range</span> D &#123;</span><br><span class="line">            <span class="keyword">if</span> v, ok := hash[-c-d]; ok &#123;</span><br><span class="line">                res += v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;首先遍历 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 元素和的组合情况，并记录在 &lt;code&gt;hash&lt;/code&gt; 中
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 221. 最大正方形</title>
    <link href="https://iamxcb.com/leetcode-221.html"/>
    <id>https://iamxcb.com/leetcode-221.html</id>
    <published>2019-06-03T07:06:50.000Z</published>
    <updated>2019-06-03T07:17:03.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>动态规划，<code>dp[i][j]</code> 表示正方形的边长（其中i, j代表正方形的右下角）, 地推公式：<code>dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])</code></p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> area <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximalSquare</span><span class="params">(matrix [][]<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    area = <span class="number">0</span></span><br><span class="line">    m := <span class="built_in">len</span>(matrix)</span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> area</span><br><span class="line">    &#125;</span><br><span class="line">    n := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, m)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m ; i++ &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="string">'1'</span> &#123;</span><br><span class="line">                computeSquare(dp, i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">computeSquare</span><span class="params">(dp [][]<span class="keyword">int</span>, i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    dp[i][j] = <span class="number">1</span></span><br><span class="line">    area = max(area, dp[i][j])</span><br><span class="line">    <span class="keyword">if</span> i<span class="number">-1</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> j<span class="number">-1</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp[i][j] += min(min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]), dp[i<span class="number">-1</span>][j<span class="number">-1</span>])</span><br><span class="line">    area = max(area, dp[i][j]*dp[i][j])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;动态规划，&lt;code&gt;dp[i][j]&lt;/code&gt; 表示正方形的边长（其中i, j代表正方形的右下角）, 地推公式：&lt;code&gt;dp[i]
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 399. 除法求值</title>
    <link href="https://iamxcb.com/leetcode-399.html"/>
    <id>https://iamxcb.com/leetcode-399.html</id>
    <published>2019-05-31T07:29:06.000Z</published>
    <updated>2019-05-31T07:41:49.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>dfs深度搜索思想，首先遍历 <code>queries</code> 找出被除数 <code>a</code>，除数 <code>b</code>，然后根据 <code>equations</code> 找出 <code>a / b</code> 的值</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcEquation</span><span class="params">(equations [][]<span class="keyword">string</span>, values []<span class="keyword">float64</span>, queries [][]<span class="keyword">string</span>)</span> []<span class="title">float64</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(queries)</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">float64</span>, n)</span><br><span class="line">    visited := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        res[i] = calc(equations, values, visited, queries[i][<span class="number">0</span>], queries[i][<span class="number">1</span>], <span class="number">1.0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(equations [][]<span class="keyword">string</span>, values []<span class="keyword">float64</span>, visited <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>, a, b <span class="keyword">string</span>, answer <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> equations &#123;</span><br><span class="line">        <span class="keyword">if</span> visited[i] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> v[<span class="number">0</span>] == a &amp;&amp; a == b || v[<span class="number">1</span>] == a &amp;&amp; a == b &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> v[<span class="number">0</span>] == a &#123;</span><br><span class="line">            <span class="keyword">if</span> v[<span class="number">1</span>] == b &#123;</span><br><span class="line">                <span class="keyword">return</span> answer * values[i]</span><br><span class="line">            &#125;</span><br><span class="line">            visited[i] = <span class="literal">true</span></span><br><span class="line">            k := calc(equations, values, visited, v[<span class="number">1</span>], b, answer * values[i])</span><br><span class="line">            visited[i] = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">if</span> k != <span class="number">-1.0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> k</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> v[<span class="number">1</span>] == a &amp;&amp; values[i] != <span class="number">0.0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> v[<span class="number">0</span>] == b &#123;</span><br><span class="line">                <span class="keyword">return</span> answer / values[i]</span><br><span class="line">            &#125;</span><br><span class="line">            visited[i] = <span class="literal">true</span></span><br><span class="line">            k := calc(equations, values, visited, v[<span class="number">0</span>], b, answer / values[i])</span><br><span class="line">            visited[i] = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">if</span> k != <span class="number">-1.0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> k</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;dfs深度搜索思想，首先遍历 &lt;code&gt;queries&lt;/code&gt; 找出被除数 &lt;code&gt;a&lt;/code&gt;，除数 &lt;code&gt;b&lt;/c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode 538. 把二叉搜索树转换为累加树</title>
    <link href="https://iamxcb.com/leetcode-538.html"/>
    <id>https://iamxcb.com/leetcode-538.html</id>
    <published>2019-05-30T03:29:56.000Z</published>
    <updated>2019-05-30T03:37:18.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>根据二叉搜索树的特点，左子树节点的值小于根节点的值，根节点的值小于右子树节点的值，可以按照右-根-左的顺序遍历二叉树，将遍历顺序的结点的值累加起来，和当前结点的值相加</p><h2 id="示例代码-go"><a href="#示例代码-go" class="headerlink" title="示例代码(go)"></a>示例代码(go)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> pre <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertBST</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    pre = <span class="number">0</span></span><br><span class="line">    inorder(root)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorder</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root.Right)</span><br><span class="line">    root.Val += pre</span><br><span class="line">    pre = root.Val</span><br><span class="line">    inorder(root.Left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h2&gt;&lt;p&gt;根据二叉搜索树的特点，左子树节点的值小于根节点的值，根节点的值小于右子树节点的值，可以按照右-根-左的顺序遍历二叉树，将遍历顺序的结点的值累
      
    
    </summary>
    
    
  </entry>
  
</feed>
