<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode 1106. 解析布尔表达式]]></title>
    <url>%2Fleetcode-1106.html</url>
    <content type="text"><![CDATA[题解两个栈，一个存操作 stackOp，一个存值 stackVal，遇到字符 ) 时计算相应表达式的值（以(开始的表达式），加入栈 stackVal 示例代码(go)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func parseBoolExpr(expression string) bool &#123; stackOp := make([]byte, 0) stackVal := make([]byte, 0) n := len(expression) for i := 0; i &lt; n; i++ &#123; if expression[i] == '&amp;' || expression[i] == '|' || expression[i] == '!' &#123; stackOp = append(stackOp, expression[i]) &#125; if expression[i] == '(' || expression[i] == 't' || expression[i] == 'f' &#123; stackVal = append(stackVal, expression[i]) &#125; if expression[i] == ')' &#123; haveT, haveF := false, false op := stackOp[len(stackOp)-1] stackOp = stackOp[:len(stackOp)-1] for stackVal[len(stackVal)-1] != '(' &#123; if stackVal[len(stackVal)-1] == 't' &#123; haveT = true &#125; else &#123; haveF = true &#125; stackVal = stackVal[:len(stackVal)-1] &#125; stackVal = stackVal[:len(stackVal)-1] if op == '!' &#123; if haveT &#123; stackVal = append(stackVal, 'f') &#125; else &#123; stackVal = append(stackVal, 't') &#125; &#125; if op == '&amp;' &#123; if haveF &#123; stackVal = append(stackVal, 'f') &#125; else &#123; stackVal = append(stackVal, 't') &#125; &#125; if op == '|' &#123; if haveT &#123; stackVal = append(stackVal, 't') &#125; else &#123; stackVal = append(stackVal, 'f') &#125; &#125; &#125; &#125; if stackVal[0] == 't' &#123; return true &#125; return false&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 30. 串联所有单词的子串]]></title>
    <url>%2Fleetcode-30.html</url>
    <content type="text"><![CDATA[题解暴力解法，直接通过哈希表判断每个子串是否符合题目要求 示例代码(go)1234567891011121314151617181920212223242526272829func findSubstring(s string, words []string) []int &#123; res := make([]int, 0) m, k := len(words), len(s) if m == 0 || k == 0&#123; return res &#125; n := len(words[0]) hashW := make(map[string]int) for _, word := range words &#123; hashW[word]++ &#125; for i := 0; i &lt;= k-m*n; i++ &#123; if isSubstring(s[i:i+m*n], m, n, hashW) &#123; res = append(res, i) &#125; &#125; return res&#125;func isSubstring(s string, m, n int, hashW map[string]int) bool &#123; hashS := make(map[string]int) for i := 0; i &lt; m*n; i += n &#123; hashS[s[i:i+n]]++ if hashW[s[i:i+n]] &lt; 1 || hashS[s[i:i+n]] &gt; hashW[s[i:i+n]] &#123; return false &#125; &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 87. 扰乱字符串]]></title>
    <url>%2Fleetcode-87.html</url>
    <content type="text"><![CDATA[题解递归，i 作为分割位，分割之后的两部分 s[:i+1], s[i+1:] 可能交换，也可能不交换，所以有两种可能 示例代码(go)1234567891011121314151617181920212223242526272829303132func isScramble(s1 string, s2 string) bool &#123; if s1 == s2 &#123; return true &#125; if !isSame(s1, s2) &#123; return false &#125; n := len(s1) for i := 1; i &lt; n; i++ &#123; if isScramble(s1[:i], s2[:i]) &amp;&amp; isScramble(s1[i:], s2[i:]) &#123; return true &#125; if isScramble(s1[:i], s2[n-i:]) &amp;&amp; isScramble(s1[i:], s2[:n-i]) &#123; return true &#125; &#125; return false&#125;func isSame(s1, s2 string) bool &#123; hash := make(map[byte]int) for i := len(s1)-1; i &gt;= 0; i-- &#123; hash[s1[i]]++ &#125; for i := len(s2)-1; i &gt;= 0; i-- &#123; hash[s2[i]]-- if hash[s2[i]] &lt; 0 &#123; return false &#125; &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 982. 按位与为零的三元组]]></title>
    <url>%2Fleetcode-982.html</url>
    <content type="text"><![CDATA[题解分两步，先计算 A[i] &amp; A[j] 保存出现的次数，再计算 (A[i] &amp; A[j]) &amp; A[k] 判断是否为零 示例代码(go)1234567891011121314151617func countTriplets(A []int) int &#123; res, n := 0, len(A) hash := make(map[int]int) for i := 0; i &lt; n; i++ &#123; for j := 0; j &lt; n; j++ &#123; hash[A[i] &amp; A[j]]++ &#125; &#125; for key, count := range hash &#123; for k := 0; k &lt; n; k++ &#123; if key &amp; A[k] == 0 &#123; res += count &#125; &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 36. 有效的数独]]></title>
    <url>%2Fleetcode-36.html</url>
    <content type="text"><![CDATA[题解使用三个二维数组 a, b, c 分别保存每行，每列，每个 3*3 区块中，相应数字出现的次数 示例代码(go)123456789101112131415161718192021func isValidSudoku(board [][]byte) bool &#123; a := [9][9]int&#123;&#125; b := [9][9]int&#123;&#125; c := [9][9]int&#123;&#125; for i := 0; i &lt; 9; i++ &#123; for j := 0; j &lt; 9; j++ &#123; if board[i][j] == '.' &#123; continue &#125; num := board[i][j] - '0' k := (i / 3) * 3 + j / 3 a[i][num-1]++ b[j][num-1]++ c[k][num-1]++ if a[i][num-1] &gt; 1 || b[j][num-1] &gt; 1 || c[k][num-1] &gt; 1 &#123; return false &#125; &#125; &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 76. 最小覆盖子串]]></title>
    <url>%2Fleetcode-76.html</url>
    <content type="text"><![CDATA[题解双指针，滑动窗口 示例代码(go)12345678910111213141516171819202122232425262728293031323334func minWindow(s string, t string) string &#123; res := "" left, right := 0, 0 n := len(s) hashS := make(map[byte]int) hashT := make(map[byte]int) for _, v := range t &#123; hashT[byte(v)]++ &#125; for right &lt; n &#123; hashS[s[right]]++ for left &lt;= right &amp;&amp; contains(hashS, hashT) &#123; if res == "" &#123; res = s[left:right+1] &#125; if len(res) &gt; right-left+1 &#123; res = s[left:right+1] &#125; hashS[s[left]]-- left++ &#125; right++ &#125; return res&#125;func contains(hashS, hashT map[byte]int) bool &#123; for k, v := range hashT &#123; if hashS[k] &lt; v &#123; return false &#125; &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 828. 独特字符串]]></title>
    <url>%2Fleetcode-828.html</url>
    <content type="text"><![CDATA[题解首先子串的独特字符的个数和即 sum(UNIQ(substring))，可以转化为求解包含 S[i] 的子串中，S[i] 为独特字符的和即 sum(UNIQ(S[i])) ；同时包含 S[i] 的子串中，可能会存在 S[i] 永远不会为独特字符的子串；当 j &lt; i &amp;&amp; S[j] == S[i] 时，以 S[j] 开始的子串会使 S[i] 永远成不了独特字符；当 k &gt; i &amp;&amp; S[k] == S[i] 时，以 S[k] 结尾的子串会使 S[i] 永远成不了独特字符；所以可以去除这两种情况，在 S[j+1:k] 之间统计 UNIQ(S[i])；最终问题就变成了计算在 S[j+1:k] 之间，包含 S[i] 的子串有多少种可能，因为每个子串中 S[i] 都会是独特字符；在 S[j+1:k] 之间，包含 S[i] 的子串的数量其实就等于 (i - j) * (k - i)；S[j+1:i+1], S[j+1:i+2], ..., S[j+1:k]，S[j+2:i+1], S[j+2:i+2], ...., S[j+1:k]，….，S[i:i+1], S[i:i+2], ...., S[i:k] 示例代码(go)123456789101112131415161718func uniqueLetterString(S string) int &#123; res, n := 0, len(S) for i := 0; i &lt; n; i++ &#123; j, k := 0, 0 for j = i-1; j &gt;= 0; j-- &#123; if S[j] == S[i] &#123; break &#125; &#125; for k = i+1; k &lt; n; k++ &#123; if S[k] == S[i] &#123; break &#125; &#125; res += (i - j) * (k - i) &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 140. 单词拆分 II]]></title>
    <url>%2Fleetcode-140.html</url>
    <content type="text"><![CDATA[题解记忆化回溯，hash[s] 保存相应字符串 s 对应的单词组合 示例代码(go)12345678910111213141516171819202122232425262728293031323334func wordBreak(s string, wordDict []string) []string &#123; hash := make(map[string][]string) wordHash := make(map[string]bool) for _, word := range wordDict &#123; wordHash[word] = true &#125; return dfs(s, wordDict, hash, wordHash)&#125;func dfs(s string, wordDict []string, hash map[string][]string, wordHash map[string]bool) []string &#123; if _, ok := hash[s]; ok &#123; return hash[s] &#125; res := make([]string, 0) n := len(s) if n == 0 &#123; res = append(res, "") return res &#125; for i := 0; i &lt; n; i++ &#123; if wordHash[s[:i+1]] &#123; sublist := dfs(s[i+1:], wordDict, hash, wordHash) for _, sub := range sublist &#123; space := " " if sub == "" &#123; space = "" &#125; res = append(res, s[:i+1]+space+sub) &#125; &#125; &#125; hash[s] = res return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 4. 寻找两个有序数组的中位数]]></title>
    <url>%2Fleetcode-4.html</url>
    <content type="text"><![CDATA[题解通过 i 划分 nums1 为左右两部分 nums1[0], nums1[1], ..., nums1[i-1] 和 nums1[i], nums1[i+1], ..., nums1[m-1]通过 j 划分 nums2 为左右两部分 nums2[0], nums2[1], ..., nums2[j-1] 和 nums2[j], nums2[j+1], ..., nums2[n-1]如果 i, j 取值满足条件 i + j = m - i + n - j 和 nums1[i-1] &lt; nums2[j], nums2[j-1] &lt; nums1[i]（说明划分出了长度相等的左右两部分，并且左边的值都小于右边的值）两个有序数组的中位数 (max(nums1[i-1], nums2[j-1]) + min(nums1[i], nums2[j])) / 2 示例代码(go)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func findMedianSortedArrays(nums1 []int, nums2 []int) float64 &#123; m, n := len(nums1), len(nums2) if m &gt; n &#123; nums1, nums2 = nums2, nums1 m, n = n, m &#125; left, right, half := 0, m, (m + n + 1) / 2 for left &lt;= right &#123; i := (left + right) / 2 j := half - i if i &lt; right &amp;&amp; nums1[i] &lt; nums2[j-1] &#123; left = i + 1 &#125; else if i &gt; left &amp;&amp; nums1[i-1] &gt; nums2[j] &#123; right = i - 1 &#125; else &#123; maxLeft, minRight := 0, 0 if i == 0 &#123; maxLeft = nums2[j-1] &#125; else if j == 0 &#123; maxLeft = nums1[i-1] &#125; else &#123; maxLeft = max(nums1[i-1], nums2[j-1]) &#125; if (m + n) % 2 == 1 &#123; return float64(maxLeft) &#125; if i == m &#123; minRight = nums2[j] &#125; else if j == n &#123; minRight = nums1[i] &#125; else &#123; minRight = min(nums1[i], nums2[j]) &#125; return float64(maxLeft + minRight) / 2 &#125; &#125; return 0.0&#125;func min(a, b int) int &#123; if a &lt; b &#123; return a &#125; return b&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 315. 计算右侧小于当前元素的个数]]></title>
    <url>%2Fleetcode-315.html</url>
    <content type="text"><![CDATA[题解从后往前遍历 nums，构建二叉搜索树，每个节点要记录其左子树节点的个数 Count 示例代码(go)1234567891011121314151617181920212223242526272829type Node struct &#123; Left *Node Right *Node Val int Count int&#125;func countSmaller(nums []int) []int &#123; var root *Node n := len(nums) res := make([]int, n) for i := n-1; i &gt;= 0; i-- &#123; root = insert(root, nums[i], i, res) &#125; return res&#125;func insert(root *Node, val, index int, res []int) *Node &#123; if root == nil &#123; root = &amp;Node&#123;nil, nil, val, 0&#125; &#125; else if val &lt;= root.Val &#123; root.Count++ root.Left = insert(root.Left, val, index, res) &#125; else &#123; res[index] += root.Count + 1 root.Right = insert(root.Right, val, index, res) &#125; return root&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 72. 编辑距离]]></title>
    <url>%2Fleetcode-72.html</url>
    <content type="text"><![CDATA[题解动态规划，dp[i][j] 表示 word1 的前 i 个字母和 word2 的前 j 个字母之间的编辑距离，dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])，特许情况当 word1[i] == word2[j] 时，dp[i][j] = dp[i-1][j-1] 不需要额外操作 示例代码(go)123456789101112131415161718192021222324252627282930func minDistance(word1 string, word2 string) int &#123; m, n := len(word1), len(word2) dp := make([][]int, m+1) for i := 0; i &lt;= m; i++ &#123; dp[i] = make([]int, n+1) &#125; for i := 0; i &lt;= m; i++ &#123; dp[i][0] = i &#125; for i := 0; i &lt;= n; i++ &#123; dp[0][i] = i &#125; for i := 1; i &lt;= m; i++ &#123; for j := 1; j &lt;= n; j++ &#123; if word1[i-1] == word2[j-1] &#123; dp[i][j] = dp[i-1][j-1] &#125; else &#123; dp[i][j] = 1 + min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) &#125; &#125; &#125; return dp[m][n]&#125;func min(a, b int) int &#123; if a &lt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 134. 加油站]]></title>
    <url>%2Fleetcode-134.html</url>
    <content type="text"><![CDATA[题解找到 gas[i] &gt;= cost[i] 作为起点， 判断是否可以行驶一周 示例代码(go)12345678910111213141516171819202122232425func canCompleteCircuit(gas []int, cost []int) int &#123; n := len(gas) for i := 0; i &lt; n; i++ &#123; if gas[i] &gt;= cost[i] &amp;&amp; canComplete(gas, cost, i) &#123; return i &#125; &#125; return -1&#125;func canComplete(gas []int, cost []int, i int) bool &#123; n := len(gas) pre := gas[i] - cost[i] for j := 1; j &lt;= n; j++ &#123; k := (i+j) % n if k == i &#123; return true &#125; pre += gas[k] - cost[k] if pre &lt; 0 &#123; break &#125; &#125; return false&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 165. 比较版本号]]></title>
    <url>%2Fleetcode-165.html</url>
    <content type="text"><![CDATA[题解首先根据 “.” 分割成数组，然后依次比较每一项的值（可以先转为整数再比较，方便一点） 示例代码(go)123456789101112131415161718192021222324252627282930313233func compareVersion(version1 string, version2 string) int &#123; arr1 := strings.Split(version1, ".") arr2 := strings.Split(version2, ".") m, n := len(arr1), len(arr2) for i, j := 0, 0 ;i &lt; m || j &lt; n; &#123; if i &lt; m &amp;&amp; j &lt; n &#123; num1, _ := strconv.Atoi(arr1[i]) num2, _ := strconv.Atoi(arr2[j]) if num1 &gt; num2 &#123; return 1 &#125; if num1 &lt; num2 &#123; return -1 &#125; i++ j++ &#125; else if i == m &amp;&amp; j &lt; n &#123; num2, _ := strconv.Atoi(arr2[j]) if 0 &lt; num2 &#123; return -1 &#125; j++ &#125; else if i &lt; m &amp;&amp; j == n &#123; num1, _ := strconv.Atoi(arr1[i]) if num1 &gt; 0 &#123; return 1 &#125; i++ &#125; &#125; return 0&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 556. 下一个更大元素 III]]></title>
    <url>%2Fleetcode-556.html</url>
    <content type="text"><![CDATA[题解n 转为字节数组 b，首先从右到左找到 b[i-1] &lt; b[i] 表明有更大的值大于 n（但不一定是最小的），然后在 b[i:] 里找到大于 b[i-1] 的最小值 b[j]，接着交换 b[i-1], b[j]，反转 b[i:] 按升序排列 示例代码(go)1234567891011121314151617181920212223242526272829func nextGreaterElement(n int) int &#123; b := []byte(strconv.Itoa(n)) for i := len(b)-1; i &gt; 0; i-- &#123; if b[i-1] &lt; b[i] &#123; for j := len(b)-1; j &gt;= i; j-- &#123; if b[j] &gt; b[i-1] &#123; b[j], b[i-1] = b[i-1], b[j] reverse(b, i) break &#125; &#125; break &#125; &#125; res, _ := strconv.Atoi(string(b)) if res == n || res &gt; math.MaxInt32 &#123; return -1 &#125; return res&#125;func reverse(b []byte, i int) &#123; l, r := i, len(b)-1 for l &lt; r &#123; b[l], b[r] = b[r], b[l] l++ r-- &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 131. 分割回文串]]></title>
    <url>%2Fleetcode-131.html</url>
    <content type="text"><![CDATA[题解递归回溯，如果字符串的 s[:i] 子串回文，则对剩下的 s[i:] 子串进行递归 示例代码(go)12345678910111213141516171819202122232425262728293031var res [][]stringfunc partition(s string) [][]string &#123; res = [][]string&#123;&#125; dfs(s, []string&#123;&#125;) return res&#125;func dfs(s string, arr []string) &#123; if s == "" &#123; tmp := make([]string, 0) tmp = append(tmp, arr...) res = append(res, tmp) return &#125; n := len(s) for i := 1; i &lt;= n; i++ &#123; if isPalindrome(s[:i]) &#123; dfs(s[i:], append(arr, string(s[:i]))) &#125; &#125;&#125;func isPalindrome(s string) bool &#123; n := len(s) for i := 0; i &lt; n/2; i++ &#123; if s[i] != s[n-i-1] &#123; return false &#125; &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 41. 缺失的第一个正数]]></title>
    <url>%2Fleetcode-41.html</url>
    <content type="text"><![CDATA[题解缺失的第一个正数不会大于 n+1；首先将小于 1 的值置为 n+1，然后数组的值作为下标，把相对应的位置 nums[v-1] 变为负数，最后遍历数组判断是否有正数 示例代码(go)123456789101112131415161718192021222324252627func firstMissingPositive(nums []int) int &#123; n := len(nums) for i, v := range nums &#123; if v &lt; 1 &#123; nums[i] = n+1 &#125; &#125; for _, v := range nums &#123; v1 := abs(v) if v1 &gt; 0 &amp;&amp; v1 &lt;= n &#123; nums[v1-1] = -abs(nums[v1-1]) &#125; &#125; for i, v := range nums &#123; if v &gt; 0 &#123; return i+1 &#125; &#125; return n+1&#125;func abs(a int) int &#123; if a &lt; 0 &#123; return -a &#125; return a&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 3. 无重复字符的最长子串]]></title>
    <url>%2Fleetcode-3.html</url>
    <content type="text"><![CDATA[题解通过哈希表保存重复字符上一次出现的位置，然后从重复字符的后一个字符作为新的开始，重新计算最长子串的长度 示例代码(go)1234567891011121314151617181920func lengthOfLongestSubstring(s string) int &#123; hash := make(map[byte]int) n := len(s) res, start := 0, 0 for i := 0; i &lt; n; i++ &#123; if last, ok := hash[s[i]]; ok &amp;&amp; last &gt;= start &#123; start = last+1 &#125; hash[s[i]] = i res = max(res, i-start+1) &#125; return res&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 146. LRU缓存机制]]></title>
    <url>%2Fleetcode-146.html</url>
    <content type="text"><![CDATA[题解主要需要解决的问题就是如何在 O(1) 时间之内找出最近最少使用的值，所以使用了双链表，head 指向双链表的头，tail 指向尾，每次进行 Get, Put 操作时，就把 key 所对应的值 node 移到链表头，tail 所指向的尾部就是最近最少使用的值 示例代码(go)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960type Node struct &#123; key int value int pre *Node next *Node&#125;type LRUCache struct &#123; capacity int hash map[int]*Node head *Node tail *Node&#125;func Constructor(capacity int) LRUCache &#123; cache := LRUCache&#123;capacity: capacity, hash: make(map[int]*Node)&#125; cache.head = &amp;Node&#123;&#125; cache.tail = &amp;Node&#123;&#125; cache.head.next = cache.tail cache.tail.pre = cache.head return cache&#125;func (this *LRUCache) Get(key int) int &#123; node, ok := this.hash[key] if !ok &#123; return -1 &#125; this.remove(node) this.setHead(node) return node.value&#125;func (this *LRUCache) Put(key int, value int) &#123; if node, ok := this.hash[key]; ok &#123; node.value = value this.remove(node) this.setHead(node) &#125; else &#123; if len(this.hash) &gt;= this.capacity &#123; delete(this.hash, this.tail.pre.key) this.remove(this.tail.pre) &#125; this.hash[key] = &amp;Node&#123;key: key, value: value&#125; this.setHead(this.hash[key]) &#125;&#125;func (this *LRUCache) setHead(node *Node) &#123; headNext := this.head.next this.head.next = node node.pre = this.head node.next = headNext headNext.pre = node&#125;func (this *LRUCache) remove(node *Node) &#123; node.pre.next = node.next node.next.pre = node.pre&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 179. 最大数]]></title>
    <url>%2Fleetcode-179.html</url>
    <content type="text"><![CDATA[题解自定义排序方式，比较 arr[i]+arr[j], arr[j]+arr[i] 两种相连方式，例如比较 “34” 和 “341” 时，可以转换为比较 “34341” 和 “34134”，可以看出 “34” 要排在 “341” 前面 示例代码(go)1234567891011121314func largestNumber(nums []int) string &#123; arr := make([]string, 0) for _, v := range nums &#123; arr = append(arr, strconv.Itoa(v)) &#125; sort.Slice(arr, func (i, j int) bool &#123; return arr[i]+arr[j] &gt; arr[j]+arr[i] &#125;) res := strings.Join(arr, "") if len(res) &gt; 0 &amp;&amp; res[0] == '0' &#123; return "0" &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 93. 复原IP地址]]></title>
    <url>%2Fleetcode-93.html</url>
    <content type="text"><![CDATA[题解dfs 深度优先搜索，每次取 1~3 位为一个 ip 地址段，然后对剩下的字符串进行递归（注意地址段是否合法） 示例代码(go)12345678910111213141516171819202122232425262728293031323334353637func restoreIpAddresses(s string) []string &#123; res := make([]string, 0) dfs(s, []string&#123;&#125;, &amp;res) return res&#125;func dfs(s string, arr []string, res *[]string) &#123; n := len(s) if s != "" &amp;&amp; len(arr) == 4 &#123; return &#125; if s == "" &amp;&amp; len(arr) == 4 &#123; *res = append(*res, strings.Join(arr, ".")) return &#125; for i := 0; i &lt; 3 &amp;&amp; i &lt; n; i++ &#123; if isLess(s[:i+1], "255") &amp;&amp; isLegal(s[:i+1]) &#123; dfs(s[i+1:], append(arr, s[:i+1]), res) &#125; &#125;&#125;func isLess(a, b string) bool &#123; a1, _ := strconv.Atoi(a) b1, _ := strconv.Atoi(b) if a1 &lt;= b1 &#123; return true &#125; return false&#125;func isLegal(str string) bool &#123; if str[0] == '0' &amp;&amp; len(str) &gt; 1 &#123; return false &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 130. 被围绕的区域]]></title>
    <url>%2Fleetcode-130.html</url>
    <content type="text"><![CDATA[题解bfs 广度优先搜索，首先把边界上出现的 O 以及相连的 O 置为 S，然后遍历二维矩阵 board， O 置为 X, S 置为 O 示例代码(go)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051func solve(board [][]byte) &#123; m, n := len(board), 0 if m &gt; 0 &#123; n = len(board[0]) &#125; for j := 0; j &lt; n; j++ &#123; if board[0][j] == 'O' &#123; bfs(board, m, n, 0, j) &#125; &#125; for i := 1; i &lt; m-1; i++ &#123; if board[i][0] == 'O' &#123; bfs(board, m, n, i, 0) &#125; if board[i][n-1] == 'O' &#123; bfs(board, m, n, i, n-1) &#125; &#125; for j := 0; j &lt; n; j++ &#123; if board[m-1][j] == 'O' &#123; bfs(board, m, n, m-1, j) &#125; &#125; for i := 0; i &lt; m; i++ &#123; for j := 0; j &lt; n; j++ &#123; if board[i][j] == 'S' &#123; board[i][j] = 'O' &#125; else if board[i][j] == 'O' &#123; board[i][j] = 'X' &#125; &#125; &#125;&#125;func bfs(board [][]byte, m, n, i, j int) &#123; if board[i][j] == 'O' &#123; board[i][j] = 'S' &#125; if i-1 &gt;= 0 &amp;&amp; board[i-1][j] == 'O' &#123; bfs(board, m, n, i-1, j) &#125; if i+1 &lt; m &amp;&amp; board[i+1][j] == 'O' &#123; bfs(board, m, n, i+1, j) &#125; if j-1 &gt;= 0 &amp;&amp; board[i][j-1] == 'O' &#123; bfs(board, m, n, i, j-1) &#125; if j+1 &lt; n &amp;&amp; board[i][j+1] == 'O' &#123; bfs(board, m, n, i, j+1) &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 127. 单词接龙]]></title>
    <url>%2Fleetcode-127.html</url>
    <content type="text"><![CDATA[题解bfs 思想，根据前面已经入队 queue 的单词 beginWord，然后把可以转换的单词 word 加入队列 示例代码(go)12345678910111213141516171819202122232425262728293031323334func ladderLength(beginWord string, endWord string, wordList []string) int &#123; res := 0 visited := make(map[int]bool) queue := make([]string, 0) queue = append(queue, beginWord) for len(queue) &gt; 0 &#123; res++ n := len(queue) for i := 0; i &lt; n; i++ &#123; beginWord := queue[0] queue = queue[1:] for j, word := range wordList &#123; if !visited[j] &amp;&amp; canTransform(beginWord, word) &#123; if word == endWord &#123; return res + 1 &#125; visited[j] = true queue = append(queue, word) &#125; &#125; &#125; &#125; return 0&#125;func canTransform(beginWord string, endWord string) bool &#123; n := len(beginWord) for i := 0; i &lt; n; i++ &#123; if beginWord[:i] + beginWord[i+1:] == endWord[:i] + endWord[i+1:] &#123; return true &#125; &#125; return false&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 227. 基本计算器 II]]></title>
    <url>%2Fleetcode-227.html</url>
    <content type="text"><![CDATA[题解遍历字符串 s ，取出数值 num 存入 stack 栈中，主要是通过前边的操作符 op 判断如何存入数值，+, - 则直接存 num 的值或者取反后再存入，*, / 的话则要计算之后再存入，最后把 stack 栈中的数值相加起来 示例代码(go)12345678910111213141516171819202122232425262728293031323334353637func calculate(s string) int &#123; stack := make([]int, 0) res := 0 n := len(s) var op byte op = '+' num := 0 for i := 0; i &lt; n; i++ &#123; if s[i] &gt;= '0' &#123; num = num * 10 + int(s[i] - '0') &#125; if (s[i] &lt; '0' &amp;&amp; s[i] != ' ') || i == n-1 &#123; if op == '+' &#123; stack = append(stack, num) &#125; if op == '-' &#123; stack = append(stack, -num) &#125; if op == '*' &#123; tmp := stack[len(stack)-1] * num stack = stack[:len(stack)-1] stack = append(stack, tmp) &#125; if op == '/' &#123; tmp := stack[len(stack)-1] / num stack = stack[:len(stack)-1] stack = append(stack, tmp) &#125; num = 0 op = s[i] &#125; &#125; for _, v := range stack &#123; res += v &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 454. 四数相加 II]]></title>
    <url>%2Fleetcode-454.html</url>
    <content type="text"><![CDATA[题解首先遍历 A 和 B 元素和的组合情况，并记录在 hash 中，然后遍历 C 和 D 元素和的组合情况，判断取反后的值是否在 hash 表中 示例代码(go)1234567891011121314151617func fourSumCount(A []int, B []int, C []int, D []int) int &#123; res := 0 hash := make(map[int]int) for _, a := range A &#123; for _, b := range B &#123; hash[a+b]++ &#125; &#125; for _, c := range C &#123; for _, d := range D &#123; if v, ok := hash[-c-d]; ok &#123; res += v &#125; &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 221. 最大正方形]]></title>
    <url>%2Fleetcode-221.html</url>
    <content type="text"><![CDATA[题解动态规划，dp[i][j] 表示正方形的边长（其中i, j代表正方形的右下角）, 地推公式：dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) 示例代码(go)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var area intfunc maximalSquare(matrix [][]byte) int &#123; area = 0 m := len(matrix) if m == 0 &#123; return area &#125; n := len(matrix[0]) dp := make([][]int, m) for i := 0; i &lt; m ; i++ &#123; dp[i] = make([]int, n) &#125; for i := 0; i &lt; m; i++ &#123; for j := 0; j &lt; n; j++ &#123; if matrix[i][j] == '1' &#123; computeSquare(dp, i, j) &#125; &#125; &#125; return area&#125;func computeSquare(dp [][]int, i, j int) &#123; dp[i][j] = 1 area = max(area, dp[i][j]) if i-1 &lt; 0 &#123; return &#125; if j-1 &lt; 0 &#123; return &#125; dp[i][j] += min(min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) area = max(area, dp[i][j]*dp[i][j])&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;func min(a, b int) int &#123; if a &lt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 399. 除法求值]]></title>
    <url>%2Fleetcode-399.html</url>
    <content type="text"><![CDATA[题解dfs深度搜索思想，首先遍历 queries 找出被除数 a，除数 b，然后根据 equations 找出 a / b 的值 示例代码(go)1234567891011121314151617181920212223242526272829303132333435363738394041func calcEquation(equations [][]string, values []float64, queries [][]string) []float64 &#123; n := len(queries) res := make([]float64, n) visited := make(map[int]bool) for i := 0; i &lt; n; i++ &#123; res[i] = calc(equations, values, visited, queries[i][0], queries[i][1], 1.0) &#125; return res&#125;func calc(equations [][]string, values []float64, visited map[int]bool, a, b string, answer float64) float64 &#123; for i, v := range equations &#123; if visited[i] &#123; continue &#125; if v[0] == a &amp;&amp; a == b || v[1] == a &amp;&amp; a == b &#123; return 1.0 &#125; else if v[0] == a &#123; if v[1] == b &#123; return answer * values[i] &#125; visited[i] = true k := calc(equations, values, visited, v[1], b, answer * values[i]) visited[i] = false if k != -1.0 &#123; return k &#125; &#125; else if v[1] == a &amp;&amp; values[i] != 0.0 &#123; if v[0] == b &#123; return answer / values[i] &#125; visited[i] = true k := calc(equations, values, visited, v[0], b, answer / values[i]) visited[i] = false if k != -1.0 &#123; return k &#125; &#125; &#125; return -1.0&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 538. 把二叉搜索树转换为累加树]]></title>
    <url>%2Fleetcode-538.html</url>
    <content type="text"><![CDATA[题解根据二叉搜索树的特点，左子树节点的值小于根节点的值，根节点的值小于右子树节点的值，可以按照右-根-左的顺序遍历二叉树，将遍历顺序的结点的值累加起来，和当前结点的值相加 示例代码(go)123456789101112131415161718192021222324/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */var pre intfunc convertBST(root *TreeNode) *TreeNode &#123; pre = 0 inorder(root) return root&#125;func inorder(root *TreeNode) &#123; if root == nil &#123; return &#125; inorder(root.Right) root.Val += pre pre = root.Val inorder(root.Left)&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 763. 划分字母区间]]></title>
    <url>%2Fleetcode-763.html</url>
    <content type="text"><![CDATA[题解首先遍历字符串找到每个字母出现的最后位置，然后判断相同字母所代表区间中的每个字母，看下字母的最后位置是否超出原区间，超出则更新区间 示例代码(go)1234567891011121314151617181920212223func partitionLabels(S string) []int &#123; res := make([]int, 0) hash := make(map[byte]int) n := len(S) for i := 0; i &lt; n; i++ &#123; hash[S[i]] = i &#125; i := 0 for i &lt; n &#123; m := hash[S[i]] j := i + 1 for j &lt;= m &#123; if hash[S[j]] &gt; m &#123; m = hash[S[j]] &#125; j++ &#125; res = append(res, j-i) i = j &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 98. 验证二叉搜索树]]></title>
    <url>%2Fleetcode-98.html</url>
    <content type="text"><![CDATA[题解暴力递归，直接判断是否符合二叉搜索树的标准，左子树上所有结点的值均小于它的根结点的值，右子树上所有结点的值均大于它的根结点的值 示例代码(go)12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func isValidBST(root *TreeNode) bool &#123; if root == nil &#123; return true &#125; if !isValidLeft(root.Left, root.Val) &#123; return false &#125; if !isValidRight(root.Right, root.Val) &#123; return false &#125; return isValidBST(root.Left) &amp;&amp; isValidBST(root.Right)&#125;func isValidLeft(root *TreeNode, val int) bool &#123; if root == nil &#123; return true &#125; if root.Val &gt;= val &#123; return false &#125; return isValidLeft(root.Left, val) &amp;&amp; isValidLeft(root.Right, val)&#125;func isValidRight(root *TreeNode, val int) bool &#123; if root == nil &#123; return true &#125; if root.Val &lt;= val &#123; return false &#125; return isValidRight(root.Left, val) &amp;&amp; isValidRight(root.Right, val)&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 309. 最佳买卖股票时机含冷冻期]]></title>
    <url>%2Fleetcode-309.html</url>
    <content type="text"><![CDATA[题解dp[i][0]表示i天买入的收益，dp[i][1]表示i天卖出的收益，dp[i][2]表示i天冷冻的收益，因为卖出之后的冷冻期为1天，所以买入的前一天一定处于冷冻期 示例代码(go)1234567891011121314151617181920212223242526func maxProfit(prices []int) int &#123; n := len(prices) if n == 0 &#123; return 0 &#125; dp := make([][]int, n) for i := 0; i &lt; n; i++ &#123; dp[i] = append(dp[i], []int&#123;0, 0, 0&#125;...) &#125; dp[0][0] = -prices[0] dp[0][1] = 0 dp[0][2] = 0 for i := 1; i &lt; n; i++ &#123; dp[i][0] = max(dp[i-1][0], dp[i-1][2] - prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]) dp[i][2] = max(dp[i-1][1], dp[i-1][2]) &#125; return dp[n-1][1]&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 56. 合并区间]]></title>
    <url>%2Fleetcode-56.html</url>
    <content type="text"><![CDATA[题解首先按照开始区间进行升序排序，然后遍历数组，得到最大的重叠区间 示例代码(go)1234567891011121314151617181920func merge(intervals [][]int) [][]int &#123; n := len(intervals) if n == 0 &#123; return intervals &#125; sort.Slice(intervals, func(i, j int) bool &#123; return intervals[i][0] &lt; intervals[j][0] &#125;) s, e := intervals[0][0], intervals[0][1] for i := 1; i &lt; n; i++ &#123; if intervals[i][0] &lt;= e &amp;&amp; intervals[i][1] &gt; e &#123; e = intervals[i][1] &#125; else if intervals[i][0] &gt; e &#123; intervals = append(intervals, []int&#123;s, e&#125;) s, e = intervals[i][0], intervals[i][1] &#125; &#125; intervals = append(intervals, []int&#123;s, e&#125;) return intervals[n:]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 152. 乘积最大子序列]]></title>
    <url>%2Fleetcode-152.html</url>
    <content type="text"><![CDATA[题解a, b表示后续相乘可以用到的最大最小值 示例代码(go)1234567891011121314151617181920212223242526272829303132333435363738func maxProduct(nums []int) int &#123; a, b := 1, 1 res := math.MinInt32 for _, v1 := range nums &#123; v2 := a * v1 v3 := b * v1 res = max(res, v2) res = max(res, v3) if v2 &gt; 0 &amp;&amp; v3 &gt; 0 &#123; a = max(v2, v3) b = 1 &#125; else if v2 == 0 &amp;&amp; v3 == 0 &#123; a = 1 b = 1 &#125; else if v2 &lt; 0 &amp;&amp; v3 &lt; 0 &#123; a = min(v2, v3) b = 1 &#125; else &#123; a = v2 b = v3 &#125; &#125; return res&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;func min(a, b int) int &#123; if a &lt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 322. 零钱兑换]]></title>
    <url>%2Fleetcode-322.html</url>
    <content type="text"><![CDATA[题解动态规划，dp[n] = min(dp[n], dp[n-v]+1)，其中n代表总金额， v代表不同的硬币 示例代码(go)123456789101112131415161718func coinChange(coins []int, amount int) int &#123; dp := make([]int, amount+1) for n := 1; n &lt;= amount; n++ &#123; for _, v := range coins &#123; if n &gt;= v &amp;&amp; dp[n-v] != -1 &#123; if dp[n] == 0 &#123; dp[n] = dp[n-v] + 1 &#125; else if dp[n] &gt; dp[n-v] + 1 &#123; dp[n] = dp[n-v] + 1 &#125; &#125; &#125; if dp[n] == 0 &#123; dp[n] = -1 &#125; &#125; return dp[amount]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 55. 跳跃游戏]]></title>
    <url>%2Fleetcode-55.html</url>
    <content type="text"><![CDATA[题解从后往前遍历，如果某个点的右边可以跳到最后，则该点只要能跳一步就可以，否则就要多跳一步 示例代码(go)123456789101112func canJump(nums []int) bool &#123; n := len(nums) c := 1 for i := n-2; i &gt;= 0; i-- &#123; if nums[i] &gt;= c &#123; c = 1 &#125; else &#123; c++ &#125; &#125; return c == 1&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 19. 删除链表的倒数第N个节点]]></title>
    <url>%2Fleetcode-19.html</url>
    <content type="text"><![CDATA[题解两次遍历，第一次算出链表的长度，第二次从前往后删除指定节点 示例代码(go)123456789101112131415161718192021222324/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func removeNthFromEnd(head *ListNode, n int) *ListNode &#123; node := head m := 0 for head != nil &#123; m++ head = head.Next &#125; head = node if m == n &#123; return head.Next &#125; for i := 0; i &lt; m-n-1; i++ &#123; node = node.Next &#125; node.Next = node.Next.Next return head&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 34. 在排序数组中查找元素的第一个和最后一个位置]]></title>
    <url>%2Fleetcode-34.html</url>
    <content type="text"><![CDATA[题解分别进行两次二分查找，找出最左边和最右边的位置 示例代码(go)123456789101112131415161718192021222324252627func searchRange(nums []int, target int) []int &#123; left, right := -1, -1 n := len(nums) for i, j := 0, n-1; i &lt;= j; &#123; mid := (i + j) / 2 if nums[mid] &gt; target &#123; j = mid - 1 &#125; else if nums[mid] &lt; target &#123; i = mid + 1 &#125; else &#123; left = mid j = mid - 1 &#125; &#125; for i, j := 0, n-1; i &lt;= j; &#123; mid := (i + j) / 2 if nums[mid] &gt; target &#123; j = mid - 1 &#125; else if nums[mid] &lt; target &#123; i = mid + 1 &#125; else &#123; right = mid i = mid + 1 &#125; &#125; return []int&#123;left, right&#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 31. 下一个排列]]></title>
    <url>%2Fleetcode-31.html</url>
    <content type="text"><![CDATA[题解从后往前遍历数组，找出比当前值nums[i]大的最小值所在的位置k，然后交换nums[i]，nums[k]，并把i之后的数进行升序排序 示例代码(go)1234567891011121314151617181920func nextPermutation(nums []int) &#123; n := len(nums) min, k := math.MaxInt64, -1 for i := n-1; i &gt;= 0; i-- &#123; for j := i+1; j &lt; n; j++ &#123; if nums[j] &gt; nums[i] &amp;&amp; nums[j] &lt; min &#123; min = nums[j] k = j &#125; &#125; if k != -1 &#123; nums[i], nums[k] = nums[k], nums[i] sort.Ints(nums[i+1:]) return &#125; &#125; if k == -1 &#123; sort.Ints(nums) &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2. 两数相加]]></title>
    <url>%2Fleetcode-2.html</url>
    <content type="text"><![CDATA[题解比较简单，遍历l1, l2进行相加，注意进位问题 示例代码(go)123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode &#123; var head, l3 *ListNode c := 0 for l1 != nil || l2 != nil &#123; sum := c if l1 != nil &#123; sum += l1.Val l1 = l1.Next &#125; if l2 != nil &#123; sum += l2.Val l2 = l2.Next &#125; c = sum / 10 tmp := &amp;ListNode&#123;sum % 10, nil&#125; if head == nil &#123; head = tmp l3 = head &#125; else &#123; l3.Next = tmp l3 = l3.Next &#125; &#125; if c &gt; 0 &#123; tmp := &amp;ListNode&#123;c, nil&#125; l3.Next = tmp &#125; return head&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 79. 单词搜索]]></title>
    <url>%2Fleetcode-79.html</url>
    <content type="text"><![CDATA[题解递归，查看元素的上下左右位置，注意已经搜索过的位置，把搜索过的置为非字母，同时也不要忘了还原 示例代码(go)123456789101112131415161718192021222324252627func exist(board [][]byte, word string) bool &#123; for x := 0; x &lt; len(board); x++ &#123; for y := 0; y &lt; len(board[x]); y++ &#123; if dfs(board, word, x, y, 0) &#123; return true &#125; &#125; &#125; return false&#125;func dfs(board [][]byte, word string, x, y, i int) bool &#123; if i == len(word) &#123; return true &#125; if x &lt; 0 || y &lt; 0 || x == len(board) || y == len(board[x]) &#123; return false &#125; if board[x][y] != word[i] &#123; return false &#125; board[x][y] ^= 255; exists := dfs(board, word, x+1, y, i+1) || dfs(board, word, x-1, y, i+1) || dfs(board, word, x, y+1, i+1) || dfs(board, word, x, y-1, i+1) board[x][y] ^= 255; return exists&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 301. 删除无效的括号]]></title>
    <url>%2Fleetcode-301.html</url>
    <content type="text"><![CDATA[题解BFS思想，通过不断从字符串中减去一位，找出各种可能的子序列，然后判断是否合法（PS：合法的字符串的长度一定都是相同的) 示例代码(go)123456789101112131415161718192021222324252627282930313233343536373839404142434445func removeInvalidParentheses(s string) []string &#123; hash := make(map[string]bool) res := make([]string, 0) queue := []string&#123;s&#125; for len(queue) &gt; 0 &#123; next := make([]string, 0) for _, str := range queue &#123; if isValid(str) &#123; res = append(res, str) continue &#125; for i, v := range str &#123; if v != '(' &amp;&amp; v != ')' &#123; continue &#125; s := str[:i] + str[i+1:] if _, ok := hash[s]; ok &#123; continue &#125; hash[s] = true next = append(next, s) &#125; &#125; if len(res) &gt; 0 &#123; return res &#125; queue = next &#125; return res&#125;func isValid(str string) bool &#123; count := 0 for _, v := range str &#123; if v == '(' &#123; count++ &#125; else if v == ')' &#123; count-- &#125; if count &lt; 0 &#123; return false &#125; &#125; return count == 0&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 207. 课程表]]></title>
    <url>%2Fleetcode-207.html</url>
    <content type="text"><![CDATA[题解拓扑排序，找出入度为0的点，然后邻接点的入度各自减1（PS：有向无环图才存在拓扑排序） 示例代码(go)12345678910111213141516171819202122232425262728293031323334func canFinish(numCourses int, prerequisites [][]int) bool &#123; graph := make([][]int, numCourses) indegree := make([]int, numCourses) for _, v := range prerequisites &#123; indegree[v[0]]++ graph[v[1]] = append(graph[v[1]], v[0]) &#125; for &#123; flag := true for _, v := range indegree &#123; if v != -1 &#123; flag = false &#125; &#125; if flag &#123; return true &#125; flag = true for i, v := range indegree &#123; if v == 0 &#123; flag = false for _, v1 := range graph[i] &#123; indegree[v1]-- &#125; indegree[i]-- break &#125; &#125; if flag &#123; return false &#125; &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 96. 不同的二叉搜索树]]></title>
    <url>%2Fleetcode-96.html</url>
    <content type="text"><![CDATA[题解动态规划，dp[n] = dp[0]dp[n-1]+dp[1]dp[n-2]+dp[2]dp[n-3]+…dp[n-1]dp[0]，其中dp[n]表示n个节点所能代表的二叉搜索树个数，因为二叉搜索树的左节点要小于根节点，右节点要大于根节点，所以当根节点为1时，左节点有为空，右节点有n-1个，当根节点为2时，左节点有为1个，右节点有n-2个，依次类推 示例代码(go)1234567891011121314func numTrees(n int) int &#123; if n == 0 &#123; return 0 &#125; dp := make([]int, n+1) dp[0] = 1 dp[1] = 1 for i := 2; i &lt;= n; i++ &#123; for j := 1; j &lt;= i; j++ &#123; dp[i] += dp[j-1] * dp[i-j] &#125; &#125; return dp[n]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 946. 验证栈序列]]></title>
    <url>%2Fleetcode-946.html</url>
    <content type="text"><![CDATA[题解通过stack模拟入栈出栈 示例代码(go)123456789101112131415161718192021222324252627func validateStackSequences(pushed []int, popped []int) bool &#123; n := len(pushed) if n == 0 &#123; return true &#125; stack := make([]int, 0) i, j := 0, 0 stack = append(stack, pushed[i]) i++ for &#123; m := len(stack) if m &gt; 0 &amp;&amp; stack[m-1] == popped[j] &#123; stack = stack[:m-1] j++ &#125; else &#123; if i == n &#123; break &#125; stack = append(stack, pushed[i]) i++ &#125; &#125; if len(stack) == 0 &#123; return true &#125; return false&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 139. 单词拆分]]></title>
    <url>%2Fleetcode-139.html</url>
    <content type="text"><![CDATA[题解动态规划，dp[i]表示字符串s的前i个字符是否可以拆分 示例代码(go)12345678910111213141516171819202122func wordBreak(s string, wordDict []string) bool &#123; n := len(s) dp := make([]bool, n+1) dp[0] = true for i := 1; i &lt;= n; i++ &#123; for j := 0; j &lt; i; j++ &#123; if dp[j] &amp;&amp; contains(s[j:i], wordDict) &#123; dp[i] = true &#125; &#125; &#125; return dp[n]&#125;func contains(s string, dict []string) bool &#123; for _, v := range dict &#123; if s == v &#123; return true &#125; &#125; return false&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 141. 环形链表]]></title>
    <url>%2Fleetcode-141.html</url>
    <content type="text"><![CDATA[题解通过快慢指针进行判断，如果有环则会相遇 示例代码(go)123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func hasCycle(head *ListNode) bool &#123; if head == nil &#123; return false &#125; fast, slow := head, head for slow != nil &amp;&amp; fast != nil &#123; slow = slow.Next if fast.Next == nil &#123; return false &#125; fast = fast.Next.Next if slow == fast &#123; return true &#125; &#125; if slow != fast &#123; return false &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 581. 最短无序连续子数组]]></title>
    <url>%2Fleetcode-581.html</url>
    <content type="text"><![CDATA[题解遍历数组，同时进行从头到尾，从尾到头的遍历，分别找出无序连续子数组区间的右边和左边节点；右边点，是从左到右不递增的点，左边点，是从右到左不递减的点，两点之间的距离就是所求值 示例代码(go)12345678910111213141516171819202122232425262728func findUnsortedSubarray(nums []int) int &#123; n := len(nums) if n == 0 &#123; return 0 &#125; start, end := n-1, 0 max, min := nums[0], nums[n-1] for i := 0; i &lt; n; i++ &#123; if nums[i] &gt;= max &#123; max= nums[i] &#125; else &#123; end = i &#125; if nums[n-i-1] &lt;= min &#123; min = nums[n-i-1] &#125; else &#123; start = n-i-1 &#125; &#125; if start &gt;= end &#123; return 0 &#125; return end-start+1&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 234. 回文链表]]></title>
    <url>%2Fleetcode-234.html</url>
    <content type="text"><![CDATA[题解分为三步，首先通过快慢指针找到链表的中点，然后算出中点后面的逆序链表，最后比较链表中点前后的值是否相同 示例代码(go)1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func isPalindrome(head *ListNode) bool &#123; fast, slow := head, head var reverse *ListNode for fast != nil &#123; slow = slow.Next if fast.Next != nil &#123; fast = fast.Next.Next &#125; else &#123; fast = fast.Next &#125; &#125; for slow != nil &#123; tmp := slow.Next slow.Next = reverse reverse = slow slow = tmp &#125; for head != nil &amp;&amp; reverse != nil &#123; if head.Val != reverse.Val &#123; return false &#125; head = head.Next reverse = reverse.Next &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 20. 有效的括号]]></title>
    <url>%2Fleetcode-20.html</url>
    <content type="text"><![CDATA[题解通过栈解决，左括号入栈，右括号出栈比较 示例代码(go)1234567891011121314151617181920212223242526272829func isValid(s string) bool &#123; stack := make([]byte, 0) for _, v := range s &#123; v1 := byte(v) if v1 == '(' || v1 == '&#123;' || v1 == '[' &#123; stack = append(stack, v1) &#125; else &#123; n := len(stack) if n == 0 &#123; return false &#125; v2 := stack[n-1] stack = stack[:n-1] if v1 == ')' &amp;&amp; v2 != '(' &#123; return false &#125; if v1 == '&#125;' &amp;&amp; v2 != '&#123;' &#123; return false &#125; if v1 == ']' &amp;&amp; v2 != '[' &#123; return false &#125; &#125; &#125; if len(stack) != 0 &#123; return false &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 438. 找到字符串中所有字母异位词]]></title>
    <url>%2Fleetcode-438.html</url>
    <content type="text"><![CDATA[题解通过哈希表记录字符出现的次数，通过滑动窗口找出要进行比较的字符串，计算出窗口字符串中每个字符出现的次数，然后比较两个哈希表是否相等 示例代码(go)12345678910111213141516171819202122232425262728func findAnagrams(s string, p string) []int &#123; res := make([]int, 0) hashS := make(map[byte]int) hashP := make(map[byte]int) m, n := len(s), len(p) for i := 0; i &lt; n; i++ &#123; hashP[p[i]]++ &#125; for i := 0; i &lt; m; i++ &#123; if i &gt;= n &#123; hashS[s[i-n]]-- &#125; hashS[s[i]]++ if isEqual(hashS, hashP) &#123; res = append(res, i-n+1) &#125; &#125; return res&#125;func isEqual(a, b map[byte]int) bool &#123; for k, v := range b &#123; if a[k] != v &#123; return false &#125; &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 416. 分割等和子集]]></title>
    <url>%2Fleetcode-416.html</url>
    <content type="text"><![CDATA[题解两个子集相等，可以知道数组的和sum肯定为偶数，然后问题就变为，判断数组中是否存在和为sum/2的子集，使用背包问题的动态规划，计算出pack可以存储的数值和 示例代码(go)1234567891011121314151617181920212223func canPartition(nums []int) bool &#123; sum := 0 for _, v := range nums &#123; sum += v &#125; if sum % 2 != 0 &#123; return false &#125; capacity := sum / 2 pack := make([]bool, capacity+1) pack[0] = true for _, v1 := range nums &#123; for v2 := capacity; v2 &gt;= v1; v2-- &#123; if pack[v2-v1] &#123; pack[v2] = true &#125; &#125; if pack[capacity] &#123; return true &#125; &#125; return false&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 105 . 从前序与中序遍历序列构造二叉树]]></title>
    <url>%2Fleetcode-105.html</url>
    <content type="text"><![CDATA[题解前序遍历顺序为根左右，中序遍历顺序为左根右，所以可以看出preorder中的每一个数，在inorder中所处位置的左边就是左子树，右边为右子树 示例代码(go)12345678910111213141516171819202122232425/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func buildTree(preorder []int, inorder []int) *TreeNode &#123; var node *TreeNode if len(preorder) == 0 &#123; return node &#125; node = &amp;TreeNode&#123;preorder[0], nil, nil&#125; left := 0 for i, v := range inorder &#123; if v == preorder[0] &#123; left = i break &#125; &#125; node.Left = buildTree(preorder[1:left+1], inorder[:left]) node.Right = buildTree(preorder[left+1:], inorder[left+1:]) return node&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 300. 最长上升子序列]]></title>
    <url>%2Fleetcode-300.html</url>
    <content type="text"><![CDATA[题解动态规划，dp[j] = max(dp[j], dp[i]+1)，表示当j &gt; i, nums[j] &gt; nums[i]时取最大的上升子序 示例代码(go)123456789101112131415161718192021222324func lengthOfLIS(nums []int) int &#123; n := len(nums) res := 0 dp := make([]int, n) for i := 0; i &lt; n; i++ &#123; if dp[i] == 0 &#123; dp[i] += 1 &#125; for j := i+1; j &lt; n; j++ &#123; if nums[j] &gt; nums[i] &#123; dp[j] = max(dp[j], dp[i]+1) &#125; &#125; res = max(res, dp[i]) &#125; return res&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 128. 最长连续序列]]></title>
    <url>%2Fleetcode-128.html</url>
    <content type="text"><![CDATA[题解哈希表存储连续区间的长度，遍历数组，如果数已在哈希表中则跳过，若还没有加入，则取出其左右相邻数表示的连续区间长度相加，然后更新左右区间两端点的长度值 示例代码(go)12345678910111213141516171819202122232425262728293031323334func longestConsecutive(nums []int) int &#123; res := 0 hash := make(map[int]int) for i := 0; i &lt; len(nums); i++ &#123; num := nums[i] if _, ok := hash[num]; ok &#123; continue &#125; hash[num] += 1 v1, ok1 := hash[num-1] v2, ok2 := hash[num+1] if ok1 &#123; hash[num] += v1 &#125; if ok2 &#123; hash[num] += v2 &#125; if hash[num] &gt; res &#123; res = hash[num] &#125; if ok1 &#123; hash[num-v1] = hash[num] &#125; if ok2 &#123; hash[num+v2] = hash[num] &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 240. 搜索二维矩阵 II]]></title>
    <url>%2Fleetcode-240.html</url>
    <content type="text"><![CDATA[题解因为数组从左到右，从上到下都是递增的，所以可以从数组左下角的开始判断，比目标值大就往上比较，比目标小就往右比较 示例代码(go)12345678910111213141516func searchMatrix(matrix [][]int, target int) bool &#123; m, n := len(matrix), 0 if m &gt; 0 &#123; n = len(matrix[0]) &#125; for i, j := m-1, 0; i &gt;= 0 &amp;&amp; j &lt; n; &#123; if matrix[i][j] &gt; target &#123; i-- &#125; else if matrix[i][j] &lt; target &#123; j++ &#125; else &#123; return true &#125; &#125; return false&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 15. 三数之和]]></title>
    <url>%2Fleetcode-15.html</url>
    <content type="text"><![CDATA[题解首先对数组进行排序，接着把三数问题变为两数问题，即遍历第一个数，找剩下的两个数；主要注意重复问题，每一个数要保证与上一次找到的数不同，nums[i]==nums[1-1], nums[j]==nums[j-1], nums[k]==nums[k+1]都是要跳过的 示例代码(go)123456789101112131415161718192021222324252627282930func threeSum(nums []int) [][]int &#123; sort.Ints(nums) n := len(nums) res := make([][]int, 0) for i := 0; i &lt; n-2; i++ &#123; if i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &#123; continue &#125; j, k := i+1, n-1 for j &lt; k &#123; sum := nums[i] + nums[j] + nums[k] if sum &gt; 0 &#123; k-- &#125; else if sum &lt; 0 &#123; j++ &#125; else &#123; res = append(res, []int&#123;nums[i], nums[j], nums[k]&#125;) j++ k-- for nums[j] == nums[j-1] &amp;&amp; j &lt; k &#123; j++ &#125; for nums[k] == nums[k+1] &amp;&amp; j &lt; k &#123; k-- &#125; &#125; &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 75. 颜色分类]]></title>
    <url>%2Fleetcode-75.html</url>
    <content type="text"><![CDATA[题解遍历数组nums，分为三种情况，值为1直接跳过，值为0则与前面的数对换（i前面的数已经排好），值为2则与后面的数对换（j后面的数已经排好） 示例代码(go)1234567891011121314func sortColors(nums []int) &#123; for cur, i, j := 0, -1, len(nums); cur &lt; j; &#123; if nums[cur] == 0 &#123; i++ nums[i], nums[cur] = nums[cur], nums[i] cur++ &#125; else if nums[cur] == 1 &#123; cur++ &#125; else if nums[cur] == 2 &#123; j-- nums[j], nums[cur] = nums[cur], nums[j] &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 42. 接雨水]]></title>
    <url>%2Fleetcode-42.html</url>
    <content type="text"><![CDATA[题解首先找出柱子的最大高度maxHeight，然后分别找出从1, 2, 3...maxHeight高度所能接到的雨水，每一次高度所能接到的雨水，就是两个相邻的不低于此高度的柱子之间的距离 示例代码(go)1234567891011121314151617181920func trap(height []int) int &#123; maxHeight, res := 0, 0 for _, v := range height &#123; if maxHeight &lt; v &#123; maxHeight = v &#125; &#125; for i := 1; i &lt;= maxHeight; i++ &#123; cur := -1 for j, v := range height &#123; if cur != -1 &amp;&amp; v &gt;= i &#123; res += j-cur-1 &#125; if v &gt;= i &#123; cur = j &#125; &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 437. 路径总和 III]]></title>
    <url>%2Fleetcode-437.html</url>
    <content type="text"><![CDATA[题解递归，注意递归结束条件，cur == 0时不要结束递归，因为可能还有更长的路径和等于sum 示例代码(go)12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func pathSum(root *TreeNode, sum int) int &#123; if root == nil &#123; return 0 &#125; res := preTrav(root, sum) res += pathSum(root.Left, sum) res += pathSum(root.Right, sum) return res&#125;func preTrav(root *TreeNode, cur int) int &#123; if root == nil &#123; return 0 &#125; res := 0 cur -= root.Val if cur == 0 &#123; res++ &#125; res += preTrav(root.Left, cur) res += preTrav(root.Right, cur) return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 279. 完全平方数]]></title>
    <url>%2Fleetcode-279.html</url>
    <content type="text"><![CDATA[题解动态规划，dp[i] = min(dp[i], dp[j]+dp[i-j])，如果i为完全平方数, 则预先设置dp[i]=1 示例代码(go)12345678910111213141516171819func numSquares(n int) int &#123; dp := make([]int, n+1) for i, j := 1, 1; i &lt;= n; &#123; dp[i] = 1 j++ i = j * j &#125; for i := 1; i &lt;= n; i++ &#123; if dp[i] != 1 &#123; dp[i] = dp[1] + dp[i-1] &#125; for j := 1; j &lt;= i/2; j++ &#123; if dp[i] &gt; dp[j]+dp[i-j] &#123; dp[i] = dp[j]+dp[i-j] &#125; &#125; &#125; return dp[n]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 572. 另一个树的子树]]></title>
    <url>%2Fleetcode-572.html</url>
    <content type="text"><![CDATA[题解递归判断两个二叉树是否相同 示例代码(go)123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func isSubtree(s *TreeNode, t *TreeNode) bool &#123; if s == nil &amp;&amp; t != nil &#123; return false &#125; return isSame(s, t) || isSubtree(s.Left, t) || isSubtree(s.Right, t)&#125;func isSame(s *TreeNode, t *TreeNode) bool &#123; if s != nil &amp;&amp; t == nil &#123; return false &#125; if s == nil &amp;&amp; t != nil &#123; return false &#125; if s == nil &amp;&amp; t == nil &#123; return true &#125; if s.Val != t.Val &#123; return false &#125; return isSame(s.Left, t.Left) &amp;&amp; isSame(s.Right, t.Right)&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1022. Sum of Root To Leaf Binary Numbers]]></title>
    <url>%2Fleetcode-1022.html</url>
    <content type="text"><![CDATA[题解前序遍历二叉树，通过左移运算符把遍历的二进制转化为十进制 示例代码(go)12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func sumRootToLeaf(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; return perTrav(root, 0)&#125;func perTrav(root *TreeNode, cur int) int &#123; sum := 0 cur = cur &lt;&lt; 1 cur += root.Val if root.Left == nil &amp;&amp; root.Right == nil &#123; sum += cur return sum &#125; if root.Left != nil &#123; sum += perTrav(root.Left, cur) &#125; if root.Right != nil &#123; sum += perTrav(root.Right, cur) &#125; return sum&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 101. 对称二叉树]]></title>
    <url>%2Fleetcode-101.html</url>
    <content type="text"><![CDATA[题解递归，判断左子树的左边和右子树的右边，以及左子树的右边和右子树的左边是否相同 示例代码(go)123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func isSymmetric(root *TreeNode) bool &#123; if root == nil &#123; return true &#125; return isLRSymmetric(root.Left, root.Right)&#125;func isLRSymmetric(left, right *TreeNode) bool &#123; if left == nil &amp;&amp; right != nil &#123; return false &#125; if left != nil &amp;&amp; right == nil &#123; return false &#125; if left == nil &amp;&amp; right == nil &#123; return true &#125; if left.Val != right.Val &#123; return false &#125; return isLRSymmetric(left.Left, right.Right) &amp;&amp; isLRSymmetric(left.Right, right.Left)&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 53. 最大子序和]]></title>
    <url>%2Fleetcode-53.html</url>
    <content type="text"><![CDATA[题解nums[i] = max(nums[i], nums[i]+nums[i-1]代表i位置处所得到的最大子序和 示例代码(go)12345678910111213141516171819func maxSubArray(nums []int) int &#123; n := len(nums) if n == 0 &#123; return 0 &#125; res := nums[0] for i := 1; i &lt; n; i++ &#123; nums[i] = max(nums[i], nums[i]+nums[i-1]) res = max(res, nums[i]) &#125; return res&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 102. 二叉树的层次遍历]]></title>
    <url>%2Fleetcode-102.html</url>
    <content type="text"><![CDATA[题解非递归算法，通过队列保存节点，找到每个节点的左右子树入队 示例代码(go)123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func levelOrder(root *TreeNode) [][]int &#123; res := make([][]int, 0) if root == nil &#123; return res &#125; queue := make([]*TreeNode, 0) queue = append(queue, root) n := len(queue) arr := make([]int, 0) for len(queue) &gt; 0 &#123; node := queue[0] queue = queue[1:] arr = append(arr, node.Val) n-- if node.Left != nil &#123; queue = append(queue, node.Left) &#125; if node.Right != nil &#123; queue = append(queue, node.Right) &#125; if n == 0 &#123; res = append(res, arr) n = len(queue) arr = []int&#123;&#125; &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 543. 二叉树的直径]]></title>
    <url>%2Fleetcode-543.html</url>
    <content type="text"><![CDATA[题解直径可能是任意两个结点的路径长度，所以要在找每个结点的左右子树高度和时，比较最大直径 示例代码(go)12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */var res intfunc diameterOfBinaryTree(root *TreeNode) int &#123; res = 0 height(root) return res&#125;func height(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; left := height(root.Left) right := height(root.Right) res = max(res, left+right) return max(left, right) + 1&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 560. 和为K的子数组]]></title>
    <url>%2Fleetcode-560.html</url>
    <content type="text"><![CDATA[题解通过遍历nums，记录连续数值的和sum出现的次数，sum-k表示当前和与前边某一个和相差k，也就是说这两个和值之间的子数组就是和为K的子数组 示例代码(go)1234567891011func subarraySum(nums []int, k int) int &#123; res, sum := 0, 0 hash := make(map[int]int, len(nums)) hash[0] = 1 for _, v := range nums &#123; sum += v res += hash[sum-k] hash[sum]++ &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 200. 岛屿的个数]]></title>
    <url>%2Fleetcode-200.html</url>
    <content type="text"><![CDATA[题解遍历grid，遇到数值为1时置为0，然后不断递归上下左右的位置为0 示例代码(go)1234567891011121314151617181920212223242526272829303132func numIslands(grid [][]byte) int &#123; m := len(grid) if m == 0 &#123; return 0 &#125; n, res := len(grid[0]), 0 for i := 0; i &lt; m; i++ &#123; for j := 0; j &lt; n; j++ &#123; if grid[i][j] == '1' &#123; res++ dfs(grid, i, j, m, n) &#125; &#125; &#125; return res&#125;func dfs(grid [][]byte, i, j, m, n int) &#123; grid[i][j] = '0' if i-1 &gt;= 0 &amp;&amp; grid[i-1][j] == '1' &#123; dfs(grid, i-1, j, m, n) &#125; if j-1 &gt;= 0 &amp;&amp; grid[i][j-1] == '1' &#123; dfs(grid, i, j-1, m, n) &#125; if i+1 &lt; m &amp;&amp; grid[i+1][j] == '1' &#123; dfs(grid, i+1, j, m, n) &#125; if j+1 &lt; n &amp;&amp; grid[i][j+1] == '1' &#123; dfs(grid, i, j+1, m, n) &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 198. 打家劫舍]]></title>
    <url>%2Fleetcode-198.html</url>
    <content type="text"><![CDATA[题解动态规划问题，状态转移方程nums[i] = max(nums[i-1], nums[i-2]+nums[i])（PS：注意初始化nums[0], nums[1]） 示例代码(go)123456789101112131415161718192021func rob(nums []int) int &#123; n := len(nums) if n == 0 &#123; return 0 &#125; if n == 1 &#123; return nums[0] &#125; nums[1] = max(nums[0], nums[1]) for i := 2; i &lt; n; i++ &#123; nums[i] = max(nums[i-1], nums[i-2]+nums[i]) &#125; return nums[n-1]&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 114. 二叉树展开为链表]]></title>
    <url>%2Fleetcode-114.html</url>
    <content type="text"><![CDATA[题解分别递归左右子树变为链表，然后先临时保存右子树，再把右子树指向左子树并清空，最后找到右子树的最后的叶节点，指向临时保存的原右子树 示例代码(go)12345678910111213141516171819202122/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func flatten(root *TreeNode) &#123; if root == nil &#123; return &#125; flatten(root.Left) flatten(root.Right) tmp := root.Right root.Right = root.Left root.Left = nil for root.Right != nil &#123; root = root.Right &#125; root.Right = tmp&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 494. 目标和]]></title>
    <url>%2Fleetcode-494.html</url>
    <content type="text"><![CDATA[题解简单粗暴，直接根据上一次的结果存储各种可能性 示例代码(go)12345678910111213func findTargetSumWays(nums []int, S int) int &#123; hash := make(map[int]int) hash[0] = 1 for _, v := range nums &#123; tmp := make(map[int]int) for k, _ := range hash &#123; tmp[k+v] += hash[k] tmp[k-v] += hash[k] &#125; hash = tmp &#125; return hash[S]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 11. 盛最多水的容器]]></title>
    <url>%2Fleetcode-11.html</url>
    <content type="text"><![CDATA[题解通过移动两个序号i,j，找出最大值，具体步骤就是高度较低的往内移动 示例代码(go)123456789101112131415161718192021222324252627func maxArea(height []int) int &#123; res := 0 i, j := 0, len(height)-1 for i &lt; j &#123; res = max(res, (j-i) * min(height[i], height[j])) if height[i] &lt; height[j] &#123; i++ &#125; else &#123; j-- &#125; &#125; return res&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;func min(a, b int) int &#123; if a &lt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 394. 字符串解码]]></title>
    <url>%2Fleetcode-394.html</url>
    <content type="text"><![CDATA[题解倒序遍历字符串s，如果不是[则直接入栈；遇到[时，先找出[前边的数字nums表示为k，然后找出编码字符串encodedStr，重复k次入栈，跳过数字继续遍历 示例代码(go)12345678910111213141516171819202122232425262728293031323334353637383940func decodeString(s string) string &#123; stack := make([]string, 0) for i := len(s)-1; i &gt;=0;&#123; if s[i] == '[' &#123; nums := make([]string, 0) for j := i-1; j &gt;= 0; j-- &#123; if s[j] &gt;= '0' &amp;&amp; s[j] &lt;= '9' &#123; nums = append(nums, string(s[j])) &#125; else &#123; break &#125; &#125; reverse(nums) k, _ := strconv.Atoi(strings.Join(nums, "")) encodedStr := make([]string, 0) for stack[len(stack)-1] != "]" &#123; encodedStr = append(encodedStr, stack[len(stack)-1]) stack = stack[:len(stack)-1] &#125; stack = stack[:len(stack)-1] reverse(encodedStr) for j := 0; j &lt; k; j++ &#123; stack = append(stack, encodedStr...) &#125; i -= len(nums) &#125; else &#123; stack = append(stack, string(s[i])) &#125; i -= 1 &#125; reverse(stack) return strings.Join(stack, "")&#125;func reverse(arr []string) &#123; length := len(arr) for i := 0; i &lt; length/2; i++ &#123; arr[i], arr[length-i-1] = arr[length-i-1], arr[i] &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1. 两数之和]]></title>
    <url>%2Fleetcode-1.html</url>
    <content type="text"><![CDATA[题解哈希表保存位置 示例代码(go)123456789101112131415func twoSum(nums []int, target int) []int &#123; res := make([]int, 2) hash := make(map[int]int) for i, v := range nums &#123; hash[v] = i &#125; for i, v := range nums &#123; if j, ok := hash[target-v]; ok &amp;&amp; j != i &#123; res[0] = i res[1] = j break &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 64. 最小路径和]]></title>
    <url>%2Fleetcode-64.html</url>
    <content type="text"><![CDATA[题解动态规划问题，grid[i][j] += min(grid[i-1][j], grid[i][j-1]) 示例代码(go)1234567891011121314151617181920212223242526272829func minPathSum(grid [][]int) int &#123; m := len(grid) if m == 0 &#123; return 0 &#125; n := len(grid[0]) if n == 0 &#123; return 0 &#125; for i := 1; i &lt; n; i++ &#123; grid[0][i] += grid[0][i-1] &#125; for i := 1; i &lt; m; i++ &#123; grid[i][0] += grid[i-1][0] &#125; for i := 1; i &lt; m; i++ &#123; for j := 1; j &lt; n; j++ &#123; grid[i][j] += min(grid[i-1][j], grid[i][j-1]) &#125; &#125; return grid[m-1][n-1]&#125;func min(a, b int) int &#123; if a &lt;= b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 39. 组合总和]]></title>
    <url>%2Fleetcode-39.html</url>
    <content type="text"><![CDATA[题解递归，遍历数组candidates，通过target减去数组中相应的值，不断缩小target进行递归，同时为了避免重复，从数组中取的值不能大于target/2，同时不能小于上一次的取值prev例如, candidates=[2,3,5,6,7,8,9,11,12]; target = 14，可以递归(2,12),(3,11),(5,9),(6,8),(7,7) 示例代码(go)1234567891011121314151617181920func combinationSum(candidates []int, target int) [][]int &#123; return combination(candidates, []int&#123;&#125;, 0, target)&#125;func combination(candidates []int, arr []int, prev, target int) [][]int &#123; res := make([][]int, 0) if target == 0 &#123; tmp := append([]int&#123;&#125;, arr...) res = append(res, tmp) return res &#125; for _, v := range candidates &#123; if (v &lt;= target/2 &amp;&amp; v &gt;= prev) || v == target &#123; arr = append(arr, v) res = append(res, combination(candidates, arr, v, target-v)...) arr = arr[:len(arr)-1] &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 287. 寻找重复数]]></title>
    <url>%2Fleetcode-287.html</url>
    <content type="text"><![CDATA[题解通过使用nums的值作为序号i，让相应位置取反，因为重复数值会访问相同位置多次，从而找出重复数值 示例代码(go)123456789101112131415161718func findDuplicate(nums []int) int &#123; for _, v := range nums &#123; i := abs(v) if nums[i] &lt; 0 &#123; return i &#125; else &#123; nums[i] = -nums[i] &#125; &#125; return 0&#125;func abs(a int) int &#123; if a &lt; 0 &#123; return -a &#125; return a&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 94. 二叉树的中序遍历]]></title>
    <url>%2Fleetcode-94.html</url>
    <content type="text"><![CDATA[题解通过stack模拟栈进行中序遍历 示例代码(go)1234567891011121314151617181920212223/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func inorderTraversal(root *TreeNode) []int &#123; res := make([]int, 0) stack := make([]*TreeNode, 0) for root != nil || len(stack) != 0 &#123; for root != nil &#123; stack = append(stack, root) root = root.Left &#125; root = stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, root.Val) root = root.Right &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 22. 括号生成]]></title>
    <url>%2Fleetcode-22.html</url>
    <content type="text"><![CDATA[题解递归，左括号小于n时递归，右括号小于左括号时递归，左右括号数量为n时停止递归 示例代码(go)123456789101112131415161718192021func generateParenthesis(n int) []string &#123; res := make([]string, 0) if n == 0 &#123; return res &#125; generate(&amp;res, "", n, 0) return res&#125;func generate(arr *[]string, str string, left, right int) &#123; if left == 0 &amp;&amp; right == 0 &#123; *arr = append(*arr, str) return &#125; if left &gt; 0 &#123; generate(arr, str+"(", left-1, right+1) &#125; if right &gt; 0 &#123; generate(arr, str+")", left, right-1) &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 347. 前K个高频元素]]></title>
    <url>%2Fleetcode-347.html</url>
    <content type="text"><![CDATA[题解统计相同数字出现的次数，然后根据出现次数存入二维数组中，最后从二维数组的后面开始取出高频数值 示例代码(go)12345678910111213141516171819202122232425262728func topKFrequent(nums []int, k int) []int &#123; arr := make([]int, 0) if len(nums) == 0 &#123; return arr &#125; m := make(map[int]int) maxCount := 0 for _,v := range nums &#123; m[v] += 1 if m[v] &gt; maxCount &#123; maxCount = m[v] &#125; &#125; tmp := make([][]int, maxCount+1) for k,v := range m &#123; tmp[v] = append(tmp[v], k) &#125; for i := maxCount; i &gt;= 0; i-- &#123; if len(tmp[i]) == 0 &#123; continue &#125; arr = append(arr, tmp[i]...) if len(arr) == k &#123; break &#125; &#125; return arr&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 46. 全排列]]></title>
    <url>%2Fleetcode-46.html</url>
    <content type="text"><![CDATA[题解递归，首先通过交换数组头部和后序的值，然后对剩下的子数组进行递归排列 示例代码(go)123456789101112131415161718192021func permute(nums []int) [][]int &#123; return recursion(nums, 0, len(nums)-1)&#125;func recursion(nums []int, left, right int) [][]int &#123; res := make([][]int, 0) if left == right &#123; tmp := append([]int&#123;&#125;, nums...) res = append(res, tmp) &#125; for i := left; i &lt;= right; i++ &#123; swap(nums, i, left) res = append(res, recursion(nums, left+1, right)...) swap(nums, i, left) &#125; return res&#125;func swap(nums []int, i, j int) &#123; nums[i], nums[j] = nums[j], nums[i]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 78. 子集]]></title>
    <url>%2Fleetcode-78.html</url>
    <content type="text"><![CDATA[题解倒序遍历数组nums，依次添加到前边的子集中 示例代码(go)1234567891011121314func subsets(nums []int) [][]int &#123; res := make([][]int, 0) res = append(res, []int&#123;&#125;) for i := len(nums)-1; i &gt;= 0; i-- &#123; length := len(res) for j := 0; j &lt; length; j++ &#123; tmp := make([]int, 0) tmp = append(tmp, nums[i]) tmp = append(tmp, res[j]...) res = append(res, tmp) &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 238. 除自身以外数组的乘积]]></title>
    <url>%2Fleetcode-238.html</url>
    <content type="text"><![CDATA[题解计算i左右两边的乘积，两边乘积再相乘，就可以了 示例代码(go)12345678910111213141516171819func productExceptSelf(nums []int) []int &#123; length := len(nums) if length &lt; 2 &#123; return nums &#125; res := make([]int, length) res[0] = 1 for i := 1; i &lt; length; i++ &#123; res[i] = res[i - 1] * nums[i - 1] &#125; reverse := 1 for i := length - 1; i &gt;= 0; i-- &#123; res[i] *= reverse reverse *= nums[i] &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1005. Maximize Sum Of Array After K Negations]]></title>
    <url>%2Fleetcode-1005.html</url>
    <content type="text"><![CDATA[题解比较反转的次数K和多少个负数nums，主要分两种情况，K &lt; nums时，就反转K个最小的负数，k &gt;= nums时，则看看K-nums是奇数还是偶数，偶数就反转两次不变，奇数就再减去最小值（数组A变为正整数中的最小值） 示例代码(go)1234567891011121314151617181920212223242526272829func largestSumAfterKNegations(A []int, K int) int &#123; res, nums, min := 0, 0, 101 sort.Ints(A) for _, v := range A &#123; if v &lt; 0 &#123; nums++ &#125; if min &gt; abs(v) &#123; min = abs(v) &#125; res += abs(v) &#125; if K &lt; nums &#123; for i := K; i &lt; nums; i++ &#123; res += 2*A[i] &#125; &#125; else if (K-nums) % 2 == 1 &#123; res -= 2*min &#125; return res&#125;func abs(a int) int &#123; if a &lt; 0 &#123; return -a &#125; return a&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 406. 根据身高重建队列]]></title>
    <url>%2Fleetcode-406.html</url>
    <content type="text"><![CDATA[题解首先进行排序，身高从高到低，同时根据前面有几个人从低到高，排好之后，根据前面有几人依次插入到相应位置 示例代码(go)1234567891011121314151617181920212223type Sorter [][]intfunc (sorter Sorter) Len() int &#123; return len(sorter) &#125;func (sorter Sorter) Swap(i, j int) &#123; sorter[i], sorter[j] = sorter[j], sorter[i] &#125;func (sorter Sorter) Less(i, j int) bool &#123; if (sorter[i][0] == sorter[j][0]) &#123; return sorter[i][1] &lt; sorter[j][1] &#125; else &#123; return sorter[i][0] &gt; sorter[j][0] &#125;&#125;func reconstructQueue(people [][]int) [][]int &#123; res := make([][]int, 0) sorter := Sorter(people) sort.Sort(sorter) for _, v := range sorter &#123; res = append(res, nil) copy(res[v[1]+1:], res[v[1]:]) res[v[1]] = v &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 553. 最优除法]]></title>
    <url>%2Fleetcode-553.html</url>
    <content type="text"><![CDATA[题解数学问题，第一个数作为分子不变，找到最小的分母，第一个数后边加括号就可以了 示例代码(go)12345678910111213141516func optimalDivision(nums []int) string &#123; length := len(nums) res := strconv.Itoa(nums[0]) if length == 1 &#123; return res &#125; if length == 2 &#123; return res + "/" + strconv.Itoa(nums[1]) &#125; res += "/(" for i := 1; i &lt; length-1; i++ &#123; res += strconv.Itoa(nums[i]) + "/" &#125; res += strconv.Itoa(nums[length-1]) + ")" return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 812. 最大三角形面积]]></title>
    <url>%2Fleetcode-812.html</url>
    <content type="text"><![CDATA[题解通过三点可以计算出三角形的面积，area = (x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)) / 2 示例代码(go)12345678910111213141516171819202122func largestTriangleArea(points [][]int) float64 &#123; res := 0.0 for i := 0; i &lt; len(points)-2; i++ &#123; for j := i+1; j &lt; len(points)-1; j++ &#123; for k := j+1; k &lt; len(points); k++ &#123; area := computeArea(points[i], points[j], points[k]) if area &gt; res &#123; res = area &#125; &#125; &#125; &#125; return res&#125;func computeArea(a, b, c []int) float64 &#123; area := a[0]*(b[1]-c[1]) + b[0]*(c[1]-a[1]) + c[0]*(a[1]-b[1]) if area &lt; 0 &#123; area = -area &#125; return float64(area) / 2.0&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 17. 电话号码的字母组合]]></title>
    <url>%2Fleetcode-17.html</url>
    <content type="text"><![CDATA[题解递归，首先把digits中的每一个数字，依次转化为相对应的字符串存入strings数组中，然后依次递归遍历strings[0], strings[1]...strings[n] 示例代码(go)123456789101112131415161718192021222324func letterCombinations(digits string) []string &#123; res := make([]string, 0) arr := []string&#123;"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"&#125; if digits == "" &#123; return res &#125; strings := make([]string, len(digits)) for i, v := range digits &#123; strings[i] = arr[v-'2'] &#125; recursion(strings, &amp;res, "") return res&#125;func recursion(strings []string, res *[]string, str string) &#123; if len(strings) == 0 &#123; *res = append(*res, str) return &#125; for _, v := range strings[0] &#123; recursion(strings[1:], res, str+string(v)) &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 343. 整数拆分]]></title>
    <url>%2Fleetcode-343.html</url>
    <content type="text"><![CDATA[题解动态规划，dp数组保存最大乘积 示例代码(go)123456789101112131415161718func integerBreak(n int) int &#123; dp := make([]int, n+1) dp[1], dp[2] = 1, 1 for i := 3; i &lt;= n; i++ &#123; for j := 1; j &lt;= i/2; j++ &#123; tmp := max(dp[j], j) * max(dp[i-j], i-j) dp[i] = max(dp[i], tmp) &#125; &#125; return dp[n]&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 463. 岛屿的周长]]></title>
    <url>%2Fleetcode-463.html</url>
    <content type="text"><![CDATA[题解判断代表陆地点的上下左右点对应的值，出界或为零则周长加一 示例代码(go)12345678910111213141516171819202122232425262728func islandPerimeter(grid [][]int) int &#123; res := 0 m := len(grid) if m == 0 &#123; return res &#125; n := len(grid[0]) for i := 0; i &lt; m; i++ &#123; for j := 0; j &lt; n; j++ &#123; if grid[i][j] == 1 &#123; if i-1 &lt; 0 || grid[i-1][j] == 0 &#123; res++ &#125; if i+1 &gt;= m || grid[i+1][j] == 0 &#123; res++ &#125; if j-1 &lt; 0 || grid[i][j-1] == 0 &#123; res++ &#125; if j+1 &gt;= n || grid[i][j+1] == 0 &#123; res++ &#125; &#125; &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 413. 等差数列划分]]></title>
    <url>%2Fleetcode-413.html</url>
    <content type="text"><![CDATA[题解找出连续的等差数列，分别计算有多少等差子数组 示例代码(go)12345678910111213141516func numberOfArithmeticSlices(A []int) int &#123; if len(A) &lt; 3 &#123; return 0 &#125; cnt := 0 sum := 0 for i:=2; i&lt;len(A); i++ &#123; if A[i] - A[i-1] == A[i-1] - A[i-2]&#123; cnt = cnt + 1 sum += cnt &#125; else &#123; cnt = 0 &#125; &#125; return sum&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 821. 字符的最短距离]]></title>
    <url>%2Fleetcode-821.html</url>
    <content type="text"><![CDATA[题解分为两步，第一步找出字符的所有位置，第二步通过比较各个位置找出最短距离 示例代码(go)123456789101112131415161718192021222324252627282930func shortestToChar(S string, C byte) []int &#123; indexArr := make([]int, 0) res := make([]int, len(S)) for i, c := range S &#123; if byte(c) == C &#123; indexArr = append(indexArr, i) &#125; &#125; for i, _ := range S &#123; res[i] = min(i, indexArr) &#125; return res&#125;func min(index int, arr []int) int &#123; min := abs(index-arr[0]) for i := 1; i &lt; len(arr); i++ &#123; if abs(index-arr[i]) &lt; min &#123; min = abs(index-arr[i]) &#125; &#125; return min&#125;func abs(a int) int &#123; if a &lt; 0 &#123; return -a &#125; return a&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 894 . 所有可能的满二叉树]]></title>
    <url>%2Fleetcode-894.html</url>
    <content type="text"><![CDATA[题解递归，满二叉树对应的N一定不会是偶数，每一个节点的左边或右边可能有1、3、5、7…等奇数个节点 示例代码(go)12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func allPossibleFBT(N int) []*TreeNode &#123; arr := make([]*TreeNode, 0) if N % 2 == 0 &#123; return arr &#125; if N == 1 &#123; arr = append(arr, new(TreeNode)) return arr &#125; for i := 1; i &lt; N; i+=2 &#123; left := allPossibleFBT(i) right := allPossibleFBT(N-i-1) for _, lt := range left &#123; for _, rt := range right &#123; node := new(TreeNode) node.Left = lt node.Right = rt arr = append(arr, node) &#125; &#125; &#125; return arr&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 756. 金字塔转换矩阵]]></title>
    <url>%2Fleetcode-756.html</url>
    <content type="text"><![CDATA[题解递归，通过bottom找出下一层字符串next，判断是否可以最终找到长度为1的的顶层字符串 示例代码(go)1234567891011121314151617181920func pyramidTransition(bottom string, allowed []string) bool &#123; return canTrans(bottom, "", allowed)&#125;func canTrans(bottom, next string, allowed []string) bool &#123; if len(bottom) == 1 &#123; return true &#125; if len(bottom) - len(next) &gt; 1 &#123; can := false for _, str := range allowed &#123; if bottom[len(next)] == str[0] &amp;&amp; bottom[len(next)+1] == str[1] &#123; can = can || canTrans(bottom, next+string(str[2]), allowed) &#125; &#125; return can &#125; else &#123; return canTrans(next, "", allowed) &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 740. 删除与获得点数]]></title>
    <url>%2Fleetcode-740.html</url>
    <content type="text"><![CDATA[题解分别统计nums中相同数字的和，遍历数组arr，比较i处的相邻arr[i-1]和相隔arr[i-2]+arr[i]的大小 示例代码(go)123456789101112131415161718192021func deleteAndEarn(nums []int) int &#123; max := 0 for _, v := range nums &#123; max = Max(max, v) &#125; arr := make([]int, max+1) for _, v := range nums &#123; arr[v] += v &#125; for i := 2; i &lt;= max; i++ &#123; arr[i] = Max(arr[i-1], arr[i-2] + arr[i]); &#125; return arr[max]&#125;func Max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 648. 单词替换]]></title>
    <url>%2Fleetcode-648.html</url>
    <content type="text"><![CDATA[题解判断单词是否有词根前缀 示例代码(go)1234567891011func replaceWords(dict []string, sentence string) string &#123; arr := strings.Split(sentence, " ") for i := 0; i &lt; len(arr); i++ &#123; for _, root := range dict &#123; if strings.HasPrefix(arr[i], root) &#123; arr[i] = root &#125; &#125; &#125; return strings.Join(arr, " ")&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 49. 字母异位词分组]]></title>
    <url>%2Fleetcode-49.html</url>
    <content type="text"><![CDATA[题解遍历strs数组，对word进行排序，判断str是否在hashMap中 示例代码(go)12345678910111213141516func groupAnagrams(strs []string) [][]string &#123; res := make([][]string, 0) hashMap := make(map[string]int) for _, word := range strs &#123; arr := strings.Split(word, "") sort.Strings(arr) str := strings.Join(arr, "") if i, ok := hashMap[str]; ok &#123; res[i] = append(res[i], word) &#125; else &#123; hashMap[str] = len(res) res = append(res, []string&#123;word&#125;) &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 434. 字符串中的单词数]]></title>
    <url>%2Fleetcode-434.html</url>
    <content type="text"><![CDATA[题解遍历字符串s，判断当前字符和前一个字符 示例代码(go)123456789func countSegments(s string) int &#123; res := 0 for i := 0; i &lt; len(s); i++ &#123; if s[i] != ' ' &amp;&amp; ( i == 0 || s[i-1] == ' ') &#123; res++ &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 859. 亲密字符串]]></title>
    <url>%2Fleetcode-859.html</url>
    <content type="text"><![CDATA[题解分为两种情况，A和B相等，判断是否出现相同的两个字母；A和B不同，找出不同之处的索引值m和n进行判断 示例代码(go)1234567891011121314151617181920212223242526272829303132func buddyStrings(A string, B string) bool &#123; if len(A) != len(B) &#123; return false &#125; if A == B &#123; hashMap := make(map[byte]int) for i := 0; i &lt; len(A); i++ &#123; hashMap[A[i]]++ if hashMap[A[i]] == 2 &#123; return true &#125; &#125; return false &#125; else &#123; m, n := -1, -1 for i := 0; i &lt; len(A); i++ &#123; if A[i] != B[i] &#123; if m == -1 &#123; m = i &#125; else if n == -1 &#123; n = i &#125; else &#123; return false &#125; &#125; &#125; if n == -1 || A[m] != B[n] || A[n] != B[m] &#123; return false &#125; &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 404. 左叶子之和]]></title>
    <url>%2Fleetcode-404.html</url>
    <content type="text"><![CDATA[题解找出左叶子节点，可以通过叶子节点的父节点进行判断 示例代码(go)123456789101112131415161718192021222324/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func sumOfLeftLeaves(root *TreeNode) int &#123; res := 0 if root == nil &#123; return 0 &#125; if root.Left != nil &amp;&amp; root.Left.Left == nil &amp;&amp; root.Left.Right == nil &#123; res += root.Left.Val &#125; if root.Left != nil &#123; res += sumOfLeftLeaves(root.Left) &#125; if root.Right != nil &#123; res += sumOfLeftLeaves(root.Right) &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 606. 根据二叉树创建字符串]]></title>
    <url>%2Fleetcode-606.html</url>
    <content type="text"><![CDATA[题解递归遍历，无效的括号包含两种情况，节点左右子树为空 或 节点右子树为空 示例代码(go)1234567891011121314151617181920/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func tree2str(t *TreeNode) string &#123; if t == nil &#123; return "" &#125; if t.Left == nil &amp;&amp; t.Right == nil &#123; return strconv.Itoa(t.Val) &#125; if t.Right == nil &#123; return strconv.Itoa(t.Val) + "(" + tree2str(t.Left) + ")" &#125; return strconv.Itoa(t.Val) + "(" + tree2str(t.Left) + ")" + "(" + tree2str(t.Right) + ")"&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 312. 戳气球]]></title>
    <url>%2Fleetcode-312.html</url>
    <content type="text"><![CDATA[题解动态规划，dp[i][j]表示戳爆从i到j个气球的最大金币数，依次戳爆1、2、3…n个气球，最终得到dp[1][n]表示最大金币数 示例代码(go)123456789101112131415161718192021func maxCoins(nums []int) int &#123; n := len(nums) dp := make([][]int, n+2) for i := 0; i &lt; n+2; i++ &#123; dp[i] = make([]int, n+1) &#125; nums = append(nums, 1) nums = append([]int&#123;1&#125;, nums...) for m := 1; m &lt;= n; m++ &#123; for i := 1; i &lt;= n-m+1; i++ &#123; j := i+m-1 for k := i; k &lt;= j; k++ &#123; sum := nums[i-1] * nums[k] * nums[j+1] + dp[i][k-1] + dp[k+1][j] if dp[i][j] &lt; sum &#123; dp[i][j] = sum &#125; &#125; &#125; &#125; return dp[1][n]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 228. 汇总区间]]></title>
    <url>%2Fleetcode-228.html</url>
    <content type="text"><![CDATA[题解首先初始化start、end代表区间的首尾，然后遍历nums找出连续的数字 示例代码(go)12345678910111213141516171819202122232425262728func summaryRanges(nums []int) []string &#123; res := make([]string, 0) if len(nums) == 0 &#123; return res &#125; start, end := nums[0], nums[0] for i := 1; i &lt; len(nums); i++ &#123; if nums[i] == nums[i-1]+1 &#123; end = nums[i] continue &#125; res = append(res, sprintf(start, end)) start = nums[i] end = nums[i] &#125; res = append(res, sprintf(start, end)) return res&#125;func sprintf(start int, end int) string &#123; str := "" if start != end &#123; str = fmt.Sprintf("%d-&gt;%d", start, end) &#125; else &#123; str = fmt.Sprintf("%d", start) &#125; return str&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 647. 回文子串]]></title>
    <url>%2Fleetcode-647.html</url>
    <content type="text"><![CDATA[题解遍历字符串s，分为奇偶两种情况，例如，xax中的a是回文子串，则xax也是回文子串；xaax中的aa是回文子串，则xaax也是回文子串 示例代码(go)1234567891011121314151617181920func countSubstrings(s string) int &#123; length, res := len(s), 0 for i := 0; i &lt; length; i++ &#123; for j := 0; i-j &gt;= 0 &amp;&amp; i+j &lt; length; j++ &#123; if s[i+j] == s[i-j] &#123; res++ &#125; else &#123; break &#125; &#125; for j := 0; i-j &gt;= 0 &amp;&amp; i+j+1 &lt; length; j++ &#123; if s[i+j+1] == s[i-j] &#123; res++ &#125; else &#123; break &#125; &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 953. 验证外星语词典]]></title>
    <url>%2Fleetcode-953.html</url>
    <content type="text"><![CDATA[题解依次比较words中连续的两个单词，前一个单词的字典序大于后一个时返回false 示例代码(go)12345678910111213141516171819202122232425262728func isAlienSorted(words []string, order string) bool &#123; for i := 1; i &lt; len(words); i++ &#123; if compare(words[i-1], words[i], order) == 1 &#123; return false &#125; &#125; return true&#125;func compare(a string, b string, order string) int &#123; la, lb := len(a), len(b) for i, j := 0, 0; i &lt; la &amp;&amp; j &lt; lb; &#123; if strings.Index(order, string(a[i])) &gt; strings.Index(order, string(b[j])) &#123; return 1 &#125; if strings.Index(order, string(a[i])) &lt; strings.Index(order, string(b[j])) &#123; return -1 &#125; i++ j++ &#125; if la &gt; lb &#123; return 1 &#125; else if la &lt; lb &#123; return -1 &#125; return 0&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 77. 组合]]></title>
    <url>%2Fleetcode-77.html</url>
    <content type="text"><![CDATA[题解回溯，每一个组合都是递逐渐增的 示例代码(go)12345678910111213141516171819func combine(n int, k int) [][]int &#123; res := make([][]int, 0) backtrack(&amp;res, n, 1, k, []int&#123;&#125;) return res&#125;func backtrack(res *[][]int, n int, num int, k int, visit []int) &#123; if len(visit) == k &#123; tmp := make([]int, 0) tmp = append(tmp, visit...) *res = append(*res, tmp) &#125; else &#123; for i := num; i &lt;= n; i++ &#123; visit = append(visit, i) backtrack(res, n, i+1, k, visit) visit = visit[:len(visit)-1] &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 969. 煎饼排序]]></title>
    <url>%2Fleetcode-969.html</url>
    <content type="text"><![CDATA[题解首先复制A的值到B，对B进行倒序排列，然后遍历B的值，并找出其在A中的位置，接着进行两次翻转，第一次翻转会先把值放在首位，第二次翻转则会把值依次放在后面，最终会完成排序 示例代码(go)123456789101112131415161718192021222324252627282930func pancakeSort(A []int) []int &#123; length := len(A) res := make([]int, 0) B := make([]int, 0) B = append(B, A...) sort.Sort(sort.Reverse(sort.IntSlice(B))) for i, v := range B &#123; index := find(A, v) res = append(res, index + 1) res = append(res, length - i) reverse(A, index + 1) reverse(A, length - i) &#125; return res&#125;func find(arr []int, num int) int &#123; for i, v := range arr &#123; if num == v &#123; return i &#125; &#125; return -1&#125;func reverse(arr []int, k int) &#123; for i := 0; i &lt; (k / 2); i++ &#123; arr[i], arr[k-i-1] = arr[k-i-1], arr[i] &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 129. 求根到叶子节点数字之和]]></title>
    <url>%2Fleetcode-129.html</url>
    <content type="text"><![CDATA[题解遍历二叉树，依次改变节点值，子节点值 = 子节点值 + 父节点值 * 10，最后返回所有叶子节点值的和 示例代码(go)1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func sumNumbers(root *TreeNode) int &#123; res := 0 if root == nil &#123; return res &#125; if root.Left != nil &#123; root.Left.Val += root.Val * 10 &#125; if root.Right != nil &#123; root.Right.Val += root.Val * 10 &#125; if root.Left == nil &amp;&amp; root.Right == nil &#123; res += root.Val &#125; res += sumNumbers(root.Left) res += sumNumbers(root.Right) return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 120. 三角形最小路径和]]></title>
    <url>%2Fleetcode-120.html</url>
    <content type="text"><![CDATA[题解自底向上依次选取最小值相加 示例代码(go)123456789101112func minimumTotal(triangle [][]int) int &#123; for i := len(triangle)-2; i &gt;= 0; i-- &#123; for j := 0; j &lt; len(triangle[i]); j++ &#123; if triangle[i+1][j] &gt; triangle[i+1][j+1] &#123; triangle[i][j] += triangle[i+1][j+1] &#125; else &#123; triangle[i][j] += triangle[i+1][j] &#125; &#125; &#125; return triangle[0][0]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 766. 托普利茨矩阵]]></title>
    <url>%2Fleetcode-766.html</url>
    <content type="text"><![CDATA[题解遍历数组matrix，比较当前元素与下一个对角线元素 示例代码(go)12345678910111213func isToeplitzMatrix(matrix [][]int) bool &#123; isToeplitz := true m, n := len(matrix[0]), len(matrix) for i := 0; i &lt; n; i++ &#123; for j := 0; j &lt; m; j++ &#123; if (i+1) &lt; n &amp;&amp; (j+1) &lt; m &amp;&amp; matrix[i][j] != matrix[i+1][j+1] &#123; isToeplitz = false break &#125; &#125; &#125; return isToeplitz&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 508. 出现次数最多的子树元素和]]></title>
    <url>%2Fleetcode-508.html</url>
    <content type="text"><![CDATA[题解找出子树元素和的出现次数存入hashMap，出现次数最大值max 示例代码(go)1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func findFrequentTreeSum(root *TreeNode) []int &#123; arr := make([]int, 0) hashMap := make(map[int]int) max := 1 if root == nil &#123; return arr &#125; findMap(root, hashMap, &amp;max) for k, v := range hashMap &#123; if v == max &#123; arr = append(arr, k) &#125; &#125; return arr&#125;func findMap(root *TreeNode, hashMap map[int]int, max *int) int &#123; sum := root.Val if root.Left != nil &#123; sum += findMap(root.Left, hashMap, max) &#125; if root.Right != nil &#123; sum += findMap(root.Right, hashMap, max) &#125; hashMap[sum]++ if hashMap[sum] &gt; *max &#123; *max = hashMap[sum] &#125; return sum&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 451. 根据字符出现频率排序]]></title>
    <url>%2Fleetcode-451.html</url>
    <content type="text"><![CDATA[题解创建字符串数组arr，字符位置表indexMap，遍历字符串s，如果字符已经存在arr中就加在后面，不存在则新增，然后根据arr中元素的字符串长度排序，最后返回连接后的字符串 示例代码(go)12345678910111213141516func frequencySort(s string) string &#123; arr := make([]string, 0) indexMap := make(map[rune]int) for _, v := range s &#123; if _, ok := indexMap[v]; ok &#123; arr[indexMap[v]] += string(v) &#125; else &#123; arr = append(arr, string(v)) indexMap[v] = len(arr) - 1 &#125; &#125; sort.Slice(arr, func(i, j int) bool &#123; return len(arr[i]) &gt; len(arr[j]) &#125;) return strings.Join(arr, "")&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 791. 自定义字符串排序]]></title>
    <url>%2Fleetcode-791.html</url>
    <content type="text"><![CDATA[题解找出每个字母在S中的索引位置i，遍历T，与arr中相应位置的字符串合并 示例代码(go)123456789101112131415func customSortString(S string, T string) string &#123; arr := make([]string, 26) indexMap := make(map[rune]int) for i, v := range S &#123; indexMap[v] = i &#125; for _, v := range T &#123; if index, ok := indexMap[v]; ok &#123; arr[index] += string(v) &#125; else &#123; arr[25] += string(v) &#125; &#125; return strings.Join(arr, "")&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 938. 二叉搜索树的范围和]]></title>
    <url>%2Fleetcode-938.html</url>
    <content type="text"><![CDATA[题解二叉搜索树的左边小于根，右边大于根，根值root.Val在L，R之间的就是我们要加上的值 示例代码(go)123456789101112131415161718192021222324/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func rangeSumBST(root *TreeNode, L int, R int) int &#123; res := 0 if root == nil &#123; return res &#125; if root.Val &gt;= L &amp;&amp; root.Val &lt;= R &#123; res += root.Val &#125; if root.Val &gt; L &#123; res += rangeSumBST(root.Left, L, R) &#125; if root.Val &lt; R &#123; res += rangeSumBST(root.Right, L, R) &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 419. 甲板上的战舰]]></title>
    <url>%2Fleetcode-419.html</url>
    <content type="text"><![CDATA[题解左边和上边没有X的点位则为战舰 示例代码(go)1234567891011121314151617func countBattleships(board [][]byte) int &#123; res := 0 for i := 0; i &lt; len(board); i++ &#123; for j := 0; j &lt; len(board[i]); j++ &#123; if board[i][j] == 'X' &#123; if j-1 &gt;= 0 &amp;&amp; board[i][j-1] == 'X'&#123; continue &#125; if i-1 &gt;= 0 &amp;&amp; board[i-1][j] == 'X'&#123; continue &#125; res++ &#125; &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 748. 最短完整词]]></title>
    <url>%2Fleetcode-748.html</url>
    <content type="text"><![CDATA[题解记录牌照licensePlate中每个字母出现的次数，遍历单词表words找出符合要求的最短单词 示例代码(go)12345678910111213141516171819202122232425262728293031func shortestCompletingWord(licensePlate string, words []string) string &#123; licensePlateMap := make(map[rune]int) res := "" for _, v := range licensePlate &#123; if v &gt;= 'a' &amp;&amp; v &lt;= 'z' &#123; licensePlateMap[v] += 1 &#125; if v &gt;= 'A' &amp;&amp; v &lt;= 'Z' &#123; licensePlateMap[v -'A' + 'a'] += 1 &#125; &#125; for _, word := range words &#123; if res == "" || len(word) &lt; len(res) &#123; wordMap := make(map[rune]int) for _, v := range word &#123; wordMap[v] += 1 &#125; flag := true for k, v := range licensePlateMap &#123; if v &gt; wordMap[k] &#123; flag = false break &#125; &#125; if flag &#123; res = word &#125; &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 447. 回旋镖的数量]]></title>
    <url>%2Fleetcode-447.html</url>
    <content type="text"><![CDATA[题解遍历每个点与其它点的距离，具有相同距离的点数如果为n的话，则有n * (n-1)种可能 示例代码(go)123456789101112131415161718func numberOfBoomerangs(points [][]int) int &#123; res := 0 for i := 0; i &lt; len(points); i++ &#123; hashMap := make(map[int]int) for j := 0; j &lt; len(points); j++ &#123; if i != j &#123; x := points[i][0] - points[j][0] y := points[i][1] - points[j][1] distance := x * x + y * y hashMap[distance]++ &#125; &#125; for _, n := range hashMap &#123; res += n * (n-1) &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 337. 打家劫舍 III]]></title>
    <url>%2Fleetcode-337.html</url>
    <content type="text"><![CDATA[题解两种情况，根的值加上不直接相连的左右子树的值，或者不要根植，直接是根的左右子树值的和，比较两种情况下的大小，同时可以加上哈希表返回已经计算过的值 示例代码(go)12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func rob(root *TreeNode) int &#123; stateMap := make(map[*TreeNode]int) return dfs(root, stateMap)&#125;func dfs(root *TreeNode, stateMap map[*TreeNode]int) int &#123; if root == nil &#123; return 0 &#125; if _, ok := stateMap[root]; ok &#123; return stateMap[root] &#125; res := root.Val if root.Left != nil &#123; res += dfs(root.Left.Left, stateMap) + dfs(root.Left.Right, stateMap) &#125; if root.Right != nil &#123; res += dfs(root.Right.Left, stateMap) + dfs(root.Right.Right, stateMap) &#125; val := dfs(root.Left, stateMap) + dfs(root.Right, stateMap) if res &lt; val &#123; res = val &#125; stateMap[root] = res return stateMap[root]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 62. 不同路径]]></title>
    <url>%2Fleetcode-62.html</url>
    <content type="text"><![CDATA[题解动态规划问题，机器人每次只能向下或者向右移动一步，所以每个格子的路径数等于上边格子加上左边格子的路径数和，即dp[i][j] = dp[i-1][j] + dp[i][j-1] 示例代码(go)12345678910111213141516func uniquePaths(m int, n int) int &#123; dp := make([][]int, m) for i := 0; i &lt; m; i++ &#123; dp[i] = make([]int, n) &#125; for i := 0; i &lt; m; i++ &#123; for j := 0; j &lt; n; j++ &#123; if i == 0 || j == 0 &#123; dp[i][j] = 1 &#125; else &#123; dp[i][j] = dp[i-1][j] + dp[i][j-1] &#125; &#125; &#125; return dp[m-1][n-1]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 937. 重新排列日志文件]]></title>
    <url>%2Fleetcode-937.html</url>
    <content type="text"><![CDATA[题解分别找出字母日志和数字日志，并对字母日志进行排序 示例代码(go)1234567891011121314151617181920212223func reorderLogFiles(logs []string) []string &#123; res := make([]string, 0) letterRes := make([]string, 0) digitRes := make([]string, 0) letterMap := make(map[string]int) for i, v := range logs &#123; splitArr := strings.Split(v, " ") joinStr := strings.Join(splitArr[1:], "") if strings.ContainsAny(joinStr, "0123456789") &#123; digitRes = append(digitRes, v) continue &#125; joinStr = strings.Join(splitArr[1:], " ") letterMap[joinStr] = i letterRes = append(letterRes, joinStr) &#125; sort.Sort(sort.StringSlice(letterRes)) for _, v := range letterRes &#123; res = append(res, logs[letterMap[v]]) &#125; res = append(res, digitRes...) return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 749. 隔离病毒]]></title>
    <url>%2Fleetcode-749.html</url>
    <content type="text"><![CDATA[题解找出每一处病毒区域和所需防火墙数的对应virusMap，以及每一处病毒区域威胁到的未感染的区块数目uninfectedCells，并找出最具威胁的病毒区域maxVirus；然后maxVirus对应的病毒区域变为2表示已隔离，其他病毒区域则感染周边区块变为1；继续下次循环直到virusMap[maxVirus] == 0 示例代码(go)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118func containVirus(grid [][]int) int &#123; firewalls := 0 if len(grid) == 0 &#123; return firewalls &#125; for &#123; virusMap, maxVirus := getVirusMap(grid) if virusMap[maxVirus] == 0 &#123; break &#125; cellsTo2(grid, virusMap, maxVirus) cellsTo1(grid, virusMap, maxVirus) firewalls += virusMap[maxVirus] &#125; return firewalls&#125;func getVirusMap(grid [][]int) (map[int]int, int) &#123; col := len(grid) row := len(grid[0]) direction := [][]int&#123;[]int&#123;0, -1&#125;, []int&#123;-1, 0&#125;, []int&#123;0, 1&#125;, []int&#123;1, 0&#125;&#125; maxUninfectedCells := 0 maxVirus := 0 virusMap := make(map[int]int) infectedCellsVisted := make(map[int]bool) for i := 0; i &lt; col; i++ &#123; for j := 0; j &lt; row; j++ &#123; if grid[i][j] == 1 &amp;&amp; !infectedCellsVisted[i*row+j] &#123; virusList := []int&#123;i*row+j&#125; infectedCellsVisted[i*row+j] = true uninfectedCellsVisted := make(map[int]bool) needWalls := 0 uninfectedCells := 0 for len(virusList) &gt; 0 &#123; virus := virusList[0] virusList = virusList[1:] for _, v := range direction &#123; ii := virus / row + v[0] jj := virus % row + v[1] if ii &gt;= 0 &amp;&amp; ii &lt; col &amp;&amp; jj &gt;= 0 &amp;&amp; jj &lt; row &#123; if grid[ii][jj] == 0 &#123; needWalls++ &#125; if grid[ii][jj] == 0 &amp;&amp; !uninfectedCellsVisted[ii*row+jj] &#123; uninfectedCellsVisted[ii*row+jj] = true uninfectedCells++ &#125; if grid[ii][jj] == 1 &amp;&amp; !infectedCellsVisted[ii*row+jj] &#123; infectedCellsVisted[ii*row+jj] = true virusList = append(virusList, ii*row+jj) &#125; &#125; &#125; &#125; virusMap[i*row+j] = needWalls if uninfectedCells &gt; maxUninfectedCells &#123; maxUninfectedCells = uninfectedCells maxVirus = i * row +j &#125; &#125; &#125; &#125; return virusMap, maxVirus&#125;func cellsTo2(grid [][]int, virusMap map[int]int, maxVirus int) &#123; col := len(grid) row := len(grid[0]) direction := [][]int&#123;[]int&#123;0, -1&#125;, []int&#123;-1, 0&#125;, []int&#123;0, 1&#125;, []int&#123;1, 0&#125;&#125; virusList := []int&#123;maxVirus&#125; grid[maxVirus / row][maxVirus % row] = 2 for len(virusList) &gt; 0 &#123; virus := virusList[0] virusList = virusList[1:] for _, v := range direction &#123; ii := virus / row + v[0] jj := virus % row + v[1] if ii &gt;= 0 &amp;&amp; ii &lt; col &amp;&amp; jj &gt;= 0 &amp;&amp; jj &lt; row &#123; if grid[ii][jj] == 1 &#123; grid[ii][jj] = 2 virusList = append(virusList, ii*row+jj) &#125; &#125; &#125; &#125;&#125;func cellsTo1(grid [][]int, virusMap map[int]int, maxVirus int) &#123; visted := make(map[int]bool) col := len(grid) row := len(grid[0]) direction := [][]int&#123;[]int&#123;0, -1&#125;, []int&#123;-1, 0&#125;, []int&#123;0, 1&#125;, []int&#123;1, 0&#125;&#125; for k,_ := range virusMap &#123; if k != maxVirus &#123; virusList := []int&#123;k&#125; visted[k] = true for len(virusList) &gt; 0 &#123; virus := virusList[0] virusList = virusList[1:] for _, v := range direction &#123; ii := virus / row + v[0] jj := virus % row + v[1] if ii &gt;= 0 &amp;&amp; ii &lt; col &amp;&amp; jj &gt;= 0 &amp;&amp; jj &lt; row &#123; if grid[ii][jj] == 0 &#123; grid[ii][jj] = 1 visted[ii*row+jj] = true &#125; if grid[ii][jj] == 1 &amp;&amp; !visted[ii*row+jj] &#123; visted[ii*row+jj] = true virusList = append(virusList, ii*row+jj) &#125; &#125; &#125; &#125; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 628. 三个数的最大乘积]]></title>
    <url>%2Fleetcode-628.html</url>
    <content type="text"><![CDATA[题解找出最大的三个数和最小的两个数，比较最大三个数的乘积和最小两个数与最大数的乘积 示例代码(go)12345678910111213141516171819202122232425func maximumProduct(nums []int) int &#123; res := 0 firstMax, secondMax, thirdMax := math.MinInt32, math.MinInt32, math.MinInt32 firstMin, secondMin := math.MaxInt32, math.MaxInt32 for _, v := range nums &#123; if v &gt; firstMax &#123; firstMax, secondMax, thirdMax = v, firstMax, secondMax &#125; else if v &gt; secondMax &#123; secondMax, thirdMax = v, secondMax &#125; else if v &gt; thirdMax &#123; thirdMax = v &#125; if v &lt; firstMin &#123; firstMin, secondMin = v, firstMin &#125; else if v &lt; secondMin &#123; secondMin = v &#125; &#125; res = firstMax * secondMax * thirdMax if res &lt; firstMin * secondMin * firstMax &#123; res = firstMin * secondMin * firstMax &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 638. 大礼包]]></title>
    <url>%2Fleetcode-638.html</url>
    <content type="text"><![CDATA[题解迭代，如果某个礼包special[i]是可以合法购买的（礼包物品的数量小于预购物品数），则以该礼包的价格special[i][len(needs)]加上购买剩余商品的最低价格，即对remainNeeds进行迭代 示例代码(go)123456789101112131415161718192021222324func shoppingOffers(price []int, special [][]int, needs []int) int &#123; minPrice := 0 for i := 0; i &lt; len(price); i++ &#123; minPrice += price[i] * needs[i] &#125; for i := 0; i &lt; len(special); i++ &#123; isValid := true remainNeeds := make([]int, len(needs)) for j := 0; j &lt; len(needs); j++ &#123; if special[i][j] &gt; needs[j] &#123; isValid = false break &#125; remainNeeds[j] = needs[j] - special[i][j] &#125; if isValid &#123; price := shoppingOffers(price, special, remainNeeds) + special[i][len(needs)] if price &lt; minPrice &#123; minPrice = price &#125; &#125; &#125; return minPrice&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 401. 二进制手表]]></title>
    <url>%2Fleetcode-401.html</url>
    <content type="text"><![CDATA[题解前六位代表分钟，后四位代表时钟，组成十位二进制，当num=1时，共计0000000001~1000000000 10种可能，换成十进制即是1~512，因为前六位代表的分钟，所以hour小时就等于十进制数值除以64，minute分钟则是对64取模，当num=2,3,4...时，对于bits每一个值，左边依次找一个二进制位变为1，比如0000010000可以变成0000110000, 0001010000一直到1000010000，同时也要排除掉大于768和在[60,64]之间的值，因为时钟不能为12，分钟不能大于59 示例代码(go)123456789101112131415161718192021222324252627282930func readBinaryWatch(num int) []string &#123; times := []string&#123;&#125; if num == 0 &#123; return []string&#123;"0:00"&#125; &#125; bits := []int&#123;1&#125; for i := 0; i &lt; 9; i++ &#123; bits = append(bits, bits[i]*2) &#125; for i := 1; i &lt; num; i++ &#123; nextBits := []int&#123;&#125; for _, v := range bits &#123; for add := 1; add &lt;= 512; add *= 2 &#123; if v + add &gt;= 768 || (v + add &gt;= 60 &amp;&amp; v + add &lt; 64) &#123; continue &#125; if add &gt; v &#123; nextBits = append(nextBits, v + add) &#125; &#125; &#125; bits = nextBits &#125; for _, v := range bits &#123; hour := v / 64 minute := v % 64 times = append(times, fmt.Sprintf("%d:%02d", hour, minute)) &#125; return times&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 932. 漂亮数组]]></title>
    <url>%2Fleetcode-932.html</url>
    <content type="text"><![CDATA[题解可以知道A[k] * 2是一个偶数， 当 i &lt; k &lt; j时，为了使 A[k] * 2 != A[i] + A[j]，可以让左边全奇数，右边全偶数 示例代码(go)1234567891011121314151617func beautifulArray(N int) []int &#123; res := make([]int, 0) if N == 1 &#123; return []int&#123;1&#125; &#125; left := beautifulArray((N +1) / 2) right := beautifulArray(N / 2) for _, v := range left &#123; res = append(res, 2 * v - 1) &#125; for _, v := range right &#123; res = append(res, 2 * v) &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 547. 朋友圈]]></title>
    <url>%2Fleetcode-547.html</url>
    <content type="text"><![CDATA[题解广度搜索的思想，如果某学生还没有出现在visited数组中，则朋友圈数count加一，并加入队列queue，然后搜索是朋友关系的同学加入queue 示例代码(go)12345678910111213141516171819202122func findCircleNum(M [][]int) int &#123; students := len(M[0]) visited := make([]int, students) count := 0 for i := 0; i &lt; students; i++ &#123; if visited[i] == 0 &#123; count++ visited[i] = 1 queue := []int&#123;i&#125; for len(queue) &gt; 0 &#123; for j := 0; j &lt; students; j++ &#123; if visited[j] == 0 &amp;&amp; M[queue[0]][j] == 1 &#123; visited[j] = 1 queue = append(queue, j) &#125; &#125; queue = queue[1:] &#125; &#125; &#125; return count&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[python环境安装]]></title>
    <url>%2Fpython-install.html</url>
    <content type="text"><![CDATA[python安装Anaconda 是一个用于科学计算的 Python 发行版，支持 Linux, Mac, Windows, 包含了许多常用的科学计算、数据分析的 Python包。下载地址Anaconda，版本的话建议选python3，各个平台的安装都不算太复杂，照着步骤安装就行了。 conda简单使用conda是一个开源包管理系统和环境管理系统，包含在Anaconda安装中，下面是一些简单的命令。 显示版本信息 conda --version 查看当前环境下已安装的包 conda list 安装包 conda install requests 更新包 conda update requests 删除包 conda remove requests 配置国内镜像conda在国内安装包的时候可能会很慢，可以配置国内源加速下载，下面是清华源的配置123conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls yes]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 328. 奇偶链表]]></title>
    <url>%2Fleetcode328.html</url>
    <content type="text"><![CDATA[题解分成奇链和偶链两条链，然后把奇链的尾指向偶链的头 示例代码(go)12345678910111213func oddEvenList(head *ListNode) *ListNode &#123; if head == nil&#123; return nil &#125; odd, even, evenHead := head, head.Next, head.Next for even != nil &amp;&amp; even.Next != nil&#123; odd.Next, even.Next = even.Next, even.Next.Next odd = odd.Next even = even.Next &#125; odd.Next = evenHead return head&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 14. 最长公共前缀]]></title>
    <url>%2Fleetcode14.html</url>
    <content type="text"><![CDATA[题解strs数组中首个字符串与其余字符串，分别比较它们的每一位，如果全部相同则加入到prefix中 示例代码(go)123456789101112131415161718func longestCommonPrefix(strs []string) string &#123; prefix := make([]byte, 0) strsNums := len(strs) if strsNums == 0 &#123; return "" &#125; nums := len(strs[0]) for i := 0; i &lt; nums; i++ &#123; for j := 1; j &lt; strsNums; j++ &#123; if len(strs[j]) == i || strs[j][i] != strs[0][i] &#123; return string(prefix) &#125; &#125; prefix = append(prefix, strs[0][i]) &#125; return string(prefix)&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 739. Daily Temperatures 每日温度]]></title>
    <url>%2Fleetcode739.html</url>
    <content type="text"><![CDATA[题解数组stack作为栈，通过append和切片模拟入栈出栈操作 迭代数组T 数组T的索引0入栈 迭代的值大于栈顶索引的值，即v &gt; T[stack[len(stack)-1]]，则栈顶元素出栈，并存入res 重复步骤3, 直到栈为空 或 v不大于T[stack[len(stack)-1]] 数组T迭代完毕，返回数组res 示例代码(go)12345678910111213141516func dailyTemperatures(T []int) []int &#123; res := make([]int, len(T)) stack := make([]int, 0) for i, v := range T &#123; for len(stack) &gt; 0 &#123; if v &gt; T[stack[len(stack)-1]] &#123; res[stack[len(stack)-1]] = i - stack[len(stack)-1] stack = stack[:len(stack)-1] &#125; else &#123; break &#125; &#125; stack = append(stack, i) &#125; return res&#125;]]></content>
  </entry>
</search>
