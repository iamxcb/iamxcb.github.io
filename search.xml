<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode 1106. 解析布尔表达式]]></title>
    <url>%2Fleetcode-1106.html</url>
    <content type="text"><![CDATA[题目描述给你一个以字符串形式表述的 布尔表达式（boolean） expression，返回该式的运算结果。有效的表达式需遵循以下约定： “t”，运算结果为 True “f”，运算结果为 False “!(expr)”，运算过程为对内部表达式 expr 进行逻辑 非的运算（NOT） “&amp;(expr1,expr2,…)”，运算过程为对 2 个或以上内部表达式 expr1, expr2, … 进行逻辑 与的运算（AND） “|(expr1,expr2,…)”，运算过程为对 2 个或以上内部表达式 expr1, expr2, … 进行逻辑 或的运算（OR） 示例 1：输入：expression = “!(f)”输出：true 示例 2：输入：expression = “|(f,t)”输出：true 示例 3：输入：expression = “&amp;(t,f)”输出：false 示例 4：输入：expression = “|(&amp;(t,f,t),!(t))”输出：false 题解两个栈，一个存操作 stackOp，一个存值 stackVal，遇到字符 ) 时计算相应表达式的值（以(开始的表达式），加入栈 stackVal 示例代码(go)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func parseBoolExpr(expression string) bool &#123; stackOp := make([]byte, 0) stackVal := make([]byte, 0) n := len(expression) for i := 0; i &lt; n; i++ &#123; if expression[i] == '&amp;' || expression[i] == '|' || expression[i] == '!' &#123; stackOp = append(stackOp, expression[i]) &#125; if expression[i] == '(' || expression[i] == 't' || expression[i] == 'f' &#123; stackVal = append(stackVal, expression[i]) &#125; if expression[i] == ')' &#123; haveT, haveF := false, false op := stackOp[len(stackOp)-1] stackOp = stackOp[:len(stackOp)-1] for stackVal[len(stackVal)-1] != '(' &#123; if stackVal[len(stackVal)-1] == 't' &#123; haveT = true &#125; else &#123; haveF = true &#125; stackVal = stackVal[:len(stackVal)-1] &#125; stackVal = stackVal[:len(stackVal)-1] if op == '!' &#123; if haveT &#123; stackVal = append(stackVal, 'f') &#125; else &#123; stackVal = append(stackVal, 't') &#125; &#125; if op == '&amp;' &#123; if haveF &#123; stackVal = append(stackVal, 'f') &#125; else &#123; stackVal = append(stackVal, 't') &#125; &#125; if op == '|' &#123; if haveT &#123; stackVal = append(stackVal, 't') &#125; else &#123; stackVal = append(stackVal, 'f') &#125; &#125; &#125; &#125; if stackVal[0] == 't' &#123; return true &#125; return false&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 30. 串联所有单词的子串]]></title>
    <url>%2Fleetcode-30.html</url>
    <content type="text"><![CDATA[题目描述给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。 示例 1：输入： s = “barfoothefoobarman”, words = [“foo”,”bar”]输出：[0,9]解释：从索引 0 和 9 开始的子串分别是 “barfoor” 和 “foobar” 。输出的顺序不重要, [9,0] 也是有效答案。 示例 2：输入： s = “wordgoodgoodgoodbestword”, words = [“word”,”good”,”best”,”word”]输出：[] 题解暴力解法，直接通过哈希表判断每个子串是否符合题目要求 示例代码(go)1234567891011121314151617181920212223242526272829func findSubstring(s string, words []string) []int &#123; res := make([]int, 0) m, k := len(words), len(s) if m == 0 || k == 0&#123; return res &#125; n := len(words[0]) hashW := make(map[string]int) for _, word := range words &#123; hashW[word]++ &#125; for i := 0; i &lt;= k-m*n; i++ &#123; if isSubstring(s[i:i+m*n], m, n, hashW) &#123; res = append(res, i) &#125; &#125; return res&#125;func isSubstring(s string, m, n int, hashW map[string]int) bool &#123; hashS := make(map[string]int) for i := 0; i &lt; m*n; i += n &#123; hashS[s[i:i+n]]++ if hashW[s[i:i+n]] &lt; 1 || hashS[s[i:i+n]] &gt; hashW[s[i:i+n]] &#123; return false &#125; &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 87. 扰乱字符串]]></title>
    <url>%2Fleetcode-87.html</url>
    <content type="text"><![CDATA[题目描述给定一个字符串 s1，我们可以把它递归地分割成两个非空子字符串，从而将其表示为二叉树。 下图是字符串 s1 = “great” 的一种可能的表示形式。 great / \ gr eat / \ / \g r e at / \ a t在扰乱这个字符串的过程中，我们可以挑选任何一个非叶节点，然后交换它的两个子节点。 例如，如果我们挑选非叶节点 “gr” ，交换它的两个子节点，将会产生扰乱字符串 “rgeat” 。 rgeat / \ rg eat / \ / \r g e at / \ a t我们将 “rgeat” 称作 “great” 的一个扰乱字符串。 同样地，如果我们继续将其节点 “eat” 和 “at” 进行交换，将会产生另一个新的扰乱字符串 “rgtae” 。 rgtae / \ rg tae / \ / \r g ta e / \ t a我们将 “rgtae” 称作 “great” 的一个扰乱字符串。 给出两个长度相等的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。 示例 1:输入: s1 = “great”, s2 = “rgeat”输出: true 示例 2:输入: s1 = “abcde”, s2 = “caebd”输出: false 题解递归，i 作为分割位，分割之后的两部分 s[:i+1], s[i+1:] 可能交换，也可能不交换，所以有两种可能 示例代码(go)1234567891011121314151617181920212223242526272829303132func isScramble(s1 string, s2 string) bool &#123; if s1 == s2 &#123; return true &#125; if !isSame(s1, s2) &#123; return false &#125; n := len(s1) for i := 1; i &lt; n; i++ &#123; if isScramble(s1[:i], s2[:i]) &amp;&amp; isScramble(s1[i:], s2[i:]) &#123; return true &#125; if isScramble(s1[:i], s2[n-i:]) &amp;&amp; isScramble(s1[i:], s2[:n-i]) &#123; return true &#125; &#125; return false&#125;func isSame(s1, s2 string) bool &#123; hash := make(map[byte]int) for i := len(s1)-1; i &gt;= 0; i-- &#123; hash[s1[i]]++ &#125; for i := len(s2)-1; i &gt;= 0; i-- &#123; hash[s2[i]]-- if hash[s2[i]] &lt; 0 &#123; return false &#125; &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 982. 按位与为零的三元组]]></title>
    <url>%2Fleetcode-982.html</url>
    <content type="text"><![CDATA[题目描述给定一个整数数组 A，找出索引为 (i, j, k) 的三元组，使得： 0 &lt;= i &lt; A.length 0 &lt;= j &lt; A.length 0 &lt;= k &lt; A.length A[i] &amp; A[j] &amp; A[k] == 0，其中 &amp; 表示按位与（AND）操作符。 示例：输入：[2,1,3]输出：12解释：我们可以选出如下 i, j, k 三元组：(i=0, j=0, k=1) : 2 &amp; 2 &amp; 1(i=0, j=1, k=0) : 2 &amp; 1 &amp; 2(i=0, j=1, k=1) : 2 &amp; 1 &amp; 1(i=0, j=1, k=2) : 2 &amp; 1 &amp; 3(i=0, j=2, k=1) : 2 &amp; 3 &amp; 1(i=1, j=0, k=0) : 1 &amp; 2 &amp; 2(i=1, j=0, k=1) : 1 &amp; 2 &amp; 1(i=1, j=0, k=2) : 1 &amp; 2 &amp; 3(i=1, j=1, k=0) : 1 &amp; 1 &amp; 2(i=1, j=2, k=0) : 1 &amp; 3 &amp; 2(i=2, j=0, k=1) : 3 &amp; 2 &amp; 1(i=2, j=1, k=0) : 3 &amp; 1 &amp; 2 提示： 1 &lt;= A.length &lt;= 1000 0 &lt;= A[i] &lt; 2^16 题解分两步，先计算 A[i] &amp; A[j] 保存出现的次数，再计算 (A[i] &amp; A[j]) &amp; A[k] 判断是否为零 示例代码(go)1234567891011121314151617func countTriplets(A []int) int &#123; res, n := 0, len(A) hash := make(map[int]int) for i := 0; i &lt; n; i++ &#123; for j := 0; j &lt; n; j++ &#123; hash[A[i] &amp; A[j]]++ &#125; &#125; for key, count := range hash &#123; for k := 0; k &lt; n; k++ &#123; if key &amp; A[k] == 0 &#123; res += count &#125; &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 36. 有效的数独]]></title>
    <url>%2Fleetcode-36.html</url>
    <content type="text"><![CDATA[题目描述判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。 数独部分空格内已填入了数字，空白格用 ‘.’ 表示。 示例 1: 输入: [ ["5","3",".",".","7",".",".",".","."], ["6",".",".","1","9","5",".",".","."], [".","9","8",".",".",".",".","6","."], ["8",".",".",".","6",".",".",".","3"], ["4",".",".","8",".","3",".",".","1"], ["7",".",".",".","2",".",".",".","6"], [".","6",".",".",".",".","2","8","."], [".",".",".","4","1","9",".",".","5"], [".",".",".",".","8",".",".","7","9"] ] 输出: true 示例 2: 输入:[ [“8”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”], [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”], [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”], [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”], [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”], [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”], [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”], [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”], [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。说明:一个有效的数独（部分已被填充）不一定是可解的。只需要根据以上规则，验证已经填入的数字是否有效即可。给定数独序列只包含数字 1-9 和字符 ‘.’ 。给定数独永远是 9x9 形式的。 题解使用三个二维数组 a, b, c 分别保存每行，每列，每个 3*3 区块中，相应数字出现的次数 示例代码(go)123456789101112131415161718192021func isValidSudoku(board [][]byte) bool &#123; a := [9][9]int&#123;&#125; b := [9][9]int&#123;&#125; c := [9][9]int&#123;&#125; for i := 0; i &lt; 9; i++ &#123; for j := 0; j &lt; 9; j++ &#123; if board[i][j] == '.' &#123; continue &#125; num := board[i][j] - '0' k := (i / 3) * 3 + j / 3 a[i][num-1]++ b[j][num-1]++ c[k][num-1]++ if a[i][num-1] &gt; 1 || b[j][num-1] &gt; 1 || c[k][num-1] &gt; 1 &#123; return false &#125; &#125; &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 76. 最小覆盖子串]]></title>
    <url>%2Fleetcode-76.html</url>
    <content type="text"><![CDATA[题目描述给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。 示例：输入: S = “ADOBECODEBANC”, T = “ABC”输出: “BANC” 说明：如果 S 中不存这样的子串，则返回空字符串 “”。如果 S 中存在这样的子串，我们保证它是唯一的答案。 题解双指针，滑动窗口 示例代码(go)12345678910111213141516171819202122232425262728293031323334func minWindow(s string, t string) string &#123; res := "" left, right := 0, 0 n := len(s) hashS := make(map[byte]int) hashT := make(map[byte]int) for _, v := range t &#123; hashT[byte(v)]++ &#125; for right &lt; n &#123; hashS[s[right]]++ for left &lt;= right &amp;&amp; contains(hashS, hashT) &#123; if res == "" &#123; res = s[left:right+1] &#125; if len(res) &gt; right-left+1 &#123; res = s[left:right+1] &#125; hashS[s[left]]-- left++ &#125; right++ &#125; return res&#125;func contains(hashS, hashT map[byte]int) bool &#123; for k, v := range hashT &#123; if hashS[k] &lt; v &#123; return false &#125; &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 828. 独特字符串]]></title>
    <url>%2Fleetcode-828.html</url>
    <content type="text"><![CDATA[题目描述如果一个字符在字符串 S 中有且仅有出现一次，那么我们称其为独特字符。例如，在字符串 S = “LETTER” 中，”L” 和 “R” 可以被称为独特字符。我们再定义 UNIQ(S) 作为字符串 S 中独特字符的个数。那么，在 S = “LETTER” 中， UNIQ(“LETTER”) = 2。对于给定字符串 S，计算其所有非空子串的独特字符的个数（即 UNIQ(substring)）之和。如果在 S 的不同位置上出现两个甚至多个相同的子串，那么我们认为这些子串是不同的。考虑到答案可能会非常大，规定返回格式为：结果 mod 10 ^ 9 + 7。 示例 1:输入: “ABC”输出: 10解释: 所有可能的子串为：”A”,”B”,”C”,”AB”,”BC” 和 “ABC”。其中，每一个子串都由独特字符构成。所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10 示例 2:输入: “ABA”输出: 8解释: 除了子串 UNIQ(‘ABA’) = 1，其余与示例1相同。 说明: 0 &lt;= S.length &lt;= 10000。 题解首先子串的独特字符的个数和即 sum(UNIQ(substring))，可以转化为求解包含 S[i] 的子串中，S[i] 为独特字符的和即 sum(UNIQ(S[i])) ；同时包含 S[i] 的子串中，可能会存在 S[i] 永远不会为独特字符的子串；当 j &lt; i &amp;&amp; S[j] == S[i] 时，以 S[j] 开始的子串会使 S[i] 永远成不了独特字符；当 k &gt; i &amp;&amp; S[k] == S[i] 时，以 S[k] 结尾的子串会使 S[i] 永远成不了独特字符；所以可以去除这两种情况，在 S[j+1:k] 之间统计 UNIQ(S[i])；最终问题就变成了计算在 S[j+1:k] 之间，包含 S[i] 的子串有多少种可能，因为每个子串中 S[i] 都会是独特字符；在 S[j+1:k] 之间，包含 S[i] 的子串的数量其实就等于 (i - j) * (k - i)；S[j+1:i+1], S[j+1:i+2], ..., S[j+1:k]，S[j+2:i+1], S[j+2:i+2], ...., S[j+1:k]，….，S[i:i+1], S[i:i+2], ...., S[i:k] 示例代码(go)123456789101112131415161718func uniqueLetterString(S string) int &#123; res, n := 0, len(S) for i := 0; i &lt; n; i++ &#123; j, k := 0, 0 for j = i-1; j &gt;= 0; j-- &#123; if S[j] == S[i] &#123; break &#125; &#125; for k = i+1; k &lt; n; k++ &#123; if S[k] == S[i] &#123; break &#125; &#125; res += (i - j) * (k - i) &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 140. 单词拆分 II]]></title>
    <url>%2Fleetcode-140.html</url>
    <content type="text"><![CDATA[题目描述给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。 说明： 分隔时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 示例 1： 输入: s = "catsanddog" wordDict = ["cat", "cats", "and", "sand", "dog"] 输出: [ "cats and dog", "cat sand dog" ] 示例 2： 输入: s = "pineapplepenapple" wordDict = ["apple", "pen", "applepen", "pine", "pineapple"] 输出: [ "pine apple pen apple", "pineapple pen apple", "pine applepen apple" ] 解释: 注意你可以重复使用字典中的单词。 示例 3： 输入: s = "catsandog" wordDict = ["cats", "dog", "sand", "and", "cat"] 输出: [] 题解记忆化回溯，hash[s] 保存相应字符串 s 对应的单词组合 示例代码(go)12345678910111213141516171819202122232425262728293031323334func wordBreak(s string, wordDict []string) []string &#123; hash := make(map[string][]string) wordHash := make(map[string]bool) for _, word := range wordDict &#123; wordHash[word] = true &#125; return dfs(s, wordDict, hash, wordHash)&#125;func dfs(s string, wordDict []string, hash map[string][]string, wordHash map[string]bool) []string &#123; if _, ok := hash[s]; ok &#123; return hash[s] &#125; res := make([]string, 0) n := len(s) if n == 0 &#123; res = append(res, "") return res &#125; for i := 0; i &lt; n; i++ &#123; if wordHash[s[:i+1]] &#123; sublist := dfs(s[i+1:], wordDict, hash, wordHash) for _, sub := range sublist &#123; space := " " if sub == "" &#123; space = "" &#125; res = append(res, s[:i+1]+space+sub) &#125; &#125; &#125; hash[s] = res return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 4. 寻找两个有序数组的中位数]]></title>
    <url>%2Fleetcode-4.html</url>
    <content type="text"><![CDATA[题目描述给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。 示例 1:nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例 2:nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 题解通过 i 划分 nums1 为左右两部分 nums1[0], nums1[1], ..., nums1[i-1] 和 nums1[i], nums1[i+1], ..., nums1[m-1]通过 j 划分 nums2 为左右两部分 nums2[0], nums2[1], ..., nums2[j-1] 和 nums2[j], nums2[j+1], ..., nums2[n-1]如果 i, j 取值满足条件 i + j = m - i + n - j 和 nums1[i-1] &lt; nums2[j], nums2[j-1] &lt; nums1[i]（说明划分出了长度相等的左右两部分，并且左边的值都小于右边的值）两个有序数组的中位数 (max(nums1[i-1], nums2[j-1]) + min(nums1[i], nums2[j])) / 2 示例代码(go)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func findMedianSortedArrays(nums1 []int, nums2 []int) float64 &#123; m, n := len(nums1), len(nums2) if m &gt; n &#123; nums1, nums2 = nums2, nums1 m, n = n, m &#125; left, right, half := 0, m, (m + n + 1) / 2 for left &lt;= right &#123; i := (left + right) / 2 j := half - i if i &lt; right &amp;&amp; nums1[i] &lt; nums2[j-1] &#123; left = i + 1 &#125; else if i &gt; left &amp;&amp; nums1[i-1] &gt; nums2[j] &#123; right = i - 1 &#125; else &#123; maxLeft, minRight := 0, 0 if i == 0 &#123; maxLeft = nums2[j-1] &#125; else if j == 0 &#123; maxLeft = nums1[i-1] &#125; else &#123; maxLeft = max(nums1[i-1], nums2[j-1]) &#125; if (m + n) % 2 == 1 &#123; return float64(maxLeft) &#125; if i == m &#123; minRight = nums2[j] &#125; else if j == n &#123; minRight = nums1[i] &#125; else &#123; minRight = min(nums1[i], nums2[j]) &#125; return float64(maxLeft + minRight) / 2 &#125; &#125; return 0.0&#125;func min(a, b int) int &#123; if a &lt; b &#123; return a &#125; return b&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 315. 计算右侧小于当前元素的个数]]></title>
    <url>%2Fleetcode-315.html</url>
    <content type="text"><![CDATA[题目描述给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。 示例:输入: [5,2,6,1]输出: [2,1,1,0]解释:5 的右侧有 2 个更小的元素 (2 和 1).2 的右侧仅有 1 个更小的元素 (1).6 的右侧有 1 个更小的元素 (1).1 的右侧有 0 个更小的元素. 题解从后往前遍历 nums，构建二叉搜索树，每个节点要记录其左子树节点的个数 Count 示例代码(go)1234567891011121314151617181920212223242526272829type Node struct &#123; Left *Node Right *Node Val int Count int&#125;func countSmaller(nums []int) []int &#123; var root *Node n := len(nums) res := make([]int, n) for i := n-1; i &gt;= 0; i-- &#123; root = insert(root, nums[i], i, res) &#125; return res&#125;func insert(root *Node, val, index int, res []int) *Node &#123; if root == nil &#123; root = &amp;Node&#123;nil, nil, val, 0&#125; &#125; else if val &lt;= root.Val &#123; root.Count++ root.Left = insert(root.Left, val, index, res) &#125; else &#123; res[index] += root.Count + 1 root.Right = insert(root.Right, val, index, res) &#125; return root&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 72. 编辑距离]]></title>
    <url>%2Fleetcode-72.html</url>
    <content type="text"><![CDATA[题目描述给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1:输入: word1 = “horse”, word2 = “ros”输出: 3解释:horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)rorse -&gt; rose (删除 ‘r’)rose -&gt; ros (删除 ‘e’) 示例 2:输入: word1 = “intention”, word2 = “execution”输出: 5解释:intention -&gt; inention (删除 ‘t’)inention -&gt; enention (将 ‘i’ 替换为 ‘e’)enention -&gt; exention (将 ‘n’ 替换为 ‘x’)exention -&gt; exection (将 ‘n’ 替换为 ‘c’)exection -&gt; execution (插入 ‘u’) 题解动态规划，dp[i][j] 表示 word1 的前 i 个字母和 word2 的前 j 个字母之间的编辑距离，dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])，特许情况当 word1[i] == word2[j] 时，dp[i][j] = dp[i-1][j-1] 不需要额外操作 示例代码(go)123456789101112131415161718192021222324252627282930func minDistance(word1 string, word2 string) int &#123; m, n := len(word1), len(word2) dp := make([][]int, m+1) for i := 0; i &lt;= m; i++ &#123; dp[i] = make([]int, n+1) &#125; for i := 0; i &lt;= m; i++ &#123; dp[i][0] = i &#125; for i := 0; i &lt;= n; i++ &#123; dp[0][i] = i &#125; for i := 1; i &lt;= m; i++ &#123; for j := 1; j &lt;= n; j++ &#123; if word1[i-1] == word2[j-1] &#123; dp[i][j] = dp[i-1][j-1] &#125; else &#123; dp[i][j] = 1 + min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) &#125; &#125; &#125; return dp[m][n]&#125;func min(a, b int) int &#123; if a &lt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 134. 加油站]]></title>
    <url>%2Fleetcode-134.html</url>
    <content type="text"><![CDATA[题目描述在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。 说明: 如果题目有解，该答案即为唯一答案。 输入数组均为非空数组，且长度相同。 输入数组中的元素均为非负数。 示例 1:输入:gas = [1,2,3,4,5]cost = [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。 示例 2:输入:gas = [2,3,4]cost = [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。 题解找到 gas[i] &gt;= cost[i] 作为起点， 判断是否可以行驶一周 示例代码(go)12345678910111213141516171819202122232425func canCompleteCircuit(gas []int, cost []int) int &#123; n := len(gas) for i := 0; i &lt; n; i++ &#123; if gas[i] &gt;= cost[i] &amp;&amp; canComplete(gas, cost, i) &#123; return i &#125; &#125; return -1&#125;func canComplete(gas []int, cost []int, i int) bool &#123; n := len(gas) pre := gas[i] - cost[i] for j := 1; j &lt;= n; j++ &#123; k := (i+j) % n if k == i &#123; return true &#125; pre += gas[k] - cost[k] if pre &lt; 0 &#123; break &#125; &#125; return false&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 165. 比较版本号]]></title>
    <url>%2Fleetcode-165.html</url>
    <content type="text"><![CDATA[题目描述比较两个版本号 version1 和 version2。如果 version1 &gt; version2 返回 1，如果 version1 &lt; version2 返回 -1， 除此之外返回 0。你可以假设版本字符串非空，并且只包含数字和 . 字符。 . 字符不代表小数点，而是用于分隔数字序列。例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。 示例 1:输入: version1 = “0.1”, version2 = “1.1”输出: -1 示例 2:输入: version1 = “1.0.1”, version2 = “1”输出: 1 示例 3:输入: version1 = “7.5.2.4”, version2 = “7.5.3”输出: -1 示例 4：输入：version1 = “1.01”, version2 = “1.001”输出：0解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。 示例 5：输入：version1 = “1.0”, version2 = “1.0.0”输出：0解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。 提示：版本字符串由以点 （.） 分隔的数字字符串组成。这个数字字符串可能有前导零。版本字符串不以点开始或结束，并且其中不会有两个连续的点。 题解首先根据 “.” 分割成数组，然后依次比较每一项的值（可以先转为整数再比较，方便一点） 示例代码(go)123456789101112131415161718192021222324252627282930313233func compareVersion(version1 string, version2 string) int &#123; arr1 := strings.Split(version1, ".") arr2 := strings.Split(version2, ".") m, n := len(arr1), len(arr2) for i, j := 0, 0 ;i &lt; m || j &lt; n; &#123; if i &lt; m &amp;&amp; j &lt; n &#123; num1, _ := strconv.Atoi(arr1[i]) num2, _ := strconv.Atoi(arr2[j]) if num1 &gt; num2 &#123; return 1 &#125; if num1 &lt; num2 &#123; return -1 &#125; i++ j++ &#125; else if i == m &amp;&amp; j &lt; n &#123; num2, _ := strconv.Atoi(arr2[j]) if 0 &lt; num2 &#123; return -1 &#125; j++ &#125; else if i &lt; m &amp;&amp; j == n &#123; num1, _ := strconv.Atoi(arr1[i]) if num1 &gt; 0 &#123; return 1 &#125; i++ &#125; &#125; return 0&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 556. 下一个更大元素 III]]></title>
    <url>%2Fleetcode-556.html</url>
    <content type="text"><![CDATA[题目描述给定一个32位正整数 n，你需要找到最小的32位整数，其与 n 中存在的位数完全相同，并且其值大于n。如果不存在这样的32位整数，则返回-1。 示例 1:输入: 12输出: 21 示例 2:输入: 21输出: -1 题解n 转为字节数组 b，首先从右到左找到 b[i-1] &lt; b[i] 表明有更大的值大于 n（但不一定是最小的），然后在 b[i:] 里找到大于 b[i-1] 的最小值 b[j]，接着交换 b[i-1], b[j]，反转 b[i:] 按升序排列 示例代码(go)1234567891011121314151617181920212223242526272829func nextGreaterElement(n int) int &#123; b := []byte(strconv.Itoa(n)) for i := len(b)-1; i &gt; 0; i-- &#123; if b[i-1] &lt; b[i] &#123; for j := len(b)-1; j &gt;= i; j-- &#123; if b[j] &gt; b[i-1] &#123; b[j], b[i-1] = b[i-1], b[j] reverse(b, i) break &#125; &#125; break &#125; &#125; res, _ := strconv.Atoi(string(b)) if res == n || res &gt; math.MaxInt32 &#123; return -1 &#125; return res&#125;func reverse(b []byte, i int) &#123; l, r := i, len(b)-1 for l &lt; r &#123; b[l], b[r] = b[r], b[l] l++ r-- &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 131. 分割回文串]]></title>
    <url>%2Fleetcode-131.html</url>
    <content type="text"><![CDATA[题目描述给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。 示例: 输入: "aab" 输出: [ ["aa","b"], ["a","a","b"] ] 题解递归回溯，如果字符串的 s[:i] 子串回文，则对剩下的 s[i:] 子串进行递归 示例代码(go)12345678910111213141516171819202122232425262728293031var res [][]stringfunc partition(s string) [][]string &#123; res = [][]string&#123;&#125; dfs(s, []string&#123;&#125;) return res&#125;func dfs(s string, arr []string) &#123; if s == "" &#123; tmp := make([]string, 0) tmp = append(tmp, arr...) res = append(res, tmp) return &#125; n := len(s) for i := 1; i &lt;= n; i++ &#123; if isPalindrome(s[:i]) &#123; dfs(s[i:], append(arr, string(s[:i]))) &#125; &#125;&#125;func isPalindrome(s string) bool &#123; n := len(s) for i := 0; i &lt; n/2; i++ &#123; if s[i] != s[n-i-1] &#123; return false &#125; &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 41. 缺失的第一个正数]]></title>
    <url>%2Fleetcode-41.html</url>
    <content type="text"><![CDATA[题目描述给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 示例 1:输入: [1,2,0]输出: 3 示例 2:输入: [3,4,-1,1]输出: 2 示例 3:输入: [7,8,9,11,12]输出: 1 说明:你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。 题解缺失的第一个正数不会大于 n+1；首先将小于 1 的值置为 n+1，然后数组的值作为下标，把相对应的位置 nums[v-1] 变为负数，最后遍历数组判断是否有正数 示例代码(go)123456789101112131415161718192021222324252627func firstMissingPositive(nums []int) int &#123; n := len(nums) for i, v := range nums &#123; if v &lt; 1 &#123; nums[i] = n+1 &#125; &#125; for _, v := range nums &#123; v1 := abs(v) if v1 &gt; 0 &amp;&amp; v1 &lt;= n &#123; nums[v1-1] = -abs(nums[v1-1]) &#125; &#125; for i, v := range nums &#123; if v &gt; 0 &#123; return i+1 &#125; &#125; return n+1&#125;func abs(a int) int &#123; if a &lt; 0 &#123; return -a &#125; return a&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 3. 无重复字符的最长子串]]></title>
    <url>%2Fleetcode-3.html</url>
    <content type="text"><![CDATA[题目描述给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1:输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 示例 2:输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。 示例 3:输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 题解通过哈希表保存重复字符上一次出现的位置，然后从重复字符的后一个字符作为新的开始，重新计算最长子串的长度 示例代码(go)1234567891011121314151617181920func lengthOfLongestSubstring(s string) int &#123; hash := make(map[byte]int) n := len(s) res, start := 0, 0 for i := 0; i &lt; n; i++ &#123; if last, ok := hash[s[i]]; ok &amp;&amp; last &gt;= start &#123; start = last+1 &#125; hash[s[i]] = i res = max(res, i-start+1) &#125; return res&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 146. LRU缓存机制]]></title>
    <url>%2Fleetcode-146.html</url>
    <content type="text"><![CDATA[题目描述运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。 进阶:你是否可以在 O(1) 时间复杂度内完成这两种操作？ 示例:LRUCache cache = new LRUCache( 2 / 缓存容量 / ); cache.put(1, 1);cache.put(2, 2);cache.get(1); // 返回 1cache.put(3, 3); // 该操作会使得密钥 2 作废cache.get(2); // 返回 -1 (未找到)cache.put(4, 4); // 该操作会使得密钥 1 作废cache.get(1); // 返回 -1 (未找到)cache.get(3); // 返回 3cache.get(4); // 返回 4 题解主要需要解决的问题就是如何在 O(1) 时间之内找出最近最少使用的值，所以使用了双链表，head 指向双链表的头，tail 指向尾，每次进行 Get, Put 操作时，就把 key 所对应的值 node 移到链表头，tail 所指向的尾部就是最近最少使用的值 示例代码(go)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960type Node struct &#123; key int value int pre *Node next *Node&#125;type LRUCache struct &#123; capacity int hash map[int]*Node head *Node tail *Node&#125;func Constructor(capacity int) LRUCache &#123; cache := LRUCache&#123;capacity: capacity, hash: make(map[int]*Node)&#125; cache.head = &amp;Node&#123;&#125; cache.tail = &amp;Node&#123;&#125; cache.head.next = cache.tail cache.tail.pre = cache.head return cache&#125;func (this *LRUCache) Get(key int) int &#123; node, ok := this.hash[key] if !ok &#123; return -1 &#125; this.remove(node) this.setHead(node) return node.value&#125;func (this *LRUCache) Put(key int, value int) &#123; if node, ok := this.hash[key]; ok &#123; node.value = value this.remove(node) this.setHead(node) &#125; else &#123; if len(this.hash) &gt;= this.capacity &#123; delete(this.hash, this.tail.pre.key) this.remove(this.tail.pre) &#125; this.hash[key] = &amp;Node&#123;key: key, value: value&#125; this.setHead(this.hash[key]) &#125;&#125;func (this *LRUCache) setHead(node *Node) &#123; headNext := this.head.next this.head.next = node node.pre = this.head node.next = headNext headNext.pre = node&#125;func (this *LRUCache) remove(node *Node) &#123; node.pre.next = node.next node.next.pre = node.pre&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 179. 最大数]]></title>
    <url>%2Fleetcode-179.html</url>
    <content type="text"><![CDATA[题目描述给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。 示例 1:输入: [10,2]输出: 210 示例 2:输入: [3,30,34,5,9]输出: 9534330 说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数。 题解自定义排序方式，比较 arr[i]+arr[j], arr[j]+arr[i] 两种相连方式，例如比较 “34” 和 “341” 时，可以转换为比较 “34341” 和 “34134”，可以看出 “34” 要排在 “341” 前面 示例代码(go)1234567891011121314func largestNumber(nums []int) string &#123; arr := make([]string, 0) for _, v := range nums &#123; arr = append(arr, strconv.Itoa(v)) &#125; sort.Slice(arr, func (i, j int) bool &#123; return arr[i]+arr[j] &gt; arr[j]+arr[i] &#125;) res := strings.Join(arr, "") if len(res) &gt; 0 &amp;&amp; res[0] == '0' &#123; return "0" &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 93. 复原IP地址]]></title>
    <url>%2Fleetcode-93.html</url>
    <content type="text"><![CDATA[题目描述给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 示例:输入: “25525511135”输出: [“255.255.11.135”, “255.255.111.35”] 题解dfs 深度优先搜索，每次取 1~3 位为一个 ip 地址段，然后对剩下的字符串进行递归（注意地址段是否合法） 示例代码(go)12345678910111213141516171819202122232425262728293031323334353637func restoreIpAddresses(s string) []string &#123; res := make([]string, 0) dfs(s, []string&#123;&#125;, &amp;res) return res&#125;func dfs(s string, arr []string, res *[]string) &#123; n := len(s) if s != "" &amp;&amp; len(arr) == 4 &#123; return &#125; if s == "" &amp;&amp; len(arr) == 4 &#123; *res = append(*res, strings.Join(arr, ".")) return &#125; for i := 0; i &lt; 3 &amp;&amp; i &lt; n; i++ &#123; if isLess(s[:i+1], "255") &amp;&amp; isLegal(s[:i+1]) &#123; dfs(s[i+1:], append(arr, s[:i+1]), res) &#125; &#125;&#125;func isLess(a, b string) bool &#123; a1, _ := strconv.Atoi(a) b1, _ := strconv.Atoi(b) if a1 &lt;= b1 &#123; return true &#125; return false&#125;func isLegal(str string) bool &#123; if str[0] == '0' &amp;&amp; len(str) &gt; 1 &#123; return false &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 130. 被围绕的区域]]></title>
    <url>%2Fleetcode-130.html</url>
    <content type="text"><![CDATA[题目描述给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。 示例: X X X XX O O XX X O XX O X X运行你的函数后，矩阵变为： X X X XX X X XX X X XX O X X解释:被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 题解bfs 广度优先搜索，首先把边界上出现的 O 以及相连的 O 置为 S，然后遍历二维矩阵 board， O 置为 X, S 置为 O 示例代码(go)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051func solve(board [][]byte) &#123; m, n := len(board), 0 if m &gt; 0 &#123; n = len(board[0]) &#125; for j := 0; j &lt; n; j++ &#123; if board[0][j] == 'O' &#123; bfs(board, m, n, 0, j) &#125; &#125; for i := 1; i &lt; m-1; i++ &#123; if board[i][0] == 'O' &#123; bfs(board, m, n, i, 0) &#125; if board[i][n-1] == 'O' &#123; bfs(board, m, n, i, n-1) &#125; &#125; for j := 0; j &lt; n; j++ &#123; if board[m-1][j] == 'O' &#123; bfs(board, m, n, m-1, j) &#125; &#125; for i := 0; i &lt; m; i++ &#123; for j := 0; j &lt; n; j++ &#123; if board[i][j] == 'S' &#123; board[i][j] = 'O' &#125; else if board[i][j] == 'O' &#123; board[i][j] = 'X' &#125; &#125; &#125;&#125;func bfs(board [][]byte, m, n, i, j int) &#123; if board[i][j] == 'O' &#123; board[i][j] = 'S' &#125; if i-1 &gt;= 0 &amp;&amp; board[i-1][j] == 'O' &#123; bfs(board, m, n, i-1, j) &#125; if i+1 &lt; m &amp;&amp; board[i+1][j] == 'O' &#123; bfs(board, m, n, i+1, j) &#125; if j-1 &gt;= 0 &amp;&amp; board[i][j-1] == 'O' &#123; bfs(board, m, n, i, j-1) &#125; if j+1 &lt; n &amp;&amp; board[i][j+1] == 'O' &#123; bfs(board, m, n, i, j+1) &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 127. 单词接龙]]></title>
    <url>%2Fleetcode-127.html</url>
    <content type="text"><![CDATA[题目描述给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则： 每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。 说明: 如果不存在这样的转换序列，返回 0。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。 示例 1:输入:beginWord = “hit”,endWord = “cog”,wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]输出: 5解释: 一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”, 返回它的长度 5。 示例 2:输入:beginWord = “hit”endWord = “cog”wordList = [“hot”,”dot”,”dog”,”lot”,”log”]输出: 0解释: endWord “cog” 不在字典中，所以无法进行转换。 题解bfs 思想，根据前面已经入队 queue 的单词 beginWord，然后把可以转换的单词 word 加入队列 示例代码(go)12345678910111213141516171819202122232425262728293031323334func ladderLength(beginWord string, endWord string, wordList []string) int &#123; res := 0 visited := make(map[int]bool) queue := make([]string, 0) queue = append(queue, beginWord) for len(queue) &gt; 0 &#123; res++ n := len(queue) for i := 0; i &lt; n; i++ &#123; beginWord := queue[0] queue = queue[1:] for j, word := range wordList &#123; if !visited[j] &amp;&amp; canTransform(beginWord, word) &#123; if word == endWord &#123; return res + 1 &#125; visited[j] = true queue = append(queue, word) &#125; &#125; &#125; &#125; return 0&#125;func canTransform(beginWord string, endWord string) bool &#123; n := len(beginWord) for i := 0; i &lt; n; i++ &#123; if beginWord[:i] + beginWord[i+1:] == endWord[:i] + endWord[i+1:] &#123; return true &#125; &#125; return false&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 227. 基本计算器 II]]></title>
    <url>%2Fleetcode-227.html</url>
    <content type="text"><![CDATA[题目描述实现一个基本的计算器来计算一个简单的字符串表达式的值。字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格 。 整数除法仅保留整数部分。 示例 1:输入: “3+2*2”输出: 7 示例 2:输入: “ 3/2 “输出: 1 示例 3:输入: “ 3+5 / 2 “输出: 5 题解遍历字符串 s ，取出数值 num 存入 stack 栈中，主要是通过前边的操作符 op 判断如何存入数值，+, - 则直接存 num 的值或者取反后再存入，*, / 的话则要计算之后再存入，最后把 stack 栈中的数值相加起来 示例代码(go)12345678910111213141516171819202122232425262728293031323334353637func calculate(s string) int &#123; stack := make([]int, 0) res := 0 n := len(s) var op byte op = '+' num := 0 for i := 0; i &lt; n; i++ &#123; if s[i] &gt;= '0' &#123; num = num * 10 + int(s[i] - '0') &#125; if (s[i] &lt; '0' &amp;&amp; s[i] != ' ') || i == n-1 &#123; if op == '+' &#123; stack = append(stack, num) &#125; if op == '-' &#123; stack = append(stack, -num) &#125; if op == '*' &#123; tmp := stack[len(stack)-1] * num stack = stack[:len(stack)-1] stack = append(stack, tmp) &#125; if op == '/' &#123; tmp := stack[len(stack)-1] / num stack = stack[:len(stack)-1] stack = append(stack, tmp) &#125; num = 0 op = s[i] &#125; &#125; for _, v := range stack &#123; res += v &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 454. 四数相加 II]]></title>
    <url>%2Fleetcode-454.html</url>
    <content type="text"><![CDATA[题目描述给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。 例如:输入:A = [ 1, 2]B = [-2,-1]C = [-1, 2]D = [ 0, 2]输出:2解释:两个元组如下: (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 题解首先遍历 A 和 B 元素和的组合情况，并记录在 hash 中，然后遍历 C 和 D 元素和的组合情况，判断取反后的值是否在 hash 表中 示例代码(go)1234567891011121314151617func fourSumCount(A []int, B []int, C []int, D []int) int &#123; res := 0 hash := make(map[int]int) for _, a := range A &#123; for _, b := range B &#123; hash[a+b]++ &#125; &#125; for _, c := range C &#123; for _, d := range D &#123; if v, ok := hash[-c-d]; ok &#123; res += v &#125; &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 221. 最大正方形]]></title>
    <url>%2Fleetcode-221.html</url>
    <content type="text"><![CDATA[题目描述在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例: 输入:1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4 题解动态规划，dp[i][j] 表示正方形的边长（其中i, j代表正方形的右下角）, 地推公式：dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) 示例代码(go)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var area intfunc maximalSquare(matrix [][]byte) int &#123; area = 0 m := len(matrix) if m == 0 &#123; return area &#125; n := len(matrix[0]) dp := make([][]int, m) for i := 0; i &lt; m ; i++ &#123; dp[i] = make([]int, n) &#125; for i := 0; i &lt; m; i++ &#123; for j := 0; j &lt; n; j++ &#123; if matrix[i][j] == '1' &#123; computeSquare(dp, i, j) &#125; &#125; &#125; return area&#125;func computeSquare(dp [][]int, i, j int) &#123; dp[i][j] = 1 area = max(area, dp[i][j]) if i-1 &lt; 0 &#123; return &#125; if j-1 &lt; 0 &#123; return &#125; dp[i][j] += min(min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) area = max(area, dp[i][j]*dp[i][j])&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;func min(a, b int) int &#123; if a &lt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 399. 除法求值]]></title>
    <url>%2Fleetcode-399.html</url>
    <content type="text"><![CDATA[题目描述给出方程式 A / B = k, 其中 A 和 B 均为代表字符串的变量， k 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 -1.0。 示例 :给定 a / b = 2.0, b / c = 3.0问题: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?返回 [6.0, 0.5, -1.0, 1.0, -1.0 ] 输入为: vector&lt;pair&lt;string, string&gt;&gt; equations, vector&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries(方程式，方程式结果，问题方程式)， 其中 equations.size() == values.size()，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。 返回vector类型。 基于上述例子，输入如下：equations(方程式) = [ [“a”, “b”], [“b”, “c”] ],values(方程式结果) = [2.0, 3.0],queries(问题方程式) = [ [“a”, “c”], [“b”, “a”], [“a”, “e”], [“a”, “a”], [“x”, “x”] ].输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。 题解dfs深度搜索思想，首先遍历 queries 找出被除数 a，除数 b，然后根据 equations 找出 a / b 的值 示例代码(go)1234567891011121314151617181920212223242526272829303132333435363738394041func calcEquation(equations [][]string, values []float64, queries [][]string) []float64 &#123; n := len(queries) res := make([]float64, n) visited := make(map[int]bool) for i := 0; i &lt; n; i++ &#123; res[i] = calc(equations, values, visited, queries[i][0], queries[i][1], 1.0) &#125; return res&#125;func calc(equations [][]string, values []float64, visited map[int]bool, a, b string, answer float64) float64 &#123; for i, v := range equations &#123; if visited[i] &#123; continue &#125; if v[0] == a &amp;&amp; a == b || v[1] == a &amp;&amp; a == b &#123; return 1.0 &#125; else if v[0] == a &#123; if v[1] == b &#123; return answer * values[i] &#125; visited[i] = true k := calc(equations, values, visited, v[1], b, answer * values[i]) visited[i] = false if k != -1.0 &#123; return k &#125; &#125; else if v[1] == a &amp;&amp; values[i] != 0.0 &#123; if v[0] == b &#123; return answer / values[i] &#125; visited[i] = true k := calc(equations, values, visited, v[0], b, answer / values[i]) visited[i] = false if k != -1.0 &#123; return k &#125; &#125; &#125; return -1.0&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 538. 把二叉搜索树转换为累加树]]></title>
    <url>%2Fleetcode-538.html</url>
    <content type="text"><![CDATA[题目描述给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。 例如： 输入: 二叉搜索树: 5 / \ 2 13 输出: 转换为累加树: 18 / \ 20 13 题解根据二叉搜索树的特点，左子树节点的值小于根节点的值，根节点的值小于右子树节点的值，可以按照右-根-左的顺序遍历二叉树，将遍历顺序的结点的值累加起来，和当前结点的值相加 示例代码(go)123456789101112131415161718192021222324/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */var pre intfunc convertBST(root *TreeNode) *TreeNode &#123; pre = 0 inorder(root) return root&#125;func inorder(root *TreeNode) &#123; if root == nil &#123; return &#125; inorder(root.Right) root.Val += pre pre = root.Val inorder(root.Left)&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 763. 划分字母区间]]></title>
    <url>%2Fleetcode-763.html</url>
    <content type="text"><![CDATA[题目描述字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。 示例 1:输入: S = “ababcbacadefegdehijhklij”输出: [9,7,8]解释:划分结果为 “ababcbaca”, “defegde”, “hijhklij”。每个字母最多出现在一个片段中。像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。 注意: S的长度在[1, 500]之间。 S只包含小写字母’a’到’z’。 题解首先遍历字符串找到每个字母出现的最后位置，然后判断相同字母所代表区间中的每个字母，看下字母的最后位置是否超出原区间，超出则更新区间 示例代码(go)1234567891011121314151617181920212223func partitionLabels(S string) []int &#123; res := make([]int, 0) hash := make(map[byte]int) n := len(S) for i := 0; i &lt; n; i++ &#123; hash[S[i]] = i &#125; i := 0 for i &lt; n &#123; m := hash[S[i]] j := i + 1 for j &lt;= m &#123; if hash[S[j]] &gt; m &#123; m = hash[S[j]] &#125; j++ &#125; res = append(res, j-i) i = j &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 98. 验证二叉搜索树]]></title>
    <url>%2Fleetcode-98.html</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 输入: 2 / \ 1 3 输出: true 示例 2: 输入: 5 / \ 1 4 / \ 3 6 输出: false 解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 题解暴力递归，直接判断是否符合二叉搜索树的标准，左子树上所有结点的值均小于它的根结点的值，右子树上所有结点的值均大于它的根结点的值 示例代码(go)12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func isValidBST(root *TreeNode) bool &#123; if root == nil &#123; return true &#125; if !isValidLeft(root.Left, root.Val) &#123; return false &#125; if !isValidRight(root.Right, root.Val) &#123; return false &#125; return isValidBST(root.Left) &amp;&amp; isValidBST(root.Right)&#125;func isValidLeft(root *TreeNode, val int) bool &#123; if root == nil &#123; return true &#125; if root.Val &gt;= val &#123; return false &#125; return isValidLeft(root.Left, val) &amp;&amp; isValidLeft(root.Right, val)&#125;func isValidRight(root *TreeNode, val int) bool &#123; if root == nil &#123; return true &#125; if root.Val &lt;= val &#123; return false &#125; return isValidRight(root.Left, val) &amp;&amp; isValidRight(root.Right, val)&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 309. 最佳买卖股票时机含冷冻期]]></title>
    <url>%2Fleetcode-309.html</url>
    <content type="text"><![CDATA[题目描述给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例:输入: [1,2,3,0,2]输出: 3解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 题解dp[i][0]表示i天买入的收益，dp[i][1]表示i天卖出的收益，dp[i][2]表示i天冷冻的收益，因为卖出之后的冷冻期为1天，所以买入的前一天一定处于冷冻期 示例代码(go)1234567891011121314151617181920212223242526func maxProfit(prices []int) int &#123; n := len(prices) if n == 0 &#123; return 0 &#125; dp := make([][]int, n) for i := 0; i &lt; n; i++ &#123; dp[i] = append(dp[i], []int&#123;0, 0, 0&#125;...) &#125; dp[0][0] = -prices[0] dp[0][1] = 0 dp[0][2] = 0 for i := 1; i &lt; n; i++ &#123; dp[i][0] = max(dp[i-1][0], dp[i-1][2] - prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]) dp[i][2] = max(dp[i-1][1], dp[i-1][2]) &#125; return dp[n-1][1]&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 56. 合并区间]]></title>
    <url>%2Fleetcode-56.html</url>
    <content type="text"><![CDATA[题目描述给出一个区间的集合，请合并所有重叠的区间。 示例 1:输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]。 示例 2:输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 题解首先按照开始区间进行升序排序，然后遍历数组，得到最大的重叠区间 示例代码(go)1234567891011121314151617181920func merge(intervals [][]int) [][]int &#123; n := len(intervals) if n == 0 &#123; return intervals &#125; sort.Slice(intervals, func(i, j int) bool &#123; return intervals[i][0] &lt; intervals[j][0] &#125;) s, e := intervals[0][0], intervals[0][1] for i := 1; i &lt; n; i++ &#123; if intervals[i][0] &lt;= e &amp;&amp; intervals[i][1] &gt; e &#123; e = intervals[i][1] &#125; else if intervals[i][0] &gt; e &#123; intervals = append(intervals, []int&#123;s, e&#125;) s, e = intervals[i][0], intervals[i][1] &#125; &#125; intervals = append(intervals, []int&#123;s, e&#125;) return intervals[n:]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 152. 乘积最大子序列]]></title>
    <url>%2Fleetcode-152.html</url>
    <content type="text"><![CDATA[题目描述给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 示例 1:输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例 2:输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 题解a, b表示后续相乘可以用到的最大最小值 示例代码(go)1234567891011121314151617181920212223242526272829303132333435363738func maxProduct(nums []int) int &#123; a, b := 1, 1 res := math.MinInt32 for _, v1 := range nums &#123; v2 := a * v1 v3 := b * v1 res = max(res, v2) res = max(res, v3) if v2 &gt; 0 &amp;&amp; v3 &gt; 0 &#123; a = max(v2, v3) b = 1 &#125; else if v2 == 0 &amp;&amp; v3 == 0 &#123; a = 1 b = 1 &#125; else if v2 &lt; 0 &amp;&amp; v3 &lt; 0 &#123; a = min(v2, v3) b = 1 &#125; else &#123; a = v2 b = v3 &#125; &#125; return res&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;func min(a, b int) int &#123; if a &lt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 322. 零钱兑换]]></title>
    <url>%2Fleetcode-322.html</url>
    <content type="text"><![CDATA[题目描述给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1:输入: coins = [1, 2, 5], amount = 11输出: 3解释: 11 = 5 + 5 + 1 示例 2:输入: coins = [2], amount = 3输出: -1 说明:你可以认为每种硬币的数量是无限的。 题解动态规划，dp[n] = min(dp[n], dp[n-v]+1)，其中n代表总金额， v代表不同的硬币 示例代码(go)123456789101112131415161718func coinChange(coins []int, amount int) int &#123; dp := make([]int, amount+1) for n := 1; n &lt;= amount; n++ &#123; for _, v := range coins &#123; if n &gt;= v &amp;&amp; dp[n-v] != -1 &#123; if dp[n] == 0 &#123; dp[n] = dp[n-v] + 1 &#125; else if dp[n] &gt; dp[n-v] + 1 &#123; dp[n] = dp[n-v] + 1 &#125; &#125; &#125; if dp[n] == 0 &#123; dp[n] = -1 &#125; &#125; return dp[amount]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 55. 跳跃游戏]]></title>
    <url>%2Fleetcode-55.html</url>
    <content type="text"><![CDATA[题目描述给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。 示例 1:输入: [2,3,1,1,4]输出: true解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。 示例 2:输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 题解从后往前遍历，如果某个点的右边可以跳到最后，则该点只要能跳一步就可以，否则就要多跳一步 示例代码(go)123456789101112func canJump(nums []int) bool &#123; n := len(nums) c := 1 for i := n-2; i &gt;= 0; i-- &#123; if nums[i] &gt;= c &#123; c = 1 &#125; else &#123; c++ &#125; &#125; return c == 1&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 19. 删除链表的倒数第N个节点]]></title>
    <url>%2Fleetcode-19.html</url>
    <content type="text"><![CDATA[题目描述给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例：给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明：给定的 n 保证是有效的。 题解两次遍历，第一次算出链表的长度，第二次从前往后删除指定节点 示例代码(go)123456789101112131415161718192021222324/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func removeNthFromEnd(head *ListNode, n int) *ListNode &#123; node := head m := 0 for head != nil &#123; m++ head = head.Next &#125; head = node if m == n &#123; return head.Next &#125; for i := 0; i &lt; m-n-1; i++ &#123; node = node.Next &#125; node.Next = node.Next.Next return head&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 34. 在排序数组中查找元素的第一个和最后一个位置]]></title>
    <url>%2Fleetcode-34.html</url>
    <content type="text"><![CDATA[题目描述给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。你的算法时间复杂度必须是 O(log n) 级别。如果数组中不存在目标值，返回 [-1, -1]。 示例 1:输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4] 示例 2:输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1] 题解分别进行两次二分查找，找出最左边和最右边的位置 示例代码(go)123456789101112131415161718192021222324252627func searchRange(nums []int, target int) []int &#123; left, right := -1, -1 n := len(nums) for i, j := 0, n-1; i &lt;= j; &#123; mid := (i + j) / 2 if nums[mid] &gt; target &#123; j = mid - 1 &#125; else if nums[mid] &lt; target &#123; i = mid + 1 &#125; else &#123; left = mid j = mid - 1 &#125; &#125; for i, j := 0, n-1; i &lt;= j; &#123; mid := (i + j) / 2 if nums[mid] &gt; target &#123; j = mid - 1 &#125; else if nums[mid] &lt; target &#123; i = mid + 1 &#125; else &#123; right = mid i = mid + 1 &#125; &#125; return []int&#123;left, right&#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 31. 下一个排列]]></title>
    <url>%2Fleetcode-31.html</url>
    <content type="text"><![CDATA[题目描述实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 题解从后往前遍历数组，找出比当前值nums[i]大的最小值所在的位置k，然后交换nums[i]，nums[k]，并把i之后的数进行升序排序 示例代码(go)1234567891011121314151617181920func nextPermutation(nums []int) &#123; n := len(nums) min, k := math.MaxInt64, -1 for i := n-1; i &gt;= 0; i-- &#123; for j := i+1; j &lt; n; j++ &#123; if nums[j] &gt; nums[i] &amp;&amp; nums[j] &lt; min &#123; min = nums[j] k = j &#125; &#125; if k != -1 &#123; nums[i], nums[k] = nums[k], nums[i] sort.Ints(nums[i+1:]) return &#125; &#125; if k == -1 &#123; sort.Ints(nums) &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2. 两数相加]]></title>
    <url>%2Fleetcode-2.html</url>
    <content type="text"><![CDATA[题目描述给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例：输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 题解比较简单，遍历l1, l2进行相加，注意进位问题 示例代码(go)123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode &#123; var head, l3 *ListNode c := 0 for l1 != nil || l2 != nil &#123; sum := c if l1 != nil &#123; sum += l1.Val l1 = l1.Next &#125; if l2 != nil &#123; sum += l2.Val l2 = l2.Next &#125; c = sum / 10 tmp := &amp;ListNode&#123;sum % 10, nil&#125; if head == nil &#123; head = tmp l3 = head &#125; else &#123; l3.Next = tmp l3 = l3.Next &#125; &#125; if c &gt; 0 &#123; tmp := &amp;ListNode&#123;c, nil&#125; l3.Next = tmp &#125; return head&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 79. 单词搜索]]></title>
    <url>%2Fleetcode-79.html</url>
    <content type="text"><![CDATA[题目描述给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例: board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] 给定 word = "ABCCED", 返回 true. 给定 word = "SEE", 返回 true. 给定 word = "ABCB", 返回 false. 题解递归，查看元素的上下左右位置，注意已经搜索过的位置，把搜索过的置为非字母，同时也不要忘了还原 示例代码(go)123456789101112131415161718192021222324252627func exist(board [][]byte, word string) bool &#123; for x := 0; x &lt; len(board); x++ &#123; for y := 0; y &lt; len(board[x]); y++ &#123; if dfs(board, word, x, y, 0) &#123; return true &#125; &#125; &#125; return false&#125;func dfs(board [][]byte, word string, x, y, i int) bool &#123; if i == len(word) &#123; return true &#125; if x &lt; 0 || y &lt; 0 || x == len(board) || y == len(board[x]) &#123; return false &#125; if board[x][y] != word[i] &#123; return false &#125; board[x][y] ^= 255; exists := dfs(board, word, x+1, y, i+1) || dfs(board, word, x-1, y, i+1) || dfs(board, word, x, y+1, i+1) || dfs(board, word, x, y-1, i+1) board[x][y] ^= 255; return exists&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 301. 删除无效的括号]]></title>
    <url>%2Fleetcode-301.html</url>
    <content type="text"><![CDATA[题目描述删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。 说明: 输入可能包含了除 ( 和 ) 以外的字符。 示例 1:输入: “()())()”输出: [“()()()”, “(())()”] 示例 2:输入: “(a)())()”输出: [“(a)()()”, “(a())()”] 示例 3:输入: “)(“输出: [“”] 题解BFS思想，通过不断从字符串中减去一位，找出各种可能的子序列，然后判断是否合法（PS：合法的字符串的长度一定都是相同的) 示例代码(go)123456789101112131415161718192021222324252627282930313233343536373839404142434445func removeInvalidParentheses(s string) []string &#123; hash := make(map[string]bool) res := make([]string, 0) queue := []string&#123;s&#125; for len(queue) &gt; 0 &#123; next := make([]string, 0) for _, str := range queue &#123; if isValid(str) &#123; res = append(res, str) continue &#125; for i, v := range str &#123; if v != '(' &amp;&amp; v != ')' &#123; continue &#125; s := str[:i] + str[i+1:] if _, ok := hash[s]; ok &#123; continue &#125; hash[s] = true next = append(next, s) &#125; &#125; if len(res) &gt; 0 &#123; return res &#125; queue = next &#125; return res&#125;func isValid(str string) bool &#123; count := 0 for _, v := range str &#123; if v == '(' &#123; count++ &#125; else if v == ')' &#123; count-- &#125; if count &lt; 0 &#123; return false &#125; &#125; return count == 0&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 207. 课程表]]></title>
    <url>%2Fleetcode-207.html</url>
    <content type="text"><![CDATA[题目描述现在你总共有 n 门课需要选，记为 0 到 n-1。在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？ 示例 1:输入: 2, [[1,0]]输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。 示例 2:输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 说明: 输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。 题解拓扑排序，找出入度为0的点，然后邻接点的入度各自减1（PS：有向无环图才存在拓扑排序） 示例代码(go)12345678910111213141516171819202122232425262728293031323334func canFinish(numCourses int, prerequisites [][]int) bool &#123; graph := make([][]int, numCourses) indegree := make([]int, numCourses) for _, v := range prerequisites &#123; indegree[v[0]]++ graph[v[1]] = append(graph[v[1]], v[0]) &#125; for &#123; flag := true for _, v := range indegree &#123; if v != -1 &#123; flag = false &#125; &#125; if flag &#123; return true &#125; flag = true for i, v := range indegree &#123; if v == 0 &#123; flag = false for _, v1 := range graph[i] &#123; indegree[v1]-- &#125; indegree[i]-- break &#125; &#125; if flag &#123; return false &#125; &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 96. 不同的二叉搜索树]]></title>
    <url>%2Fleetcode-96.html</url>
    <content type="text"><![CDATA[题目描述给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 题解动态规划，dp[n] = dp[0]dp[n-1]+dp[1]dp[n-2]+dp[2]dp[n-3]+…dp[n-1]dp[0]，其中dp[n]表示n个节点所能代表的二叉搜索树个数，因为二叉搜索树的左节点要小于根节点，右节点要大于根节点，所以当根节点为1时，左节点有为空，右节点有n-1个，当根节点为2时，左节点有为1个，右节点有n-2个，依次类推 示例代码(go)1234567891011121314func numTrees(n int) int &#123; if n == 0 &#123; return 0 &#125; dp := make([]int, n+1) dp[0] = 1 dp[1] = 1 for i := 2; i &lt;= n; i++ &#123; for j := 1; j &lt;= i; j++ &#123; dp[i] += dp[j-1] * dp[i-j] &#125; &#125; return dp[n]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 946. 验证栈序列]]></title>
    <url>%2Fleetcode-946.html</url>
    <content type="text"><![CDATA[题目描述给定 pushed 和 popped 两个序列，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。 示例 1：输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]输出：true解释：我们可以按以下顺序执行：push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1 示例 2：输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]输出：false解释：1 不能在 2 之前弹出。 提示： 0 &lt;= pushed.length == popped.length &lt;= 1000 0 &lt;= pushed[i], popped[i] &lt; 1000 pushed 是 popped 的排列。 题解通过stack模拟入栈出栈 示例代码(go)123456789101112131415161718192021222324252627func validateStackSequences(pushed []int, popped []int) bool &#123; n := len(pushed) if n == 0 &#123; return true &#125; stack := make([]int, 0) i, j := 0, 0 stack = append(stack, pushed[i]) i++ for &#123; m := len(stack) if m &gt; 0 &amp;&amp; stack[m-1] == popped[j] &#123; stack = stack[:m-1] j++ &#125; else &#123; if i == n &#123; break &#125; stack = append(stack, pushed[i]) i++ &#125; &#125; if len(stack) == 0 &#123; return true &#125; return false&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 139. 单词拆分]]></title>
    <url>%2Fleetcode-139.html</url>
    <content type="text"><![CDATA[题目描述给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 示例 1：输入: s = “leetcode”, wordDict = [“leet”, “code”]输出: true解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。 示例 2：输入: s = “applepenapple”, wordDict = [“apple”, “pen”]输出: true解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。 注意你可以重复使用字典中的单词。 示例 3：输入: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]输出: false 题解动态规划，dp[i]表示字符串s的前i个字符是否可以拆分 示例代码(go)12345678910111213141516171819202122func wordBreak(s string, wordDict []string) bool &#123; n := len(s) dp := make([]bool, n+1) dp[0] = true for i := 1; i &lt;= n; i++ &#123; for j := 0; j &lt; i; j++ &#123; if dp[j] &amp;&amp; contains(s[j:i], wordDict) &#123; dp[i] = true &#125; &#125; &#125; return dp[n]&#125;func contains(s string, dict []string) bool &#123; for _, v := range dict &#123; if s == v &#123; return true &#125; &#125; return false&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 141. 环形链表]]></title>
    <url>%2Fleetcode-141.html</url>
    <content type="text"><![CDATA[题目描述给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1：输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2：输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3：输入：head = [1], pos = -1输出：false解释：链表中没有环。 题解通过快慢指针进行判断，如果有环则会相遇 示例代码(go)123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func hasCycle(head *ListNode) bool &#123; if head == nil &#123; return false &#125; fast, slow := head, head for slow != nil &amp;&amp; fast != nil &#123; slow = slow.Next if fast.Next == nil &#123; return false &#125; fast = fast.Next.Next if slow == fast &#123; return true &#125; &#125; if slow != fast &#123; return false &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 581. 最短无序连续子数组]]></title>
    <url>%2Fleetcode-581.html</url>
    <content type="text"><![CDATA[题目描述给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。你找到的子数组应是最短的，请输出它的长度。 示例 1:输入: [2, 6, 4, 8, 10, 9, 15]输出: 5解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。 说明 : 输入的数组长度范围在 [1, 10,000]。 输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。 题解遍历数组，同时进行从头到尾，从尾到头的遍历，分别找出无序连续子数组区间的右边和左边节点；右边点，是从左到右不递增的点，左边点，是从右到左不递减的点，两点之间的距离就是所求值 示例代码(go)12345678910111213141516171819202122232425262728func findUnsortedSubarray(nums []int) int &#123; n := len(nums) if n == 0 &#123; return 0 &#125; start, end := n-1, 0 max, min := nums[0], nums[n-1] for i := 0; i &lt; n; i++ &#123; if nums[i] &gt;= max &#123; max= nums[i] &#125; else &#123; end = i &#125; if nums[n-i-1] &lt;= min &#123; min = nums[n-i-1] &#125; else &#123; start = n-i-1 &#125; &#125; if start &gt;= end &#123; return 0 &#125; return end-start+1&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 234. 回文链表]]></title>
    <url>%2Fleetcode-234.html</url>
    <content type="text"><![CDATA[题目描述请判断一个链表是否为回文链表。 示例 1:输入: 1-&gt;2输出: false 示例 2:输入: 1-&gt;2-&gt;2-&gt;1输出: true 题解分为三步，首先通过快慢指针找到链表的中点，然后算出中点后面的逆序链表，最后比较链表中点前后的值是否相同 示例代码(go)1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func isPalindrome(head *ListNode) bool &#123; fast, slow := head, head var reverse *ListNode for fast != nil &#123; slow = slow.Next if fast.Next != nil &#123; fast = fast.Next.Next &#125; else &#123; fast = fast.Next &#125; &#125; for slow != nil &#123; tmp := slow.Next slow.Next = reverse reverse = slow slow = tmp &#125; for head != nil &amp;&amp; reverse != nil &#123; if head.Val != reverse.Val &#123; return false &#125; head = head.Next reverse = reverse.Next &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 20. 有效的括号]]></title>
    <url>%2Fleetcode-20.html</url>
    <content type="text"><![CDATA[题目描述给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1:输入: “()”输出: true 示例 2:输入: “()[]{}”输出: true 示例 3:输入: “(]”输出: false 示例 4:输入: “([)]”输出: false 示例 5:输入: “{[]}”输出: true 题解通过栈解决，左括号入栈，右括号出栈比较 示例代码(go)1234567891011121314151617181920212223242526272829func isValid(s string) bool &#123; stack := make([]byte, 0) for _, v := range s &#123; v1 := byte(v) if v1 == '(' || v1 == '&#123;' || v1 == '[' &#123; stack = append(stack, v1) &#125; else &#123; n := len(stack) if n == 0 &#123; return false &#125; v2 := stack[n-1] stack = stack[:n-1] if v1 == ')' &amp;&amp; v2 != '(' &#123; return false &#125; if v1 == '&#125;' &amp;&amp; v2 != '&#123;' &#123; return false &#125; if v1 == ']' &amp;&amp; v2 != '[' &#123; return false &#125; &#125; &#125; if len(stack) != 0 &#123; return false &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 438. 找到字符串中所有字母异位词]]></title>
    <url>%2Fleetcode-438.html</url>
    <content type="text"><![CDATA[题目描述给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。 说明： 字母异位词指字母相同，但排列不同的字符串。 不考虑答案输出的顺序。 示例 1:输入:s: “cbaebabacd” p: “abc”输出:[0, 6]解释:起始索引等于 0 的子串是 “cba”, 它是 “abc” 的字母异位词。起始索引等于 6 的子串是 “bac”, 它是 “abc” 的字母异位词。 示例 2:输入:s: “abab” p: “ab”输出:[0, 1, 2]解释:起始索引等于 0 的子串是 “ab”, 它是 “ab” 的字母异位词。起始索引等于 1 的子串是 “ba”, 它是 “ab” 的字母异位词。起始索引等于 2 的子串是 “ab”, 它是 “ab” 的字母异位词。 题解通过哈希表记录字符出现的次数，通过滑动窗口找出要进行比较的字符串，计算出窗口字符串中每个字符出现的次数，然后比较两个哈希表是否相等 示例代码(go)12345678910111213141516171819202122232425262728func findAnagrams(s string, p string) []int &#123; res := make([]int, 0) hashS := make(map[byte]int) hashP := make(map[byte]int) m, n := len(s), len(p) for i := 0; i &lt; n; i++ &#123; hashP[p[i]]++ &#125; for i := 0; i &lt; m; i++ &#123; if i &gt;= n &#123; hashS[s[i-n]]-- &#125; hashS[s[i]]++ if isEqual(hashS, hashP) &#123; res = append(res, i-n+1) &#125; &#125; return res&#125;func isEqual(a, b map[byte]int) bool &#123; for k, v := range b &#123; if a[k] != v &#123; return false &#125; &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 416. 分割等和子集]]></title>
    <url>%2Fleetcode-416.html</url>
    <content type="text"><![CDATA[题目描述给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200 示例 1:输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例 2:输入: [1, 2, 3, 5]输出: false解释: 数组不能分割成两个元素和相等的子集. 题解两个子集相等，可以知道数组的和sum肯定为偶数，然后问题就变为，判断数组中是否存在和为sum/2的子集，使用背包问题的动态规划，计算出pack可以存储的数值和 示例代码(go)1234567891011121314151617181920212223func canPartition(nums []int) bool &#123; sum := 0 for _, v := range nums &#123; sum += v &#125; if sum % 2 != 0 &#123; return false &#125; capacity := sum / 2 pack := make([]bool, capacity+1) pack[0] = true for _, v1 := range nums &#123; for v2 := capacity; v2 &gt;= v1; v2-- &#123; if pack[v2-v1] &#123; pack[v2] = true &#125; &#125; if pack[capacity] &#123; return true &#125; &#125; return false&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 105 . 从前序与中序遍历序列构造二叉树]]></title>
    <url>%2Fleetcode-105.html</url>
    <content type="text"><![CDATA[题目描述根据一棵树的前序遍历与中序遍历构造二叉树。注意:你可以假设树中没有重复的元素。 例如，给出前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树： 3 / \ 9 20 / \ 15 7 题解前序遍历顺序为根左右，中序遍历顺序为左根右，所以可以看出preorder中的每一个数，在inorder中所处位置的左边就是左子树，右边为右子树 示例代码(go)12345678910111213141516171819202122232425/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func buildTree(preorder []int, inorder []int) *TreeNode &#123; var node *TreeNode if len(preorder) == 0 &#123; return node &#125; node = &amp;TreeNode&#123;preorder[0], nil, nil&#125; left := 0 for i, v := range inorder &#123; if v == preorder[0] &#123; left = i break &#125; &#125; node.Left = buildTree(preorder[1:left+1], inorder[:left]) node.Right = buildTree(preorder[left+1:], inorder[left+1:]) return node&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 300. 最长上升子序列]]></title>
    <url>%2Fleetcode-300.html</url>
    <content type="text"><![CDATA[题目描述给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例:输入: [10,9,2,5,3,7,101,18]输出: 4解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 题解动态规划，dp[j] = max(dp[j], dp[i]+1)，表示当j &gt; i, nums[j] &gt; nums[i]时取最大的上升子序 示例代码(go)123456789101112131415161718192021222324func lengthOfLIS(nums []int) int &#123; n := len(nums) res := 0 dp := make([]int, n) for i := 0; i &lt; n; i++ &#123; if dp[i] == 0 &#123; dp[i] += 1 &#125; for j := i+1; j &lt; n; j++ &#123; if nums[j] &gt; nums[i] &#123; dp[j] = max(dp[j], dp[i]+1) &#125; &#125; res = max(res, dp[i]) &#125; return res&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 128. 最长连续序列]]></title>
    <url>%2Fleetcode-128.html</url>
    <content type="text"><![CDATA[题目描述给定一个未排序的整数数组，找出最长连续序列的长度。要求算法的时间复杂度为 O(n)。示例:输入: [100, 4, 200, 1, 3, 2]输出: 4解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。 题解哈希表存储连续区间的长度，遍历数组，如果数已在哈希表中则跳过，若还没有加入，则取出其左右相邻数表示的连续区间长度相加，然后更新左右区间两端点的长度值 示例代码(go)12345678910111213141516171819202122232425262728293031323334func longestConsecutive(nums []int) int &#123; res := 0 hash := make(map[int]int) for i := 0; i &lt; len(nums); i++ &#123; num := nums[i] if _, ok := hash[num]; ok &#123; continue &#125; hash[num] += 1 v1, ok1 := hash[num-1] v2, ok2 := hash[num+1] if ok1 &#123; hash[num] += v1 &#125; if ok2 &#123; hash[num] += v2 &#125; if hash[num] &gt; res &#123; res = hash[num] &#125; if ok1 &#123; hash[num-v1] = hash[num] &#125; if ok2 &#123; hash[num+v2] = hash[num] &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 240. 搜索二维矩阵 II]]></title>
    <url>%2Fleetcode-240.html</url>
    <content type="text"><![CDATA[题目描述编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例: 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 题解因为数组从左到右，从上到下都是递增的，所以可以从数组左下角的开始判断，比目标值大就往上比较，比目标小就往右比较 示例代码(go)12345678910111213141516func searchMatrix(matrix [][]int, target int) bool &#123; m, n := len(matrix), 0 if m &gt; 0 &#123; n = len(matrix[0]) &#125; for i, j := m-1, 0; i &gt;= 0 &amp;&amp; j &lt; n; &#123; if matrix[i][j] &gt; target &#123; i-- &#125; else if matrix[i][j] &lt; target &#123; j++ &#125; else &#123; return true &#125; &#125; return false&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 15. 三数之和]]></title>
    <url>%2Fleetcode-15.html</url>
    <content type="text"><![CDATA[题目描述给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2]] 题解首先对数组进行排序，接着把三数问题变为两数问题，即遍历第一个数，找剩下的两个数；主要注意重复问题，每一个数要保证与上一次找到的数不同，nums[i]==nums[1-1], nums[j]==nums[j-1], nums[k]==nums[k+1]都是要跳过的 示例代码(go)123456789101112131415161718192021222324252627282930func threeSum(nums []int) [][]int &#123; sort.Ints(nums) n := len(nums) res := make([][]int, 0) for i := 0; i &lt; n-2; i++ &#123; if i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &#123; continue &#125; j, k := i+1, n-1 for j &lt; k &#123; sum := nums[i] + nums[j] + nums[k] if sum &gt; 0 &#123; k-- &#125; else if sum &lt; 0 &#123; j++ &#125; else &#123; res = append(res, []int&#123;nums[i], nums[j], nums[k]&#125;) j++ k-- for nums[j] == nums[j-1] &amp;&amp; j &lt; k &#123; j++ &#125; for nums[k] == nums[k+1] &amp;&amp; j &lt; k &#123; k-- &#125; &#125; &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 75. 颜色分类]]></title>
    <url>%2Fleetcode-75.html</url>
    <content type="text"><![CDATA[题目描述给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意:不能使用代码库中的排序函数来解决这道题。 示例:输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 题解遍历数组nums，分为三种情况，值为1直接跳过，值为0则与前面的数对换（i前面的数已经排好），值为2则与后面的数对换（j后面的数已经排好） 示例代码(go)1234567891011121314func sortColors(nums []int) &#123; for cur, i, j := 0, -1, len(nums); cur &lt; j; &#123; if nums[cur] == 0 &#123; i++ nums[i], nums[cur] = nums[cur], nums[i] cur++ &#125; else if nums[cur] == 1 &#123; cur++ &#125; else if nums[cur] == 2 &#123; j-- nums[j], nums[cur] = nums[cur], nums[j] &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 42. 接雨水]]></title>
    <url>%2Fleetcode-42.html</url>
    <content type="text"><![CDATA[题目描述给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 题解首先找出柱子的最大高度maxHeight，然后分别找出从1, 2, 3...maxHeight高度所能接到的雨水，每一次高度所能接到的雨水，就是两个相邻的不低于此高度的柱子之间的距离 示例代码(go)1234567891011121314151617181920func trap(height []int) int &#123; maxHeight, res := 0, 0 for _, v := range height &#123; if maxHeight &lt; v &#123; maxHeight = v &#125; &#125; for i := 1; i &lt;= maxHeight; i++ &#123; cur := -1 for j, v := range height &#123; if cur != -1 &amp;&amp; v &gt;= i &#123; res += j-cur-1 &#125; if v &gt;= i &#123; cur = j &#125; &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 437. 路径总和 III]]></title>
    <url>%2Fleetcode-437.html</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树，它的每个结点都存放着一个整数值。找出路径和等于给定数值的路径总数。路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。 示例： root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \ 5 -3 / \ \ 3 2 11 / \ \ 3 -2 1 返回 3。和等于 8 的路径有: 1. 5 -> 3 2. 5 -> 2 -> 1 3. -3 -> 11 题解递归，注意递归结束条件，cur == 0时不要结束递归，因为可能还有更长的路径和等于sum 示例代码(go)12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func pathSum(root *TreeNode, sum int) int &#123; if root == nil &#123; return 0 &#125; res := preTrav(root, sum) res += pathSum(root.Left, sum) res += pathSum(root.Right, sum) return res&#125;func preTrav(root *TreeNode, cur int) int &#123; if root == nil &#123; return 0 &#125; res := 0 cur -= root.Val if cur == 0 &#123; res++ &#125; res += preTrav(root.Left, cur) res += preTrav(root.Right, cur) return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 279. 完全平方数]]></title>
    <url>%2Fleetcode-279.html</url>
    <content type="text"><![CDATA[题目描述给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1:输入: n = 12输出: 3解释: 12 = 4 + 4 + 4. 示例 2:输入: n = 13输出: 2解释: 13 = 4 + 9. 题解动态规划，dp[i] = min(dp[i], dp[j]+dp[i-j])，如果i为完全平方数, 则预先设置dp[i]=1 示例代码(go)12345678910111213141516171819func numSquares(n int) int &#123; dp := make([]int, n+1) for i, j := 1, 1; i &lt;= n; &#123; dp[i] = 1 j++ i = j * j &#125; for i := 1; i &lt;= n; i++ &#123; if dp[i] != 1 &#123; dp[i] = dp[1] + dp[i-1] &#125; for j := 1; j &lt;= i/2; j++ &#123; if dp[i] &gt; dp[j]+dp[i-j] &#123; dp[i] = dp[j]+dp[i-j] &#125; &#125; &#125; return dp[n]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 572. 另一个树的子树]]></title>
    <url>%2Fleetcode-572.html</url>
    <content type="text"><![CDATA[题目描述给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。 示例 1: 给定的树 s: 3 / \ 4 5 / \ 1 2 给定的树 t： 4 / \ 1 2 返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。 示例 2: 给定的树 s： 3 / \ 4 5 / \ 1 2 / 0 给定的树 t： 4 / \ 1 2 返回 false。 题解递归判断两个二叉树是否相同 示例代码(go)123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func isSubtree(s *TreeNode, t *TreeNode) bool &#123; if s == nil &amp;&amp; t != nil &#123; return false &#125; return isSame(s, t) || isSubtree(s.Left, t) || isSubtree(s.Right, t)&#125;func isSame(s *TreeNode, t *TreeNode) bool &#123; if s != nil &amp;&amp; t == nil &#123; return false &#125; if s == nil &amp;&amp; t != nil &#123; return false &#125; if s == nil &amp;&amp; t == nil &#123; return true &#125; if s.Val != t.Val &#123; return false &#125; return isSame(s.Left, t.Left) &amp;&amp; isSame(s.Right, t.Right)&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1022. 从根到叶的二进制数之和]]></title>
    <url>%2Fleetcode-1022.html</url>
    <content type="text"><![CDATA[题目描述给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1，那么它表示二进制数 01101，也就是 13 。对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。以 10^9 + 7 为模，返回这些数字之和。 示例： 输入：[1,0,1,0,1,0,1]输出：22解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22 提示： 树中的结点数介于 1 和 1000 之间。 node.val 为 0 或 1 。 题解前序遍历二叉树，通过左移运算符把遍历的二进制转化为十进制 示例代码(go)12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func sumRootToLeaf(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; return perTrav(root, 0)&#125;func perTrav(root *TreeNode, cur int) int &#123; sum := 0 cur = cur &lt;&lt; 1 cur += root.Val if root.Left == nil &amp;&amp; root.Right == nil &#123; sum += cur return sum &#125; if root.Left != nil &#123; sum += perTrav(root.Left, cur) &#125; if root.Right != nil &#123; sum += perTrav(root.Right, cur) &#125; return sum&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 101. 对称二叉树]]></title>
    <url>%2Fleetcode-101.html</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树，检查它是否是镜像对称的。例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \ 2 2 / \ / \ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \ 2 2 \ \ 3 3 题解递归，判断左子树的左边和右子树的右边，以及左子树的右边和右子树的左边是否相同 示例代码(go)123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func isSymmetric(root *TreeNode) bool &#123; if root == nil &#123; return true &#125; return isLRSymmetric(root.Left, root.Right)&#125;func isLRSymmetric(left, right *TreeNode) bool &#123; if left == nil &amp;&amp; right != nil &#123; return false &#125; if left != nil &amp;&amp; right == nil &#123; return false &#125; if left == nil &amp;&amp; right == nil &#123; return true &#125; if left.Val != right.Val &#123; return false &#125; return isLRSymmetric(left.Left, right.Right) &amp;&amp; isLRSymmetric(left.Right, right.Left)&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 53. 最大子序和]]></title>
    <url>%2Fleetcode-53.html</url>
    <content type="text"><![CDATA[题目描述给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例:输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 题解nums[i] = max(nums[i], nums[i]+nums[i-1]代表i位置处所得到的最大子序和 示例代码(go)12345678910111213141516171819func maxSubArray(nums []int) int &#123; n := len(nums) if n == 0 &#123; return 0 &#125; res := nums[0] for i := 1; i &lt; n; i++ &#123; nums[i] = max(nums[i], nums[i]+nums[i-1]) res = max(res, nums[i]) &#125; return res&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 102. 二叉树的层次遍历]]></title>
    <url>%2Fleetcode-102.html</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。例如:给定二叉树: [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 返回其层次遍历结果：[ [3], [9,20], [15,7]] 题解非递归算法，通过队列保存节点，找到每个节点的左右子树入队 示例代码(go)123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func levelOrder(root *TreeNode) [][]int &#123; res := make([][]int, 0) if root == nil &#123; return res &#125; queue := make([]*TreeNode, 0) queue = append(queue, root) n := len(queue) arr := make([]int, 0) for len(queue) &gt; 0 &#123; node := queue[0] queue = queue[1:] arr = append(arr, node.Val) n-- if node.Left != nil &#123; queue = append(queue, node.Left) &#125; if node.Right != nil &#123; queue = append(queue, node.Right) &#125; if n == 0 &#123; res = append(res, arr) n = len(queue) arr = []int&#123;&#125; &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 543. 二叉树的直径]]></title>
    <url>%2Fleetcode-543.html</url>
    <content type="text"><![CDATA[题目描述给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。 示例 : 给定二叉树 1 / \ 2 3 / \ 4 5返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。注意：两结点之间的路径长度是以它们之间边的数目表示。 题解直径可能是任意两个结点的路径长度，所以要在找每个结点的左右子树高度和时，比较最大直径 示例代码(go)12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */var res intfunc diameterOfBinaryTree(root *TreeNode) int &#123; res = 0 height(root) return res&#125;func height(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; left := height(root.Left) right := height(root.Right) res = max(res, left+right) return max(left, right) + 1&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 560. 和为K的子数组]]></title>
    <url>%2Fleetcode-560.html</url>
    <content type="text"><![CDATA[题目描述给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1 :输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明 : 数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。 题解通过遍历nums，记录连续数值的和sum出现的次数，sum-k表示当前和与前边某一个和相差k，也就是说这两个和值之间的子数组就是和为K的子数组 示例代码(go)1234567891011func subarraySum(nums []int, k int) int &#123; res, sum := 0, 0 hash := make(map[int]int, len(nums)) hash[0] = 1 for _, v := range nums &#123; sum += v res += hash[sum-k] hash[sum]++ &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 200. 岛屿的个数]]></title>
    <url>%2Fleetcode-200.html</url>
    <content type="text"><![CDATA[题目描述给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例 1: 输入: 11110 11010 11000 00000 输出: 1 示例 2: 输入: 11000 11000 00100 00011 输出: 3 题解遍历grid，遇到数值为1时置为0，然后不断递归上下左右的位置为0 示例代码(go)1234567891011121314151617181920212223242526272829303132func numIslands(grid [][]byte) int &#123; m := len(grid) if m == 0 &#123; return 0 &#125; n, res := len(grid[0]), 0 for i := 0; i &lt; m; i++ &#123; for j := 0; j &lt; n; j++ &#123; if grid[i][j] == '1' &#123; res++ dfs(grid, i, j, m, n) &#125; &#125; &#125; return res&#125;func dfs(grid [][]byte, i, j, m, n int) &#123; grid[i][j] = '0' if i-1 &gt;= 0 &amp;&amp; grid[i-1][j] == '1' &#123; dfs(grid, i-1, j, m, n) &#125; if j-1 &gt;= 0 &amp;&amp; grid[i][j-1] == '1' &#123; dfs(grid, i, j-1, m, n) &#125; if i+1 &lt; m &amp;&amp; grid[i+1][j] == '1' &#123; dfs(grid, i+1, j, m, n) &#125; if j+1 &lt; n &amp;&amp; grid[i][j+1] == '1' &#123; dfs(grid, i, j+1, m, n) &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 198. 打家劫舍]]></title>
    <url>%2Fleetcode-198.html</url>
    <content type="text"><![CDATA[题目描述你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1:输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2:输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 题解动态规划问题，状态转移方程nums[i] = max(nums[i-1], nums[i-2]+nums[i])（PS：注意初始化nums[0], nums[1]） 示例代码(go)123456789101112131415161718192021func rob(nums []int) int &#123; n := len(nums) if n == 0 &#123; return 0 &#125; if n == 1 &#123; return nums[0] &#125; nums[1] = max(nums[0], nums[1]) for i := 2; i &lt; n; i++ &#123; nums[i] = max(nums[i-1], nums[i-2]+nums[i]) &#125; return nums[n-1]&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 114. 二叉树展开为链表]]></title>
    <url>%2Fleetcode-114.html</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树，原地将它展开为链表。例如，给定二叉树 1 / \ 2 5 / \ \3 4 6将其展开为： 1 \ 2 \ 3 \ 4 \ 5 \ 6 题解分别递归左右子树变为链表，然后先临时保存右子树，再把右子树指向左子树并清空，最后找到右子树的最后的叶节点，指向临时保存的原右子树 示例代码(go)12345678910111213141516171819202122/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func flatten(root *TreeNode) &#123; if root == nil &#123; return &#125; flatten(root.Left) flatten(root.Right) tmp := root.Right root.Right = root.Left root.Left = nil for root.Right != nil &#123; root = root.Right &#125; root.Right = tmp&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 494. 目标和]]></title>
    <url>%2Fleetcode-494.html</url>
    <content type="text"><![CDATA[题目描述给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 示例 1:输入: nums: [1, 1, 1, 1, 1], S: 3输出: 5解释:-1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3一共有5种方法让最终目标和为3。 注意: 数组的长度不会超过20，并且数组中的值全为正数。 初始的数组的和不会超过1000。 保证返回的最终结果为32位整数。 题解简单粗暴，直接根据上一次的结果存储各种可能性 示例代码(go)12345678910111213func findTargetSumWays(nums []int, S int) int &#123; hash := make(map[int]int) hash[0] = 1 for _, v := range nums &#123; tmp := make(map[int]int) for k, _ := range hash &#123; tmp[k+v] += hash[k] tmp[k-v] += hash[k] &#125; hash = tmp &#125; return hash[S]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 11. 盛最多水的容器]]></title>
    <url>%2Fleetcode-11.html</url>
    <content type="text"><![CDATA[题目描述给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 题解通过移动两个序号i,j，找出最大值，具体步骤就是高度较低的往内移动 示例代码(go)123456789101112131415161718192021222324252627func maxArea(height []int) int &#123; res := 0 i, j := 0, len(height)-1 for i &lt; j &#123; res = max(res, (j-i) * min(height[i], height[j])) if height[i] &lt; height[j] &#123; i++ &#125; else &#123; j-- &#125; &#125; return res&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;func min(a, b int) int &#123; if a &lt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 394. 字符串解码]]></title>
    <url>%2Fleetcode-394.html</url>
    <content type="text"><![CDATA[题目描述给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例:s = “3[a]2[bc]”, 返回 “aaabcbc”.s = “3[a2[c]]”, 返回 “accaccacc”.s = “2[abc]3[cd]ef”, 返回 “abcabccdcdcdef”. 题解倒序遍历字符串s，如果不是[则直接入栈；遇到[时，先找出[前边的数字nums表示为k，然后找出编码字符串encodedStr，重复k次入栈，跳过数字继续遍历 示例代码(go)12345678910111213141516171819202122232425262728293031323334353637383940func decodeString(s string) string &#123; stack := make([]string, 0) for i := len(s)-1; i &gt;=0;&#123; if s[i] == '[' &#123; nums := make([]string, 0) for j := i-1; j &gt;= 0; j-- &#123; if s[j] &gt;= '0' &amp;&amp; s[j] &lt;= '9' &#123; nums = append(nums, string(s[j])) &#125; else &#123; break &#125; &#125; reverse(nums) k, _ := strconv.Atoi(strings.Join(nums, "")) encodedStr := make([]string, 0) for stack[len(stack)-1] != "]" &#123; encodedStr = append(encodedStr, stack[len(stack)-1]) stack = stack[:len(stack)-1] &#125; stack = stack[:len(stack)-1] reverse(encodedStr) for j := 0; j &lt; k; j++ &#123; stack = append(stack, encodedStr...) &#125; i -= len(nums) &#125; else &#123; stack = append(stack, string(s[i])) &#125; i -= 1 &#125; reverse(stack) return strings.Join(stack, "")&#125;func reverse(arr []string) &#123; length := len(arr) for i := 0; i &lt; length/2; i++ &#123; arr[i], arr[length-i-1] = arr[length-i-1], arr[i] &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1. 两数之和]]></title>
    <url>%2Fleetcode-1.html</url>
    <content type="text"><![CDATA[题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 题解哈希表保存位置 示例代码(go)123456789101112131415func twoSum(nums []int, target int) []int &#123; res := make([]int, 2) hash := make(map[int]int) for i, v := range nums &#123; hash[v] = i &#125; for i, v := range nums &#123; if j, ok := hash[target-v]; ok &amp;&amp; j != i &#123; res[0] = i res[1] = j break &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 64. 最小路径和]]></title>
    <url>%2Fleetcode-64.html</url>
    <content type="text"><![CDATA[题目描述给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。 示例: 输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 题解动态规划问题，grid[i][j] += min(grid[i-1][j], grid[i][j-1]) 示例代码(go)1234567891011121314151617181920212223242526272829func minPathSum(grid [][]int) int &#123; m := len(grid) if m == 0 &#123; return 0 &#125; n := len(grid[0]) if n == 0 &#123; return 0 &#125; for i := 1; i &lt; n; i++ &#123; grid[0][i] += grid[0][i-1] &#125; for i := 1; i &lt; m; i++ &#123; grid[i][0] += grid[i-1][0] &#125; for i := 1; i &lt; m; i++ &#123; for j := 1; j &lt; n; j++ &#123; grid[i][j] += min(grid[i-1][j], grid[i][j-1]) &#125; &#125; return grid[m-1][n-1]&#125;func min(a, b int) int &#123; if a &lt;= b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 39. 组合总和]]></title>
    <url>%2Fleetcode-39.html</url>
    <content type="text"><![CDATA[题目描述给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。 说明：所有数字（包括 target）都是正整数。解集不能包含重复的组合。 示例 1: 输入: candidates = [2,3,6,7], target = 7, 所求解集为: [ [7], [2,2,3] ] 示例 2: 输入: candidates = [2,3,5], target = 8, 所求解集为: [ [2,2,2,2], [2,3,3], [3,5] ] 题解递归，遍历数组candidates，通过target减去数组中相应的值，不断缩小target进行递归，同时为了避免重复，从数组中取的值不能大于target/2，同时不能小于上一次的取值prev例如, candidates=[2,3,5,6,7,8,9,11,12]; target = 14，可以递归(2,12),(3,11),(5,9),(6,8),(7,7) 示例代码(go)1234567891011121314151617181920func combinationSum(candidates []int, target int) [][]int &#123; return combination(candidates, []int&#123;&#125;, 0, target)&#125;func combination(candidates []int, arr []int, prev, target int) [][]int &#123; res := make([][]int, 0) if target == 0 &#123; tmp := append([]int&#123;&#125;, arr...) res = append(res, tmp) return res &#125; for _, v := range candidates &#123; if (v &lt;= target/2 &amp;&amp; v &gt;= prev) || v == target &#123; arr = append(arr, v) res = append(res, combination(candidates, arr, v, target-v)...) arr = arr[:len(arr)-1] &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 287. 寻找重复数]]></title>
    <url>%2Fleetcode-287.html</url>
    <content type="text"><![CDATA[题目描述给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例 1:输入: [1,3,4,2,2]输出: 2 示例 2:输入: [3,1,3,4,2]输出: 3 说明： 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 题解通过使用nums的值作为序号i，让相应位置取反，因为重复数值会访问相同位置多次，从而找出重复数值 示例代码(go)123456789101112131415161718func findDuplicate(nums []int) int &#123; for _, v := range nums &#123; i := abs(v) if nums[i] &lt; 0 &#123; return i &#125; else &#123; nums[i] = -nums[i] &#125; &#125; return 0&#125;func abs(a int) int &#123; if a &lt; 0 &#123; return -a &#125; return a&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 94. 二叉树的中序遍历]]></title>
    <url>%2Fleetcode-94.html</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树，返回它的中序 遍历。 示例: 输入: [1,null,2,3] 1 \ 2 / 3 输出: [1,3,2] 题解通过stack模拟栈进行中序遍历 示例代码(go)1234567891011121314151617181920212223/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func inorderTraversal(root *TreeNode) []int &#123; res := make([]int, 0) stack := make([]*TreeNode, 0) for root != nil || len(stack) != 0 &#123; for root != nil &#123; stack = append(stack, root) root = root.Left &#125; root = stack[len(stack)-1] stack = stack[:len(stack)-1] res = append(res, root.Val) root = root.Right &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 22. 括号生成]]></title>
    <url>%2Fleetcode-22.html</url>
    <content type="text"><![CDATA[题目描述给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： [ “((()))”, “(()())”, “(())()”, “()(())”, “()()()”] 题解递归，左括号小于n时递归，右括号小于左括号时递归，左右括号数量为n时停止递归 示例代码(go)123456789101112131415161718192021func generateParenthesis(n int) []string &#123; res := make([]string, 0) if n == 0 &#123; return res &#125; generate(&amp;res, "", n, 0) return res&#125;func generate(arr *[]string, str string, left, right int) &#123; if left == 0 &amp;&amp; right == 0 &#123; *arr = append(*arr, str) return &#125; if left &gt; 0 &#123; generate(arr, str+"(", left-1, right+1) &#125; if right &gt; 0 &#123; generate(arr, str+")", left, right-1) &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 347. 前K个高频元素]]></title>
    <url>%2Fleetcode-347.html</url>
    <content type="text"><![CDATA[题目描述给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1:输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例 2:输入: nums = [1], k = 1输出: [1] 说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 题解统计相同数字出现的次数，然后根据出现次数存入二维数组中，最后从二维数组的后面开始取出高频数值 示例代码(go)12345678910111213141516171819202122232425262728func topKFrequent(nums []int, k int) []int &#123; arr := make([]int, 0) if len(nums) == 0 &#123; return arr &#125; m := make(map[int]int) maxCount := 0 for _,v := range nums &#123; m[v] += 1 if m[v] &gt; maxCount &#123; maxCount = m[v] &#125; &#125; tmp := make([][]int, maxCount+1) for k,v := range m &#123; tmp[v] = append(tmp[v], k) &#125; for i := maxCount; i &gt;= 0; i-- &#123; if len(tmp[i]) == 0 &#123; continue &#125; arr = append(arr, tmp[i]...) if len(arr) == k &#123; break &#125; &#125; return arr&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 46. 全排列]]></title>
    <url>%2Fleetcode-46.html</url>
    <content type="text"><![CDATA[题目描述给定一个没有重复数字的序列，返回其所有可能的全排列。 示例: 输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 题解递归，首先通过交换数组头部和后序的值，然后对剩下的子数组进行递归排列 示例代码(go)123456789101112131415161718192021func permute(nums []int) [][]int &#123; return recursion(nums, 0, len(nums)-1)&#125;func recursion(nums []int, left, right int) [][]int &#123; res := make([][]int, 0) if left == right &#123; tmp := append([]int&#123;&#125;, nums...) res = append(res, tmp) &#125; for i := left; i &lt;= right; i++ &#123; swap(nums, i, left) res = append(res, recursion(nums, left+1, right)...) swap(nums, i, left) &#125; return res&#125;func swap(nums []int, i, j int) &#123; nums[i], nums[j] = nums[j], nums[i]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 78. 子集]]></title>
    <url>%2Fleetcode-78.html</url>
    <content type="text"><![CDATA[题目描述给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 题解倒序遍历数组nums，依次添加到前边的子集中 示例代码(go)1234567891011121314func subsets(nums []int) [][]int &#123; res := make([][]int, 0) res = append(res, []int&#123;&#125;) for i := len(nums)-1; i &gt;= 0; i-- &#123; length := len(res) for j := 0; j &lt; length; j++ &#123; tmp := make([]int, 0) tmp = append(tmp, nums[i]) tmp = append(tmp, res[j]...) res = append(res, tmp) &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 238. 除自身以外数组的乘积]]></title>
    <url>%2Fleetcode-238.html</url>
    <content type="text"><![CDATA[题目描述给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例:输入: [1,2,3,4]输出: [24,12,8,6] 说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 题解计算i左右两边的乘积，两边乘积再相乘，就可以了 示例代码(go)12345678910111213141516171819func productExceptSelf(nums []int) []int &#123; length := len(nums) if length &lt; 2 &#123; return nums &#125; res := make([]int, length) res[0] = 1 for i := 1; i &lt; length; i++ &#123; res[i] = res[i - 1] * nums[i - 1] &#125; reverse := 1 for i := length - 1; i &gt;= 0; i-- &#123; res[i] *= reverse reverse *= nums[i] &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1005. K 次取反后最大化的数组和]]></title>
    <url>%2Fleetcode-1005.html</url>
    <content type="text"><![CDATA[题目描述给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）以这种方式修改数组后，返回数组可能的最大和。 示例 1：输入：A = [4,2,3], K = 1输出：5解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。 示例 2：输入：A = [3,-1,0,2], K = 3输出：6解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。 示例 3：输入：A = [2,-3,-1,5,-4], K = 2输出：13解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。 提示： 1 &lt;= A.length &lt;= 10000 1 &lt;= K &lt;= 10000 -100 &lt;= A[i] &lt;= 100 题解比较反转的次数K和多少个负数nums，主要分两种情况，K &lt; nums时，就反转K个最小的负数，k &gt;= nums时，则看看K-nums是奇数还是偶数，偶数就反转两次不变，奇数就再减去最小值（数组A变为正整数中的最小值） 示例代码(go)1234567891011121314151617181920212223242526272829func largestSumAfterKNegations(A []int, K int) int &#123; res, nums, min := 0, 0, 101 sort.Ints(A) for _, v := range A &#123; if v &lt; 0 &#123; nums++ &#125; if min &gt; abs(v) &#123; min = abs(v) &#125; res += abs(v) &#125; if K &lt; nums &#123; for i := K; i &lt; nums; i++ &#123; res += 2*A[i] &#125; &#125; else if (K-nums) % 2 == 1 &#123; res -= 2*min &#125; return res&#125;func abs(a int) int &#123; if a &lt; 0 &#123; return -a &#125; return a&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 406. 根据身高重建队列]]></title>
    <url>%2Fleetcode-406.html</url>
    <content type="text"><![CDATA[题目描述假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 注意：总人数少于1100人。 示例输入:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]输出:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 题解首先进行排序，身高从高到低，同时根据前面有几个人从低到高，排好之后，根据前面有几人依次插入到相应位置 示例代码(go)1234567891011121314151617181920212223type Sorter [][]intfunc (sorter Sorter) Len() int &#123; return len(sorter) &#125;func (sorter Sorter) Swap(i, j int) &#123; sorter[i], sorter[j] = sorter[j], sorter[i] &#125;func (sorter Sorter) Less(i, j int) bool &#123; if (sorter[i][0] == sorter[j][0]) &#123; return sorter[i][1] &lt; sorter[j][1] &#125; else &#123; return sorter[i][0] &gt; sorter[j][0] &#125;&#125;func reconstructQueue(people [][]int) [][]int &#123; res := make([][]int, 0) sorter := Sorter(people) sort.Sort(sorter) for _, v := range sorter &#123; res = append(res, nil) copy(res[v[1]+1:], res[v[1]:]) res[v[1]] = v &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 553. 最优除法]]></title>
    <url>%2Fleetcode-553.html</url>
    <content type="text"><![CDATA[题目描述给定一组正整数，相邻的整数之间将会进行浮点除法操作。例如， [2,3,4] -&gt; 2 / 3 / 4 。但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，才能得到最大的结果，并且返回相应的字符串格式的表达式。你的表达式不应该含有冗余的括号。 示例：输入: [1000,100,10,2]输出: “1000/(100/10/2)”解释:1000/(100/10/2) = 1000/((100/10)/2) = 200但是，以下加粗的括号 “1000/((100/10)/2)” 是冗余的，因为他们并不影响操作的优先级，所以你需要返回 “1000/(100/10/2)”。 其他用例:1000/(100/10)/2 = 501000/(100/(10/2)) = 501000/100/10/2 = 0.51000/100/(10/2) = 2 说明: 输入数组的长度在 [1, 10] 之间。 数组中每个元素的大小都在 [2, 1000] 之间。 每个测试用例只有一个最优除法解。 题解数学问题，第一个数作为分子不变，找到最小的分母，第一个数后边加括号就可以了 示例代码(go)12345678910111213141516func optimalDivision(nums []int) string &#123; length := len(nums) res := strconv.Itoa(nums[0]) if length == 1 &#123; return res &#125; if length == 2 &#123; return res + "/" + strconv.Itoa(nums[1]) &#125; res += "/(" for i := 1; i &lt; length-1; i++ &#123; res += strconv.Itoa(nums[i]) + "/" &#125; res += strconv.Itoa(nums[length-1]) + ")" return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 812. 最大三角形面积]]></title>
    <url>%2Fleetcode-812.html</url>
    <content type="text"><![CDATA[题目描述给定包含多个点的集合，从其中取三个点组成三角形，返回能组成的最大三角形的面积。 示例:输入: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]输出: 2 解释:这五个点如下图所示。组成的橙色三角形是最大的，面积为2。 注意: 3 &lt;= points.length &lt;= 50. 不存在重复的点。 -50 &lt;= points[i][j] &lt;= 50. 结果误差值在 10^-6 以内都认为是正确答案。 题解通过三点可以计算出三角形的面积，area = (x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)) / 2 示例代码(go)12345678910111213141516171819202122func largestTriangleArea(points [][]int) float64 &#123; res := 0.0 for i := 0; i &lt; len(points)-2; i++ &#123; for j := i+1; j &lt; len(points)-1; j++ &#123; for k := j+1; k &lt; len(points); k++ &#123; area := computeArea(points[i], points[j], points[k]) if area &gt; res &#123; res = area &#125; &#125; &#125; &#125; return res&#125;func computeArea(a, b, c []int) float64 &#123; area := a[0]*(b[1]-c[1]) + b[0]*(c[1]-a[1]) + c[0]*(a[1]-b[1]) if area &lt; 0 &#123; area = -area &#125; return float64(area) / 2.0&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 17. 电话号码的字母组合]]></title>
    <url>%2Fleetcode-17.html</url>
    <content type="text"><![CDATA[题目描述给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例:输入：”23”输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. 说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 题解递归，首先把digits中的每一个数字，依次转化为相对应的字符串存入strings数组中，然后依次递归遍历strings[0], strings[1]...strings[n] 示例代码(go)123456789101112131415161718192021222324func letterCombinations(digits string) []string &#123; res := make([]string, 0) arr := []string&#123;"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"&#125; if digits == "" &#123; return res &#125; strings := make([]string, len(digits)) for i, v := range digits &#123; strings[i] = arr[v-'2'] &#125; recursion(strings, &amp;res, "") return res&#125;func recursion(strings []string, res *[]string, str string) &#123; if len(strings) == 0 &#123; *res = append(*res, str) return &#125; for _, v := range strings[0] &#123; recursion(strings[1:], res, str+string(v)) &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 343. 整数拆分]]></title>
    <url>%2Fleetcode-343.html</url>
    <content type="text"><![CDATA[题目描述给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例 1:输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2:输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。 题解动态规划，dp数组保存最大乘积 示例代码(go)123456789101112131415161718func integerBreak(n int) int &#123; dp := make([]int, n+1) dp[1], dp[2] = 1, 1 for i := 3; i &lt;= n; i++ &#123; for j := 1; j &lt;= i/2; j++ &#123; tmp := max(dp[j], j) * max(dp[i-j], i-j) dp[i] = max(dp[i], tmp) &#125; &#125; return dp[n]&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 463. 岛屿的周长]]></title>
    <url>%2Fleetcode-463.html</url>
    <content type="text"><![CDATA[题目描述给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。 示例 : 输入:[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]输出: 16解释: 它的周长是下面图片中的 16 个黄色的边： 题解判断代表陆地点的上下左右点对应的值，出界或为零则周长加一 示例代码(go)12345678910111213141516171819202122232425262728func islandPerimeter(grid [][]int) int &#123; res := 0 m := len(grid) if m == 0 &#123; return res &#125; n := len(grid[0]) for i := 0; i &lt; m; i++ &#123; for j := 0; j &lt; n; j++ &#123; if grid[i][j] == 1 &#123; if i-1 &lt; 0 || grid[i-1][j] == 0 &#123; res++ &#125; if i+1 &gt;= m || grid[i+1][j] == 0 &#123; res++ &#125; if j-1 &lt; 0 || grid[i][j-1] == 0 &#123; res++ &#125; if j+1 &gt;= n || grid[i][j+1] == 0 &#123; res++ &#125; &#125; &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 413. 等差数列划分]]></title>
    <url>%2Fleetcode-413.html</url>
    <content type="text"><![CDATA[题目描述如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。 例如，以下数列为等差数列:1, 3, 5, 7, 97, 7, 7, 73, -1, -5, -9以下数列不是等差数列。1, 1, 2, 5, 7 数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。如果满足以下条件，则称子数组(P, Q)为等差数组：元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。函数要返回数组 A 中所有为等差数组的子数组个数。 示例:A = [1, 2, 3, 4]返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。 题解找出连续的等差数列，分别计算有多少等差子数组 示例代码(go)12345678910111213141516func numberOfArithmeticSlices(A []int) int &#123; if len(A) &lt; 3 &#123; return 0 &#125; cnt := 0 sum := 0 for i:=2; i&lt;len(A); i++ &#123; if A[i] - A[i-1] == A[i-1] - A[i-2]&#123; cnt = cnt + 1 sum += cnt &#125; else &#123; cnt = 0 &#125; &#125; return sum&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 821. 字符的最短距离]]></title>
    <url>%2Fleetcode-821.html</url>
    <content type="text"><![CDATA[题目描述给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。 示例 1:输入: S = “loveleetcode”, C = ‘e’输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] 说明: 字符串 S 的长度范围为 [1, 10000]。 C 是一个单字符，且保证是字符串 S 里的字符。 S 和 C 中的所有字母均为小写字母。 题解分为两步，第一步找出字符的所有位置，第二步通过比较各个位置找出最短距离 示例代码(go)123456789101112131415161718192021222324252627282930func shortestToChar(S string, C byte) []int &#123; indexArr := make([]int, 0) res := make([]int, len(S)) for i, c := range S &#123; if byte(c) == C &#123; indexArr = append(indexArr, i) &#125; &#125; for i, _ := range S &#123; res[i] = min(i, indexArr) &#125; return res&#125;func min(index int, arr []int) int &#123; min := abs(index-arr[0]) for i := 1; i &lt; len(arr); i++ &#123; if abs(index-arr[i]) &lt; min &#123; min = abs(index-arr[i]) &#125; &#125; return min&#125;func abs(a int) int &#123; if a &lt; 0 &#123; return -a &#125; return a&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 894 . 所有可能的满二叉树]]></title>
    <url>%2Fleetcode-894.html</url>
    <content type="text"><![CDATA[题目描述满二叉树是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。返回包含 N 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。答案中每个树的每个结点都必须有 node.val=0。你可以按任何顺序返回树的最终列表。 示例：输入：7输出：[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]解释： 提示：1 &lt;= N &lt;= 20 题解递归，满二叉树对应的N一定不会是偶数，每一个节点的左边或右边可能有1、3、5、7…等奇数个节点 示例代码(go)12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func allPossibleFBT(N int) []*TreeNode &#123; arr := make([]*TreeNode, 0) if N % 2 == 0 &#123; return arr &#125; if N == 1 &#123; arr = append(arr, new(TreeNode)) return arr &#125; for i := 1; i &lt; N; i+=2 &#123; left := allPossibleFBT(i) right := allPossibleFBT(N-i-1) for _, lt := range left &#123; for _, rt := range right &#123; node := new(TreeNode) node.Left = lt node.Right = rt arr = append(arr, node) &#125; &#125; &#125; return arr&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 756. 金字塔转换矩阵]]></title>
    <url>%2Fleetcode-756.html</url>
    <content type="text"><![CDATA[题目描述现在，我们用一些方块来堆砌一个金字塔。 每个方块用仅包含一个字母的字符串表示，例如 “Z”。使用三元组表示金字塔的堆砌规则如下：(A, B, C) 表示，“C”为顶层方块，方块“A”、“B”分别作为方块“C”下一层的的左、右子块。当且仅当(A, B, C)是被允许的三元组，我们才可以将其堆砌上。初始时，给定金字塔的基层 bottom，用一个字符串表示。一个允许的三元组列表 allowed，每个三元组用一个长度为 3 的字符串表示。如果可以由基层一直堆到塔尖返回true，否则返回false。 示例 1: 输入: bottom = “XYZ”, allowed = [“XYD”, “YZE”, “DEA”, “FFF”]输出: true解析:可以堆砌成这样的金字塔: A / \ D E / \ / \X Y Z 因为符合(‘X’, ‘Y’, ‘D’), (‘Y’, ‘Z’, ‘E’) 和 (‘D’, ‘E’, ‘A’) 三种规则。示例 2: 输入: bottom = “XXYX”, allowed = [“XXX”, “XXY”, “XYX”, “XYY”, “YXZ”]输出: false解析:无法一直堆到塔尖。注意, 允许存在三元组(A, B, C)和 (A, B, D) ，其中 C != D.注意： bottom 的长度范围在 [2, 8]。 allowed 的长度范围在[0, 200]。 方块的标记字母范围为{‘A’, ‘B’, ‘C’, ‘D’, ‘E’, ‘F’, ‘G’}。 题解递归，通过bottom找出下一层字符串next，判断是否可以最终找到长度为1的的顶层字符串 示例代码(go)1234567891011121314151617181920func pyramidTransition(bottom string, allowed []string) bool &#123; return canTrans(bottom, "", allowed)&#125;func canTrans(bottom, next string, allowed []string) bool &#123; if len(bottom) == 1 &#123; return true &#125; if len(bottom) - len(next) &gt; 1 &#123; can := false for _, str := range allowed &#123; if bottom[len(next)] == str[0] &amp;&amp; bottom[len(next)+1] == str[1] &#123; can = can || canTrans(bottom, next+string(str[2]), allowed) &#125; &#125; return can &#125; else &#123; return canTrans(next, "", allowed) &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 740. 删除与获得点数]]></title>
    <url>%2Fleetcode-740.html</url>
    <content type="text"><![CDATA[题目描述给定一个整数数组 nums ，你可以对它进行一些操作。每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。 示例 1:输入: nums = [3, 4, 2]输出: 6解释:删除 4 来获得 4 个点数，因此 3 也被删除。之后，删除 2 来获得 2 个点数。总共获得 6 个点数。 示例 2:输入: nums = [2, 2, 3, 3, 3, 4]输出: 9解释:删除 3 来获得 3 个点数，接着要删除两个 2 和 4 。之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。总共获得 9 个点数。 注意: nums的长度最大为20000。 每个整数nums[i]的大小都在[1, 10000]范围内。 题解分别统计nums中相同数字的和，遍历数组arr，比较i处的相邻arr[i-1]和相隔arr[i-2]+arr[i]的大小 示例代码(go)123456789101112131415161718192021func deleteAndEarn(nums []int) int &#123; max := 0 for _, v := range nums &#123; max = Max(max, v) &#125; arr := make([]int, max+1) for _, v := range nums &#123; arr[v] += v &#125; for i := 2; i &lt;= max; i++ &#123; arr[i] = Max(arr[i-1], arr[i-2] + arr[i]); &#125; return arr[max]&#125;func Max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 648. 单词替换]]></title>
    <url>%2Fleetcode-648.html</url>
    <content type="text"><![CDATA[题目描述在英语中，我们有一个叫做 词根(root)的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。现在，给定一个由许多词根组成的词典和一个句子。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。你需要输出替换之后的句子。 示例 1:输入: dict(词典) = [“cat”, “bat”, “rat”]sentence(句子) = “the cattle was rattled by the battery”输出: “the cat was rat by the bat” 注: 输入只包含小写字母。 1 &lt;= 字典单词数 &lt;=1000 1 &lt;= 句中词语数 &lt;= 1000 1 &lt;= 词根长度 &lt;= 100 1 &lt;= 句中词语长度 &lt;= 1000 题解判断单词是否有词根前缀 示例代码(go)1234567891011func replaceWords(dict []string, sentence string) string &#123; arr := strings.Split(sentence, " ") for i := 0; i &lt; len(arr); i++ &#123; for _, root := range dict &#123; if strings.HasPrefix(arr[i], root) &#123; arr[i] = root &#125; &#125; &#125; return strings.Join(arr, " ")&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 49. 字母异位词分组]]></title>
    <url>%2Fleetcode-49.html</url>
    <content type="text"><![CDATA[题目描述给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例: 输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],输出:[ [“ate”,”eat”,”tea”], [“nat”,”tan”], [“bat”]]说明：所有输入均为小写字母。不考虑答案输出的顺序。 题解遍历strs数组，对word进行排序，判断str是否在hashMap中 示例代码(go)12345678910111213141516func groupAnagrams(strs []string) [][]string &#123; res := make([][]string, 0) hashMap := make(map[string]int) for _, word := range strs &#123; arr := strings.Split(word, "") sort.Strings(arr) str := strings.Join(arr, "") if i, ok := hashMap[str]; ok &#123; res[i] = append(res[i], word) &#125; else &#123; hashMap[str] = len(res) res = append(res, []string&#123;word&#125;) &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 434. 字符串中的单词数]]></title>
    <url>%2Fleetcode-434.html</url>
    <content type="text"><![CDATA[题目描述统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。请注意，你可以假定字符串里不包括任何不可打印的字符。 示例:输入: “Hello, my name is John”输出: 5 题解遍历字符串s，判断当前字符和前一个字符 示例代码(go)123456789func countSegments(s string) int &#123; res := 0 for i := 0; i &lt; len(s); i++ &#123; if s[i] != ' ' &amp;&amp; ( i == 0 || s[i-1] == ' ') &#123; res++ &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 859. 亲密字符串]]></title>
    <url>%2Fleetcode-859.html</url>
    <content type="text"><![CDATA[题目描述给定两个由小写字母构成的字符串 A 和 B ，只要我们可以通过交换 A 中的两个字母得到与 B 相等的结果，就返回 true ；否则返回 false 。 示例 1：输入： A = “ab”, B = “ba”输出： true 示例 2：输入： A = “ab”, B = “ab”输出： false 示例 3:输入： A = “aa”, B = “aa”输出： true 示例 4：输入： A = “aaaaaaabc”, B = “aaaaaaacb”输出： true 示例 5：输入： A = “”, B = “aa”输出： false 提示： 0 &lt;= A.length &lt;= 20000 0 &lt;= B.length &lt;= 20000 A 和 B 仅由小写字母构成。 题解分为两种情况，A和B相等，判断是否出现相同的两个字母；A和B不同，找出不同之处的索引值m和n进行判断 示例代码(go)1234567891011121314151617181920212223242526272829303132func buddyStrings(A string, B string) bool &#123; if len(A) != len(B) &#123; return false &#125; if A == B &#123; hashMap := make(map[byte]int) for i := 0; i &lt; len(A); i++ &#123; hashMap[A[i]]++ if hashMap[A[i]] == 2 &#123; return true &#125; &#125; return false &#125; else &#123; m, n := -1, -1 for i := 0; i &lt; len(A); i++ &#123; if A[i] != B[i] &#123; if m == -1 &#123; m = i &#125; else if n == -1 &#123; n = i &#125; else &#123; return false &#125; &#125; &#125; if n == -1 || A[m] != B[n] || A[n] != B[m] &#123; return false &#125; &#125; return true&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 404. 左叶子之和]]></title>
    <url>%2Fleetcode-404.html</url>
    <content type="text"><![CDATA[题目描述计算给定二叉树的所有左叶子之和。 示例： 3 / \ 9 20 / \ 15 7在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 题解找出左叶子节点，可以通过叶子节点的父节点进行判断 示例代码(go)123456789101112131415161718192021222324/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func sumOfLeftLeaves(root *TreeNode) int &#123; res := 0 if root == nil &#123; return 0 &#125; if root.Left != nil &amp;&amp; root.Left.Left == nil &amp;&amp; root.Left.Right == nil &#123; res += root.Left.Val &#125; if root.Left != nil &#123; res += sumOfLeftLeaves(root.Left) &#125; if root.Right != nil &#123; res += sumOfLeftLeaves(root.Right) &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 606. 根据二叉树创建字符串]]></title>
    <url>%2Fleetcode-606.html</url>
    <content type="text"><![CDATA[题目描述你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。 示例 1: 输入: 二叉树: [1,2,3,4] 1 / \ 2 3 / 4 输出: "1(2(4))(3)" 解释: 原本将是“1(2(4)())(3())”， 在你省略所有不必要的空括号对之后， 它将是“1(2(4))(3)”。 示例 2: 输入: 二叉树: [1,2,3,null,4] 1 / \ 2 3 \ 4 输出: "1(2()(4))(3)" 解释: 和第一个示例相似， 除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。 题解递归遍历，无效的括号包含两种情况，节点左右子树为空 或 节点右子树为空 示例代码(go)1234567891011121314151617181920/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func tree2str(t *TreeNode) string &#123; if t == nil &#123; return "" &#125; if t.Left == nil &amp;&amp; t.Right == nil &#123; return strconv.Itoa(t.Val) &#125; if t.Right == nil &#123; return strconv.Itoa(t.Val) + "(" + tree2str(t.Left) + ")" &#125; return strconv.Itoa(t.Val) + "(" + tree2str(t.Left) + ")" + "(" + tree2str(t.Right) + ")"&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 312. 戳气球]]></title>
    <url>%2Fleetcode-312.html</url>
    <content type="text"><![CDATA[题目描述有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] nums[i] nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。求所能获得硬币的最大数量。 说明: 你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 示例: 输入: [3,1,5,8] 输出: 167 解释: nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 题解动态规划，dp[i][j]表示戳爆从i到j个气球的最大金币数，依次戳爆1、2、3…n个气球，最终得到dp[1][n]表示最大金币数 示例代码(go)123456789101112131415161718192021func maxCoins(nums []int) int &#123; n := len(nums) dp := make([][]int, n+2) for i := 0; i &lt; n+2; i++ &#123; dp[i] = make([]int, n+1) &#125; nums = append(nums, 1) nums = append([]int&#123;1&#125;, nums...) for m := 1; m &lt;= n; m++ &#123; for i := 1; i &lt;= n-m+1; i++ &#123; j := i+m-1 for k := i; k &lt;= j; k++ &#123; sum := nums[i-1] * nums[k] * nums[j+1] + dp[i][k-1] + dp[k+1][j] if dp[i][j] &lt; sum &#123; dp[i][j] = sum &#125; &#125; &#125; &#125; return dp[1][n]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 228. 汇总区间]]></title>
    <url>%2Fleetcode-228.html</url>
    <content type="text"><![CDATA[题目描述给定一个无重复元素的有序整数数组，返回数组区间范围的汇总。 示例 1:输入: [0,1,2,4,5,7]输出: [“0-&gt;2”,”4-&gt;5”,”7”]解释: 0,1,2 可组成一个连续的区间; 4,5 可组成一个连续的区间。 示例 2:输入: [0,2,3,4,6,8,9]输出: [“0”,”2-&gt;4”,”6”,”8-&gt;9”]解释: 2,3,4 可组成一个连续的区间; 8,9 可组成一个连续的区间。 题解首先初始化start、end代表区间的首尾，然后遍历nums找出连续的数字 示例代码(go)12345678910111213141516171819202122232425262728func summaryRanges(nums []int) []string &#123; res := make([]string, 0) if len(nums) == 0 &#123; return res &#125; start, end := nums[0], nums[0] for i := 1; i &lt; len(nums); i++ &#123; if nums[i] == nums[i-1]+1 &#123; end = nums[i] continue &#125; res = append(res, sprintf(start, end)) start = nums[i] end = nums[i] &#125; res = append(res, sprintf(start, end)) return res&#125;func sprintf(start int, end int) string &#123; str := "" if start != end &#123; str = fmt.Sprintf("%d-&gt;%d", start, end) &#125; else &#123; str = fmt.Sprintf("%d", start) &#125; return str&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 647. 回文子串]]></title>
    <url>%2Fleetcode-647.html</url>
    <content type="text"><![CDATA[题目描述给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。 示例 1:输入: “abc”输出: 3解释: 三个回文子串: “a”, “b”, “c”. 示例 2:输入: “aaa”输出: 6说明: 6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”. 注意: 输入的字符串长度不会超过1000。 题解遍历字符串s，分为奇偶两种情况，例如，xax中的a是回文子串，则xax也是回文子串；xaax中的aa是回文子串，则xaax也是回文子串 示例代码(go)1234567891011121314151617181920func countSubstrings(s string) int &#123; length, res := len(s), 0 for i := 0; i &lt; length; i++ &#123; for j := 0; i-j &gt;= 0 &amp;&amp; i+j &lt; length; j++ &#123; if s[i+j] == s[i-j] &#123; res++ &#125; else &#123; break &#125; &#125; for j := 0; i-j &gt;= 0 &amp;&amp; i+j+1 &lt; length; j++ &#123; if s[i+j+1] == s[i-j] &#123; res++ &#125; else &#123; break &#125; &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 953. 验证外星语词典]]></title>
    <url>%2Fleetcode-953.html</url>
    <content type="text"><![CDATA[题目描述某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。 示例 1：输入：words = [“hello”,”leetcode”], order = “hlabcdefgijkmnopqrstuvwxyz”输出：true解释：在该语言的字母表中，’h’ 位于 ‘l’ 之前，所以单词序列是按字典序排列的。 示例 2：输入：words = [“word”,”world”,”row”], order = “worldabcefghijkmnpqstuvxyz”输出：false解释：在该语言的字母表中，’d’ 位于 ‘l’ 之后，那么 words[0] &gt; words[1]，因此单词序列不是按字典序排列的。 示例 3：输入：words = [“apple”,”app”], order = “abcdefghijklmnopqrstuvwxyz”输出：false解释：当前三个字符 “app” 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 “apple” &gt; “app”，因为 ‘l’ &gt; ‘∅’，其中 ‘∅’ 是空白字符，定义为比任何其他字符都小（更多信息）。 提示： 1 &lt;= words.length &lt;= 100 1 &lt;= words[i].length &lt;= 20 order.length == 26 在 words[i] 和 order 中的所有字符都是英文小写字母。 题解依次比较words中连续的两个单词，前一个单词的字典序大于后一个时返回false 示例代码(go)12345678910111213141516171819202122232425262728func isAlienSorted(words []string, order string) bool &#123; for i := 1; i &lt; len(words); i++ &#123; if compare(words[i-1], words[i], order) == 1 &#123; return false &#125; &#125; return true&#125;func compare(a string, b string, order string) int &#123; la, lb := len(a), len(b) for i, j := 0, 0; i &lt; la &amp;&amp; j &lt; lb; &#123; if strings.Index(order, string(a[i])) &gt; strings.Index(order, string(b[j])) &#123; return 1 &#125; if strings.Index(order, string(a[i])) &lt; strings.Index(order, string(b[j])) &#123; return -1 &#125; i++ j++ &#125; if la &gt; lb &#123; return 1 &#125; else if la &lt; lb &#123; return -1 &#125; return 0&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 77. 组合]]></title>
    <url>%2Fleetcode-77.html</url>
    <content type="text"><![CDATA[题目描述给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 示例: 输入: n = 4, k = 2输出:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 题解回溯，每一个组合都是递逐渐增的 示例代码(go)12345678910111213141516171819func combine(n int, k int) [][]int &#123; res := make([][]int, 0) backtrack(&amp;res, n, 1, k, []int&#123;&#125;) return res&#125;func backtrack(res *[][]int, n int, num int, k int, visit []int) &#123; if len(visit) == k &#123; tmp := make([]int, 0) tmp = append(tmp, visit...) *res = append(*res, tmp) &#125; else &#123; for i := num; i &lt;= n; i++ &#123; visit = append(visit, i) backtrack(res, n, i+1, k, visit) visit = visit[:len(visit)-1] &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 969. 煎饼排序]]></title>
    <url>%2Fleetcode-969.html</url>
    <content type="text"><![CDATA[题目描述给定数组 A，我们可以对其进行煎饼翻转：我们选择一些正整数 k &lt;= A.length，然后反转 A 的前 k 个元素的顺序。我们要执行零次或多次煎饼翻转（按顺序一次接一次地进行）以完成对数组 A 的排序。返回能使 A 排序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * A.length 范围内的有效答案都将被判断为正确。 示例 1：输入：[3,2,4,1]输出：[4,2,4,3]解释：我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。初始状态 A = [3, 2, 4, 1]第一次翻转后 (k=4): A = [1, 4, 2, 3]第二次翻转后 (k=2): A = [4, 1, 2, 3]第三次翻转后 (k=4): A = [3, 2, 1, 4]第四次翻转后 (k=3): A = [1, 2, 3, 4]，此时已完成排序。 示例 2：输入：[1,2,3]输出：[]解释：输入已经排序，因此不需要翻转任何内容。请注意，其他可能的答案，如[3，3]，也将被接受。 提示： 1 &lt;= A.length &lt;= 100 A[i] 是 [1, 2, …, A.length] 的排列 题解首先复制A的值到B，对B进行倒序排列，然后遍历B的值，并找出其在A中的位置，接着进行两次翻转，第一次翻转会先把值放在首位，第二次翻转则会把值依次放在后面，最终会完成排序 示例代码(go)123456789101112131415161718192021222324252627282930func pancakeSort(A []int) []int &#123; length := len(A) res := make([]int, 0) B := make([]int, 0) B = append(B, A...) sort.Sort(sort.Reverse(sort.IntSlice(B))) for i, v := range B &#123; index := find(A, v) res = append(res, index + 1) res = append(res, length - i) reverse(A, index + 1) reverse(A, length - i) &#125; return res&#125;func find(arr []int, num int) int &#123; for i, v := range arr &#123; if num == v &#123; return i &#125; &#125; return -1&#125;func reverse(arr []int, k int) &#123; for i := 0; i &lt; (k / 2); i++ &#123; arr[i], arr[k-i-1] = arr[k-i-1], arr[i] &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 129. 求根到叶子节点数字之和]]></title>
    <url>%2Fleetcode-129.html</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。计算从根到叶子节点生成的所有数字之和。 说明: 叶子节点是指没有子节点的节点。 示例 1: 输入: [1,2,3] 1 / \ 2 3 输出: 25 解释: 从根到叶子节点路径 1->2 代表数字 12. 从根到叶子节点路径 1->3 代表数字 13. 因此，数字总和 = 12 + 13 = 25. 示例 2: 输入: [4,9,0,5,1] 4 / \ 9 0 / \ 5 1 输出: 1026 解释: 从根到叶子节点路径 4->9->5 代表数字 495. 从根到叶子节点路径 4->9->1 代表数字 491. 从根到叶子节点路径 4->0 代表数字 40. 因此，数字总和 = 495 + 491 + 40 = 1026. 题解遍历二叉树，依次改变节点值，子节点值 = 子节点值 + 父节点值 * 10，最后返回所有叶子节点值的和 示例代码(go)1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func sumNumbers(root *TreeNode) int &#123; res := 0 if root == nil &#123; return res &#125; if root.Left != nil &#123; root.Left.Val += root.Val * 10 &#125; if root.Right != nil &#123; root.Right.Val += root.Val * 10 &#125; if root.Left == nil &amp;&amp; root.Right == nil &#123; res += root.Val &#125; res += sumNumbers(root.Left) res += sumNumbers(root.Right) return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 120. 三角形最小路径和]]></title>
    <url>%2Fleetcode-120.html</url>
    <content type="text"><![CDATA[题目描述给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。例如，给定三角形： [ [2], [3,4], [6,5,7], [4,1,8,3]]自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 题解自底向上依次选取最小值相加 示例代码(go)123456789101112func minimumTotal(triangle [][]int) int &#123; for i := len(triangle)-2; i &gt;= 0; i-- &#123; for j := 0; j &lt; len(triangle[i]); j++ &#123; if triangle[i+1][j] &gt; triangle[i+1][j+1] &#123; triangle[i][j] += triangle[i+1][j+1] &#125; else &#123; triangle[i][j] += triangle[i+1][j] &#125; &#125; &#125; return triangle[0][0]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 766. 托普利茨矩阵]]></title>
    <url>%2Fleetcode-766.html</url>
    <content type="text"><![CDATA[题目描述如果一个矩阵的每一方向由左上到右下的对角线上具有相同元素，那么这个矩阵是托普利茨矩阵。给定一个 M x N 的矩阵，当且仅当它是托普利茨矩阵时返回 True。 示例 1: 输入:matrix = [ [1,2,3,4], [5,1,2,3], [9,5,1,2]]输出: True解释:在上述矩阵中, 其对角线为:“[9]”, “[5, 5]”, “[1, 1, 1]”, “[2, 2, 2]”, “[3, 3]”, “[4]”。各条对角线上的所有元素均相同, 因此答案是True。 示例 2: 输入:matrix = [ [1,2], [2,2]]输出: False解释:对角线”[1, 2]”上的元素不同。说明: matrix 是一个包含整数的二维数组。 matrix 的行数和列数均在 [1, 20]范围内。 matrix[i][j] 包含的整数在 [0, 99]范围内。 题解遍历数组matrix，比较当前元素与下一个对角线元素 示例代码(go)12345678910111213func isToeplitzMatrix(matrix [][]int) bool &#123; isToeplitz := true m, n := len(matrix[0]), len(matrix) for i := 0; i &lt; n; i++ &#123; for j := 0; j &lt; m; j++ &#123; if (i+1) &lt; n &amp;&amp; (j+1) &lt; m &amp;&amp; matrix[i][j] != matrix[i+1][j+1] &#123; isToeplitz = false break &#125; &#125; &#125; return isToeplitz&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 508. 出现次数最多的子树元素和]]></title>
    <url>%2Fleetcode-508.html</url>
    <content type="text"><![CDATA[题目描述给出二叉树的根，找出出现次数最多的子树元素和。一个结点的子树元素和定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。然后求出出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的元素（不限顺序）。 示例 1 输入: 5 / \2 -3返回 [2, -3, 4]，所有的值均只出现一次，以任意顺序返回所有值。 示例 2 输入: 5 / \2 -5返回 [2]，只有 2 出现两次，-5 只出现 1 次。提示： 假设任意子树元素和均可以用 32 位有符号整数表示。 题解找出子树元素和的出现次数存入hashMap，出现次数最大值max 示例代码(go)1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func findFrequentTreeSum(root *TreeNode) []int &#123; arr := make([]int, 0) hashMap := make(map[int]int) max := 1 if root == nil &#123; return arr &#125; findMap(root, hashMap, &amp;max) for k, v := range hashMap &#123; if v == max &#123; arr = append(arr, k) &#125; &#125; return arr&#125;func findMap(root *TreeNode, hashMap map[int]int, max *int) int &#123; sum := root.Val if root.Left != nil &#123; sum += findMap(root.Left, hashMap, max) &#125; if root.Right != nil &#123; sum += findMap(root.Right, hashMap, max) &#125; hashMap[sum]++ if hashMap[sum] &gt; *max &#123; *max = hashMap[sum] &#125; return sum&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 451. 根据字符出现频率排序]]></title>
    <url>%2Fleetcode-451.html</url>
    <content type="text"><![CDATA[题目描述给定一个字符串，请将字符串里的字符按照出现的频率降序排列。 示例 1:输入:“tree”输出:“eert”解释:‘e’出现两次，’r’和’t’都只出现一次。因此’e’必须出现在’r’和’t’之前。此外，”eetr”也是一个有效的答案。 示例 2:输入:“cccaaa”输出:“cccaaa”解释:‘c’和’a’都出现三次。此外，”aaaccc”也是有效的答案。注意”cacaca”是不正确的，因为相同的字母必须放在一起。 示例 3:输入:“Aabb”输出:“bbAa”解释:此外，”bbaA”也是一个有效的答案，但”Aabb”是不正确的。注意’A’和’a’被认为是两种不同的字符。 题解创建字符串数组arr，字符位置表indexMap，遍历字符串s，如果字符已经存在arr中就加在后面，不存在则新增，然后根据arr中元素的字符串长度排序，最后返回连接后的字符串 示例代码(go)12345678910111213141516func frequencySort(s string) string &#123; arr := make([]string, 0) indexMap := make(map[rune]int) for _, v := range s &#123; if _, ok := indexMap[v]; ok &#123; arr[indexMap[v]] += string(v) &#125; else &#123; arr = append(arr, string(v)) indexMap[v] = len(arr) - 1 &#125; &#125; sort.Slice(arr, func(i, j int) bool &#123; return len(arr[i]) &gt; len(arr[j]) &#125;) return strings.Join(arr, "")&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 791. 自定义字符串排序]]></title>
    <url>%2Fleetcode-791.html</url>
    <content type="text"><![CDATA[题目描述字符串S和 T 只包含小写字符。在S中，所有字符只会出现一次。S 已经根据某种规则进行了排序。我们要根据S中的字符顺序对T进行排序。更具体地说，如果S中x在y之前出现，那么返回的字符串中x也应出现在y之前。返回任意一种符合条件的字符串T。 示例:输入:S = “cba”T = “abcd”输出: “cbad”解释:S中出现了字符 “a”, “b”, “c”, 所以 “a”, “b”, “c” 的顺序应该是 “c”, “b”, “a”.由于 “d” 没有在S中出现, 它可以放在T的任意位置. “dcba”, “cdba”, “cbda” 都是合法的输出。 注意: S的最大长度为26，其中没有重复的字符。 T的最大长度为200。 S和T只包含小写字符。 题解找出每个字母在S中的索引位置i，遍历T，与arr中相应位置的字符串合并 示例代码(go)123456789101112131415func customSortString(S string, T string) string &#123; arr := make([]string, 26) indexMap := make(map[rune]int) for i, v := range S &#123; indexMap[v] = i &#125; for _, v := range T &#123; if index, ok := indexMap[v]; ok &#123; arr[index] += string(v) &#125; else &#123; arr[25] += string(v) &#125; &#125; return strings.Join(arr, "")&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 938. 二叉搜索树的范围和]]></title>
    <url>%2Fleetcode-938.html</url>
    <content type="text"><![CDATA[题目描述给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。二叉搜索树保证具有唯一的值。 示例 1：输入：root = [10,5,15,3,7,null,18], L = 7, R = 15输出：32 示例 2：输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10输出：23 提示： 树中的结点数量最多为 10000 个。 最终的答案保证小于 2^31。 题解二叉搜索树的左边小于根，右边大于根，根值root.Val在L，R之间的就是我们要加上的值 示例代码(go)123456789101112131415161718192021222324/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func rangeSumBST(root *TreeNode, L int, R int) int &#123; res := 0 if root == nil &#123; return res &#125; if root.Val &gt;= L &amp;&amp; root.Val &lt;= R &#123; res += root.Val &#125; if root.Val &gt; L &#123; res += rangeSumBST(root.Left, L, R) &#125; if root.Val &lt; R &#123; res += rangeSumBST(root.Right, L, R) &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 419. 甲板上的战舰]]></title>
    <url>%2Fleetcode-419.html</url>
    <content type="text"><![CDATA[题目描述给定一个二维的甲板， 请计算其中有多少艘战舰。 战舰用 ‘X’表示，空位用 ‘.’表示。 你需要遵守以下规则： 给你一个有效的甲板，仅由战舰或者空位组成。 战舰只能水平或者垂直放置。换句话说,战舰只能由 1xN (1 行, N 列)组成，或者 Nx1 (N 行, 1 列)组成，其中N可以是任意大小。 两艘战舰之间至少有一个水平或垂直的空位分隔 - 即没有相邻的战舰。 示例 : X..X ...X ...X 在上面的甲板中有2艘战舰。 无效样例 : ...X XXXX ...X 你不会收到这样的无效甲板 - 因为战舰之间至少会有一个空位将它们分开。 题解左边和上边没有X的点位则为战舰 示例代码(go)1234567891011121314151617func countBattleships(board [][]byte) int &#123; res := 0 for i := 0; i &lt; len(board); i++ &#123; for j := 0; j &lt; len(board[i]); j++ &#123; if board[i][j] == 'X' &#123; if j-1 &gt;= 0 &amp;&amp; board[i][j-1] == 'X'&#123; continue &#125; if i-1 &gt;= 0 &amp;&amp; board[i-1][j] == 'X'&#123; continue &#125; res++ &#125; &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 748. 最短完整词]]></title>
    <url>%2Fleetcode-748.html</url>
    <content type="text"><![CDATA[题目描述如果单词列表（words）中的一个单词包含牌照（licensePlate）中所有的字母，那么我们称之为完整词。在所有完整词中，最短的单词我们称之为最短完整词。单词在匹配牌照中的字母时不区分大小写，比如牌照中的 “P” 依然可以匹配单词中的 “p” 字母。我们保证一定存在一个最短完整词。当有多个单词都符合最短完整词的匹配条件时取单词列表中最靠前的一个。牌照中可能包含多个相同的字符，比如说：对于牌照 “PP”，单词 “pair” 无法匹配，但是 “supper” 可以匹配。 示例 1：输入：licensePlate = “1s3 PSt”, words = [“step”, “steps”, “stripe”, “stepple”]输出：”steps”说明：最短完整词应该包括 “s”、”p”、”s” 以及 “t”。对于 “step” 它只包含一个 “s” 所以它不符合条件。同时在匹配过程中我们忽略牌照中的大小写。 示例 2：输入：licensePlate = “1s3 456”, words = [“looks”, “pest”, “stew”, “show”]输出：”pest”说明：存在 3 个包含字母 “s” 且有着最短长度的完整词，但我们返回最先出现的完整词。 注意: 牌照（licensePlate）的长度在区域[1, 7]中。 牌照（licensePlate）将会包含数字、空格、或者字母（大写和小写）。 单词列表（words）长度在区间 [10, 1000] 中。 每一个单词 words[i] 都是小写，并且长度在区间 [1, 15] 中。 题解记录牌照licensePlate中每个字母出现的次数，遍历单词表words找出符合要求的最短单词 示例代码(go)12345678910111213141516171819202122232425262728293031func shortestCompletingWord(licensePlate string, words []string) string &#123; licensePlateMap := make(map[rune]int) res := "" for _, v := range licensePlate &#123; if v &gt;= 'a' &amp;&amp; v &lt;= 'z' &#123; licensePlateMap[v] += 1 &#125; if v &gt;= 'A' &amp;&amp; v &lt;= 'Z' &#123; licensePlateMap[v -'A' + 'a'] += 1 &#125; &#125; for _, word := range words &#123; if res == "" || len(word) &lt; len(res) &#123; wordMap := make(map[rune]int) for _, v := range word &#123; wordMap[v] += 1 &#125; flag := true for k, v := range licensePlateMap &#123; if v &gt; wordMap[k] &#123; flag = false break &#125; &#125; if flag &#123; res = word &#125; &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 447. 回旋镖的数量]]></title>
    <url>%2Fleetcode-447.html</url>
    <content type="text"><![CDATA[题目描述给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。 示例:输入:[[0,0],[1,0],[2,0]]输出:2解释:两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]] 题解遍历每个点与其它点的距离，具有相同距离的点数如果为n的话，则有n * (n-1)种可能 示例代码(go)123456789101112131415161718func numberOfBoomerangs(points [][]int) int &#123; res := 0 for i := 0; i &lt; len(points); i++ &#123; hashMap := make(map[int]int) for j := 0; j &lt; len(points); j++ &#123; if i != j &#123; x := points[i][0] - points[j][0] y := points[i][1] - points[j][1] distance := x * x + y * y hashMap[distance]++ &#125; &#125; for _, n := range hashMap &#123; res += n * (n-1) &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 337. 打家劫舍 III]]></title>
    <url>%2Fleetcode-337.html</url>
    <content type="text"><![CDATA[题目描述在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 示例 1: 输入: [3,2,3,null,3,null,1] 3 / \ 2 3 \ \ 3 1 输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7. 示例 2: 输入: [3,4,5,1,3,null,1] 3 / \ 4 5 / \ \ 1 3 1 输出: 9 解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9. 题解两种情况，根的值加上不直接相连的左右子树的值，或者不要根植，直接是根的左右子树值的和，比较两种情况下的大小，同时可以加上哈希表返回已经计算过的值 示例代码(go)12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func rob(root *TreeNode) int &#123; stateMap := make(map[*TreeNode]int) return dfs(root, stateMap)&#125;func dfs(root *TreeNode, stateMap map[*TreeNode]int) int &#123; if root == nil &#123; return 0 &#125; if _, ok := stateMap[root]; ok &#123; return stateMap[root] &#125; res := root.Val if root.Left != nil &#123; res += dfs(root.Left.Left, stateMap) + dfs(root.Left.Right, stateMap) &#125; if root.Right != nil &#123; res += dfs(root.Right.Left, stateMap) + dfs(root.Right.Right, stateMap) &#125; val := dfs(root.Left, stateMap) + dfs(root.Right, stateMap) if res &lt; val &#123; res = val &#125; stateMap[root] = res return stateMap[root]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 62. 不同路径]]></title>
    <url>%2Fleetcode-62.html</url>
    <content type="text"><![CDATA[题目描述一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：m 和 n 的值均不超过 100。 示例 1:输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。 向右 -&gt; 向右 -&gt; 向下 向右 -&gt; 向下 -&gt; 向右 向下 -&gt; 向右 -&gt; 向右 示例 2:输入: m = 7, n = 3输出: 28 题解动态规划问题，机器人每次只能向下或者向右移动一步，所以每个格子的路径数等于上边格子加上左边格子的路径数和，即dp[i][j] = dp[i-1][j] + dp[i][j-1] 示例代码(go)12345678910111213141516func uniquePaths(m int, n int) int &#123; dp := make([][]int, m) for i := 0; i &lt; m; i++ &#123; dp[i] = make([]int, n) &#125; for i := 0; i &lt; m; i++ &#123; for j := 0; j &lt; n; j++ &#123; if i == 0 || j == 0 &#123; dp[i][j] = 1 &#125; else &#123; dp[i][j] = dp[i-1][j] + dp[i][j-1] &#125; &#125; &#125; return dp[m-1][n-1]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 937. 重新排列日志文件]]></title>
    <url>%2Fleetcode-937.html</url>
    <content type="text"><![CDATA[题目描述你有一个日志数组 logs。每条日志都是以空格分隔的字串。对于每条日志，其第一个字为字母数字标识符。然后，要么：标识符后面的每个字将仅由小写字母组成，或；标识符后面的每个字将仅由数字组成。我们将这两种日志分别称为字母日志和数字日志。保证每个日志在其标识符后面至少有一个字。将日志重新排序，使得所有字母日志都排在数字日志之前。字母日志按内容字母顺序排序，忽略标识符；在内容相同时，按标识符排序。数字日志应该按原来的顺序排列。返回日志的最终顺序。 示例 ：输入：[“a1 9 2 3 1”,”g1 act car”,”zo4 4 7”,”ab1 off key dog”,”a8 act zoo”]输出：[“g1 act car”,”a8 act zoo”,”ab1 off key dog”,”a1 9 2 3 1”,”zo4 4 7”] 提示： 0 &lt;= logs.length &lt;= 100 3 &lt;= logs[i].length &lt;= 100 logs[i] 保证有一个标识符，并且标识符后面有一个字。 题解分别找出字母日志和数字日志，并对字母日志进行排序 示例代码(go)1234567891011121314151617181920212223func reorderLogFiles(logs []string) []string &#123; res := make([]string, 0) letterRes := make([]string, 0) digitRes := make([]string, 0) letterMap := make(map[string]int) for i, v := range logs &#123; splitArr := strings.Split(v, " ") joinStr := strings.Join(splitArr[1:], "") if strings.ContainsAny(joinStr, "0123456789") &#123; digitRes = append(digitRes, v) continue &#125; joinStr = strings.Join(splitArr[1:], " ") letterMap[joinStr] = i letterRes = append(letterRes, joinStr) &#125; sort.Sort(sort.StringSlice(letterRes)) for _, v := range letterRes &#123; res = append(res, logs[letterMap[v]]) &#125; res = append(res, digitRes...) return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 749. 隔离病毒]]></title>
    <url>%2Fleetcode-749.html</url>
    <content type="text"><![CDATA[题目描述病毒扩散得很快，现在你的任务是尽可能地通过安装防火墙来隔离病毒。假设世界由二维矩阵组成，0 表示该区域未感染病毒，而 1 表示该区域已感染病毒。可以在任意 2 个四方向相邻单元之间的共享边界上安装一个防火墙（并且只有一个防火墙）。每天晚上，病毒会从被感染区域向相邻未感染区域扩散，除非被防火墙隔离。现由于资源有限，每天你只能安装一系列防火墙来隔离其中一个被病毒感染的区域（一个区域或连续的一片区域），且该感染区域对未感染区域的威胁最大且保证唯一。你需要努力使得最后有部分区域不被病毒感染，如果可以成功，那么返回需要使用的防火墙个数; 如果无法实现，则返回在世界被病毒全部感染时已安装的防火墙个数。 示例 1： 输入: grid =[[0,1,0,0,0,0,0,1], [0,1,0,0,0,0,0,1], [0,0,0,0,0,0,0,1], [0,0,0,0,0,0,0,0]]输出: 10说明:一共有两块被病毒感染的区域: 从左往右第一块需要 5 个防火墙，同时若该区域不隔离，晚上将感染 5 个未感染区域（即被威胁的未感染区域个数为 5）;第二块需要 4 个防火墙，同理被威胁的未感染区域个数是 4。因此，第一天先隔离左边的感染区域，经过一晚后，病毒传播后世界如下:[[0,1,0,0,0,0,1,1], [0,1,0,0,0,0,1,1], [0,0,0,0,0,0,1,1], [0,0,0,0,0,0,0,1]]第二天，只剩下一块未隔离的被感染的连续区域，此时需要安装 5 个防火墙，且安装完毕后病毒隔离任务完成。示例 2： 输入: grid =[[1,1,1], [1,0,1], [1,1,1]]输出: 4说明:此时只需要安装 4 面防火墙，就有一小区域可以幸存，不被病毒感染。注意不需要在世界边界建立防火墙。示例 3: 输入: grid =[[1,1,1,0,0,0,0,0,0], [1,0,1,0,1,1,1,1,1], [1,1,1,0,0,0,0,0,0]]输出: 13说明:在隔离右边感染区域后，隔离左边病毒区域只需要 2 个防火墙了。说明: grid 的行数和列数范围是 [1, 50]。 grid[i][j] 只包含 0 或 1 。 题目保证每次选取感染区域进行隔离时，一定存在唯一一个对未感染区域的威胁最大的区域。 题解找出每一处病毒区域和所需防火墙数的对应virusMap，以及每一处病毒区域威胁到的未感染的区块数目uninfectedCells，并找出最具威胁的病毒区域maxVirus；然后maxVirus对应的病毒区域变为2表示已隔离，其他病毒区域则感染周边区块变为1；继续下次循环直到virusMap[maxVirus] == 0 示例代码(go)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118func containVirus(grid [][]int) int &#123; firewalls := 0 if len(grid) == 0 &#123; return firewalls &#125; for &#123; virusMap, maxVirus := getVirusMap(grid) if virusMap[maxVirus] == 0 &#123; break &#125; cellsTo2(grid, virusMap, maxVirus) cellsTo1(grid, virusMap, maxVirus) firewalls += virusMap[maxVirus] &#125; return firewalls&#125;func getVirusMap(grid [][]int) (map[int]int, int) &#123; col := len(grid) row := len(grid[0]) direction := [][]int&#123;[]int&#123;0, -1&#125;, []int&#123;-1, 0&#125;, []int&#123;0, 1&#125;, []int&#123;1, 0&#125;&#125; maxUninfectedCells := 0 maxVirus := 0 virusMap := make(map[int]int) infectedCellsVisted := make(map[int]bool) for i := 0; i &lt; col; i++ &#123; for j := 0; j &lt; row; j++ &#123; if grid[i][j] == 1 &amp;&amp; !infectedCellsVisted[i*row+j] &#123; virusList := []int&#123;i*row+j&#125; infectedCellsVisted[i*row+j] = true uninfectedCellsVisted := make(map[int]bool) needWalls := 0 uninfectedCells := 0 for len(virusList) &gt; 0 &#123; virus := virusList[0] virusList = virusList[1:] for _, v := range direction &#123; ii := virus / row + v[0] jj := virus % row + v[1] if ii &gt;= 0 &amp;&amp; ii &lt; col &amp;&amp; jj &gt;= 0 &amp;&amp; jj &lt; row &#123; if grid[ii][jj] == 0 &#123; needWalls++ &#125; if grid[ii][jj] == 0 &amp;&amp; !uninfectedCellsVisted[ii*row+jj] &#123; uninfectedCellsVisted[ii*row+jj] = true uninfectedCells++ &#125; if grid[ii][jj] == 1 &amp;&amp; !infectedCellsVisted[ii*row+jj] &#123; infectedCellsVisted[ii*row+jj] = true virusList = append(virusList, ii*row+jj) &#125; &#125; &#125; &#125; virusMap[i*row+j] = needWalls if uninfectedCells &gt; maxUninfectedCells &#123; maxUninfectedCells = uninfectedCells maxVirus = i * row +j &#125; &#125; &#125; &#125; return virusMap, maxVirus&#125;func cellsTo2(grid [][]int, virusMap map[int]int, maxVirus int) &#123; col := len(grid) row := len(grid[0]) direction := [][]int&#123;[]int&#123;0, -1&#125;, []int&#123;-1, 0&#125;, []int&#123;0, 1&#125;, []int&#123;1, 0&#125;&#125; virusList := []int&#123;maxVirus&#125; grid[maxVirus / row][maxVirus % row] = 2 for len(virusList) &gt; 0 &#123; virus := virusList[0] virusList = virusList[1:] for _, v := range direction &#123; ii := virus / row + v[0] jj := virus % row + v[1] if ii &gt;= 0 &amp;&amp; ii &lt; col &amp;&amp; jj &gt;= 0 &amp;&amp; jj &lt; row &#123; if grid[ii][jj] == 1 &#123; grid[ii][jj] = 2 virusList = append(virusList, ii*row+jj) &#125; &#125; &#125; &#125;&#125;func cellsTo1(grid [][]int, virusMap map[int]int, maxVirus int) &#123; visted := make(map[int]bool) col := len(grid) row := len(grid[0]) direction := [][]int&#123;[]int&#123;0, -1&#125;, []int&#123;-1, 0&#125;, []int&#123;0, 1&#125;, []int&#123;1, 0&#125;&#125; for k,_ := range virusMap &#123; if k != maxVirus &#123; virusList := []int&#123;k&#125; visted[k] = true for len(virusList) &gt; 0 &#123; virus := virusList[0] virusList = virusList[1:] for _, v := range direction &#123; ii := virus / row + v[0] jj := virus % row + v[1] if ii &gt;= 0 &amp;&amp; ii &lt; col &amp;&amp; jj &gt;= 0 &amp;&amp; jj &lt; row &#123; if grid[ii][jj] == 0 &#123; grid[ii][jj] = 1 visted[ii*row+jj] = true &#125; if grid[ii][jj] == 1 &amp;&amp; !visted[ii*row+jj] &#123; visted[ii*row+jj] = true virusList = append(virusList, ii*row+jj) &#125; &#125; &#125; &#125; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 628. 三个数的最大乘积]]></title>
    <url>%2Fleetcode-628.html</url>
    <content type="text"><![CDATA[题目描述给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。 示例 1:输入: [1,2,3]输出: 6 示例 2:输入: [1,2,3,4]输出: 24 注意: 给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。 输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。 题解找出最大的三个数和最小的两个数，比较最大三个数的乘积和最小两个数与最大数的乘积 示例代码(go)12345678910111213141516171819202122232425func maximumProduct(nums []int) int &#123; res := 0 firstMax, secondMax, thirdMax := math.MinInt32, math.MinInt32, math.MinInt32 firstMin, secondMin := math.MaxInt32, math.MaxInt32 for _, v := range nums &#123; if v &gt; firstMax &#123; firstMax, secondMax, thirdMax = v, firstMax, secondMax &#125; else if v &gt; secondMax &#123; secondMax, thirdMax = v, secondMax &#125; else if v &gt; thirdMax &#123; thirdMax = v &#125; if v &lt; firstMin &#123; firstMin, secondMin = v, firstMin &#125; else if v &lt; secondMin &#123; secondMin = v &#125; &#125; res = firstMax * secondMax * thirdMax if res &lt; firstMin * secondMin * firstMax &#123; res = firstMin * secondMin * firstMax &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 638. 大礼包]]></title>
    <url>%2Fleetcode-638.html</url>
    <content type="text"><![CDATA[题目描述在LeetCode商店中， 有许多在售的物品。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。任意大礼包可无限次购买。 示例 1:输入: [2,5], [[3,0,5],[1,2,10]], [3,2]输出: 14解释:有A和B两种物品，价格分别为¥2和¥5。大礼包1，你可以以¥5的价格购买3A和0B。大礼包2， 你可以以¥10的价格购买1A和2B。你需要购买3个A和2个B， 所以你付了¥10购买了1A和2B（大礼包2），以及¥4购买2A。 示例 2:输入: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]输出: 11解释:A，B，C的价格分别为¥2，¥3，¥4.你可以用¥4购买1A和1B，也可以用¥9购买2A，2B和1C。你需要买1A，2B和1C，所以你付了¥4买了1A和1B（大礼包1），以及¥3购买1B， ¥4购买1C。你不可以购买超出待购清单的物品，尽管购买大礼包2更加便宜。 说明: 最多6种物品， 100种大礼包。 每种物品，你最多只需要购买6个。 你不可以购买超出待购清单的物品，即使更便宜。 题解迭代，如果某个礼包special[i]是可以合法购买的（礼包物品的数量小于预购物品数），则以该礼包的价格special[i][len(needs)]加上购买剩余商品的最低价格，即对remainNeeds进行迭代 示例代码(go)123456789101112131415161718192021222324func shoppingOffers(price []int, special [][]int, needs []int) int &#123; minPrice := 0 for i := 0; i &lt; len(price); i++ &#123; minPrice += price[i] * needs[i] &#125; for i := 0; i &lt; len(special); i++ &#123; isValid := true remainNeeds := make([]int, len(needs)) for j := 0; j &lt; len(needs); j++ &#123; if special[i][j] &gt; needs[j] &#123; isValid = false break &#125; remainNeeds[j] = needs[j] - special[i][j] &#125; if isValid &#123; price := shoppingOffers(price, special, remainNeeds) + special[i][len(needs)] if price &lt; minPrice &#123; minPrice = price &#125; &#125; &#125; return minPrice&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 401. 二进制手表]]></title>
    <url>%2Fleetcode-401.html</url>
    <content type="text"><![CDATA[题目描述二进制手表顶部有 4 个 LED 代表小时（0-11），底部的 6 个 LED 代表分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。 例如，上面的二进制手表读取 “3:25”。给定一个非负整数 n 代表当前 LED 亮着的数量，返回所有可能的时间。 案例:输入: n = 1返回: [“1:00”, “2:00”, “4:00”, “8:00”, “0:01”, “0:02”, “0:04”, “0:08”, “0:16”, “0:32”] 注意事项: 输出的顺序没有要求。 小时不会以零开头，比如 “01:00” 是不允许的，应为 “1:00”。 分钟必须由两位数组成，可能会以零开头，比如 “10:2” 是无效的，应为 “10:02”。 题解前六位代表分钟，后四位代表时钟，组成十位二进制，当num=1时，共计0000000001~1000000000 10种可能，换成十进制即是1~512，因为前六位代表的分钟，所以hour小时就等于十进制数值除以64，minute分钟则是对64取模，当num=2,3,4...时，对于bits每一个值，左边依次找一个二进制位变为1，比如0000010000可以变成0000110000, 0001010000一直到1000010000，同时也要排除掉大于768和在[60,64]之间的值，因为时钟不能为12，分钟不能大于59 示例代码(go)123456789101112131415161718192021222324252627282930func readBinaryWatch(num int) []string &#123; times := []string&#123;&#125; if num == 0 &#123; return []string&#123;"0:00"&#125; &#125; bits := []int&#123;1&#125; for i := 0; i &lt; 9; i++ &#123; bits = append(bits, bits[i]*2) &#125; for i := 1; i &lt; num; i++ &#123; nextBits := []int&#123;&#125; for _, v := range bits &#123; for add := 1; add &lt;= 512; add *= 2 &#123; if v + add &gt;= 768 || (v + add &gt;= 60 &amp;&amp; v + add &lt; 64) &#123; continue &#125; if add &gt; v &#123; nextBits = append(nextBits, v + add) &#125; &#125; &#125; bits = nextBits &#125; for _, v := range bits &#123; hour := v / 64 minute := v % 64 times = append(times, fmt.Sprintf("%d:%02d", hour, minute)) &#125; return times&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 932. 漂亮数组]]></title>
    <url>%2Fleetcode-932.html</url>
    <content type="text"><![CDATA[题目描述对于某些固定的 N，如果数组 A 是整数 1, 2, …, N 组成的排列，使得：对于每个 i &lt; j，都不存在 k 满足 i &lt; k &lt; j 使得 A[k] * 2 = A[i] + A[j]。那么数组 A 是漂亮数组。给定 N，返回任意漂亮数组 A（保证存在一个）。 示例 1：输入：4输出：[2,1,4,3] 示例 2：输入：5输出：[3,1,2,5,4] 提示：1 &lt;= N &lt;= 1000 题解可以知道A[k] * 2是一个偶数， 当 i &lt; k &lt; j时，为了使 A[k] * 2 != A[i] + A[j]，可以让左边全奇数，右边全偶数 示例代码(go)1234567891011121314151617func beautifulArray(N int) []int &#123; res := make([]int, 0) if N == 1 &#123; return []int&#123;1&#125; &#125; left := beautifulArray((N +1) / 2) right := beautifulArray(N / 2) for _, v := range left &#123; res = append(res, 2 * v - 1) &#125; for _, v := range right &#123; res = append(res, 2 * v) &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 547. 朋友圈]]></title>
    <url>%2Fleetcode-547.html</url>
    <content type="text"><![CDATA[题目描述班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。 示例 1: 输入:[[1,1,0], [1,1,0], [0,0,1]]输出: 2说明：已知学生0和学生1互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回2。示例 2: 输入:[[1,1,0], [1,1,1], [0,1,1]]输出: 1说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。注意： N 在[1,200]的范围内。 对于所有学生，有M[i][i] = 1。 如果有M[i][j] = 1，则有M[j][i] = 1。 题解广度搜索的思想，如果某学生还没有出现在visited数组中，则朋友圈数count加一，并加入队列queue，然后搜索是朋友关系的同学加入queue 示例代码(go)12345678910111213141516171819202122func findCircleNum(M [][]int) int &#123; students := len(M[0]) visited := make([]int, students) count := 0 for i := 0; i &lt; students; i++ &#123; if visited[i] == 0 &#123; count++ visited[i] = 1 queue := []int&#123;i&#125; for len(queue) &gt; 0 &#123; for j := 0; j &lt; students; j++ &#123; if visited[j] == 0 &amp;&amp; M[queue[0]][j] == 1 &#123; visited[j] = 1 queue = append(queue, j) &#125; &#125; queue = queue[1:] &#125; &#125; &#125; return count&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[python环境安装]]></title>
    <url>%2Fpython-install.html</url>
    <content type="text"><![CDATA[python安装Anaconda 是一个用于科学计算的 Python 发行版，支持 Linux, Mac, Windows, 包含了许多常用的科学计算、数据分析的 Python包。下载地址Anaconda，版本的话建议选python3，各个平台的安装都不算太复杂，照着步骤安装就行了。 conda简单使用conda是一个开源包管理系统和环境管理系统，包含在Anaconda安装中，下面是一些简单的命令。 显示版本信息 conda --version 查看当前环境下已安装的包 conda list 安装包 conda install requests 更新包 conda update requests 删除包 conda remove requests 配置国内镜像conda在国内安装包的时候可能会很慢，可以配置国内源加速下载，下面是清华源的配置123conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls yes]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 328. 奇偶链表]]></title>
    <url>%2Fleetcode-328.html</url>
    <content type="text"><![CDATA[题目描述给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。 示例 1:输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL 示例 2:输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL 说明: 应当保持奇数节点和偶数节点的相对顺序。 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。 题解分成奇链和偶链两条链，然后把奇链的尾指向偶链的头 示例代码(go)12345678910111213func oddEvenList(head *ListNode) *ListNode &#123; if head == nil&#123; return nil &#125; odd, even, evenHead := head, head.Next, head.Next for even != nil &amp;&amp; even.Next != nil&#123; odd.Next, even.Next = even.Next, even.Next.Next odd = odd.Next even = even.Next &#125; odd.Next = evenHead return head&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 14. 最长公共前缀]]></title>
    <url>%2Fleetcode-14.html</url>
    <content type="text"><![CDATA[题目描述编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。 示例 1:输入: [“flower”,”flow”,”flight”]输出: “fl” 示例 2:输入: [“dog”,”racecar”,”car”]输出: “”解释: 输入不存在公共前缀。 说明:所有输入只包含小写字母 a-z 。 题解strs数组中首个字符串与其余字符串，分别比较它们的每一位，如果全部相同则加入到prefix中 示例代码(go)123456789101112131415161718func longestCommonPrefix(strs []string) string &#123; prefix := make([]byte, 0) strsNums := len(strs) if strsNums == 0 &#123; return "" &#125; nums := len(strs[0]) for i := 0; i &lt; nums; i++ &#123; for j := 1; j &lt; strsNums; j++ &#123; if len(strs[j]) == i || strs[j][i] != strs[0][i] &#123; return string(prefix) &#125; &#125; prefix = append(prefix, strs[0][i]) &#125; return string(prefix)&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 739. Daily Temperatures 每日温度]]></title>
    <url>%2Fleetcode-739.html</url>
    <content type="text"><![CDATA[题目描述根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 题解数组stack作为栈，通过append和切片模拟入栈出栈操作 迭代数组T 数组T的索引0入栈 迭代的值大于栈顶索引的值，即v &gt; T[stack[len(stack)-1]]，则栈顶元素出栈，并存入res 重复步骤3, 直到栈为空 或 v不大于T[stack[len(stack)-1]] 数组T迭代完毕，返回数组res 示例代码(go)12345678910111213141516func dailyTemperatures(T []int) []int &#123; res := make([]int, len(T)) stack := make([]int, 0) for i, v := range T &#123; for len(stack) &gt; 0 &#123; if v &gt; T[stack[len(stack)-1]] &#123; res[stack[len(stack)-1]] = i - stack[len(stack)-1] stack = stack[:len(stack)-1] &#125; else &#123; break &#125; &#125; stack = append(stack, i) &#125; return res&#125;]]></content>
  </entry>
</search>
